<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Developer way: improve your technical skills with in-depth explanations, practical
      advices and useful tips and tricks.
    </title>
    <link>https://www.developerway.com</link>
    <description>Improve your technical skills with in-depth explanations, practical advices and
      useful tips and tricks. Techstack: React, Typescript, node, monorepos, yarn, webpack, etc.
    </description>
    <lastBuildDate>Fri, 07 Oct 2022 11:25:34 GMT</lastBuildDate>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <generator>https://github.com/jpmonette/feed</generator>
    <language>en</language>
    <image>
      <title>Developer way: improve your technical skills with in-depth explanations, practical
        advices and useful tips and tricks.
      </title>
      <url>https://www.developerway.com/intro.png</url>
      <link>https://www.developerway.com</link>
    </image>
    <copyright>All rights reserved 2022, Nadia Makarevich</copyright>
    <item>
      <title><![CDATA[How to fetch data in React with performance in mind]]></title>
      <link>https://www.developerway.com/posts/how-to-fetch-data-in-react</link>
      <guid>how-to-fetch-data-in-react</guid>
      <pubDate>Thu, 06 Oct 2022 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Deep dive into data fetching in React. What is performance, fundamental libraries-agnostic patterns and techniques, how react lifecycle and browser limitations affect data fetching and apps rendering time and order.]]></description>
      <content:encoded><![CDATA[<p>Have you tried recently to wrap your head around what‚Äôs the latest on data fetching in React? I tried. Almost lost my mind in the process. The chaos of endless data management libraries, GraphQL or not GraphQL, recent React 18 &amp; useEffect <a href="https://www.reddit.com/r/reactjs/comments/vi6q6f/what_is_the_recommended_way_to_load_data_for">scandal</a>, <code>useEffect</code> is evil since it causes waterfalls, <code>Suspence</code> for data fetching is supposed to save the world, but is still marked as <a href="https://17.reactjs.org/docs/concurrent-mode-suspense.html">Experimental</a>, <code>fetch-on-render</code>, <code>fetch-then-render</code> and <code>render-as-you-fetch</code> patterns that <a href="https://twitter.com/housecor/status/1531675927997997057?s=20&amp;t=Oe3T-aFhyTKJl5LH3s56TA">confuse even people who write about them</a>. What on Earth is going on? Why do I suddenly need a PhD to just make a simple GET request? üò≠</p>
<p>And what is the actual ‚Äúright way‚Äù to fetch data in React now?</p>
<p>Let‚Äôs take a look.</p>
<h2 id="part1"><a href="#part1">Types of data fetching</a></h2>
<p>Generally speaking, in the modern frontend world, we can loosely separate the concept of ‚Äúdata fetching‚Äù into two categories: initial data fetching and data fetching on demand.</p>
<p>Data <strong>on demand</strong> is something that you fetch after a user interacts with a page, in order to update their experience. All the various autocompletes, dynamic forms, and search experiences fall under that category. In React, fetch of this data is usually triggered in callbacks.</p>
<p><strong>Initial data</strong> is the data you‚Äôd expect to see on a page right away when you open it. It‚Äôs the data we need to fetch before a component ends up on the screen. It‚Äôs something that we need to be able to show users some meaningful experience as soon as possible. In React, fetching data like this usually happens in <code>useEffect</code> (or in <code>componentDidMount</code> for class components).</p>
<p>Interestingly enough, although those concepts seem totally different, the core principles and fundamental patterns of data fetching are exactly the same for them both. But the initial data fetching is usually the most crucial for the majority of people. During this stage, the first impression of your apps as ‚Äúslow as hell‚Äù or ‚Äúblazing fast‚Äù will form. That‚Äôs why for the rest of the article I will be focusing solely on initial data fetching and how to do it properly with performance in mind.</p>
<h2 id="part2"><a href="#part2">Do I really need an external library to fetch data in React?</a></h2>
<p>First thing first. External libraries for data fetching in React - yes or no?</p>
<p>Short answer - no. And yes. Depends on your use case üòÖ If you <em>actually</em> just need to fetch a bit of data once and forget about it, then no, you don‚Äôt need anything. Just a simple <code>fetch</code> in <code>useEffect</code> hook will do just fine:</p>
<pre><code class="language-tsx">const Component = () =&gt; {
  const [data, setData] = useState();

  useEffect(() =&gt; {
    // fetch data
    const dataFetch = async () =&gt; {
      const data = await (
        await fetch(
          &quot;https://run.mocky.io/v3/b3bcb9d2-d8e9-43c5-bfb7-0062c85be6f9&quot;
        )
      ).json();

      // set state when the data received
      setState(data);
    };

    dataFetch();
  }, []);

  return &lt;&gt;...&lt;/&gt;
}
</code></pre>
<p><a href="https://codesandbox.io/s/example1-simplest-fetch-ktb0bw?file=/src/App.tsx:203-461">See example in codesandbox</a></p>
<p>But as soon as your use case exceeds ‚Äúfetch once and forget‚Äù you‚Äôre going to face tough questions. What about error handling? What if multiple components want to fetch data from this exact endpoint? Do I cache that data? For how long? What about race conditions? What if I want to remove the component from the screen? Should I cancel this request? What about memory leaks? And so on and so forth. Dan Abramov <a href="https://www.reddit.com/r/reactjs/comments/vi6q6f/comment/iddrjue">explained the situation really well</a>, highly recommend reading for more details.</p>
<p>Not a single question from that list is even React specific, it‚Äôs a general problem of fetching data over the network. And to solve those problems (and more!) there are only two paths: you either need to re-invent the wheel and write <em>a lot of code</em> to solve those, or just rely on some existing library that has been doing this for years.</p>
<p>Some libraries, like <a href="https://github.com/axios/axios">axios</a>, will abstract some concerns, like canceling requests, but will have no opinion on React-specific API. Others, like <a href="https://swr.vercel.app/docs/getting-started">swr</a>, will handle pretty much everything for you, including caching. But essentially, the choice of technology doesn‚Äôt matter much here. No library or Suspense in the world can improve performance of your app just by itself. They just make some things easier at the cost of making some things harder. You <strong>always</strong> need to understand the fundamentals of data fetching and data orchestration patterns and techniques in order to write performant apps.</p>
<h2 id="part3"><a href="#part3">What is a ‚Äúperformant‚Äù React app?</a></h2>
<p>Before jumping into concrete patterns and code examples, let‚Äôs have a conversation on what ‚Äúperformance‚Äù of an app is. How do you know whether an app is ‚Äúperformant‚Äù? It‚Äôs relatively straightforward with a simple component: you just measure how long it takes to render it, and voila! The smaller the number, the more ‚Äúperformant‚Äù (i.e. faster) your component is.</p>
<p>With async operations, which data fetching typically is, and in the context of big apps and user experience point of view it‚Äôs not that obvious.</p>
<p>Imagine we were implementing an issue view for an issue tracker. It would have sidebar navigation on the left with a bunch of links; the main issue information in the center - things like title, description or assignee; and a section with comments underneath that.</p>
<p><img src="/assets/how-to-fetch-data-in-react/issue-view-example.png" alt=""/></p>
<p>And let‚Äôs say the app is implemented in three different ways:</p>
<ol>
<li>Shows a loading state until all the data is loaded, and then renders everything in one go. Takes ~3 seconds.</li>
<li>Shows a loading state until sidebar data is loaded first, renders sidebar, and keeps loading state until the data is finished in the main part. The sidebar to appear takes ~1 second, the rest of the app appears in ~3 seconds. Overall takes ~ 4 seconds.</li>
<li>Shows a loading state until main issue data is loaded, renders it, keeps loading state for sidebar and comments. When sidebar loaded - renders it, comments are still in loading state. Main part appears in ~2 seconds, sidebar in ~1 second after that, takes another ~2 second for comments to appear. Overall takes ~5s to appear.</li>
</ol>
<p>Which app is the most performant here? What do you think?</p>
<p>Play around with the apps <a href="https://codesandbox.io/s/app-one-load-all-with-skeleton-vlyq63?file=/src/App.tsx">One</a>, <a href="https://codesandbox.io/s/app-two-load-sidebar-first-t42f7q?file=/src/App.tsx">Two</a> and <a href="https://codesandbox.io/s/app-three-load-issue-first-ovjcti?file=/src/App.tsx:992-1012">Three</a> and make a decision before scrolling to the answer.</p>
<p>‚Ä¶</p>
<p>‚Ä¶</p>
<p>‚Ä¶</p>
<p>And the answer is of course tricky, and the most performant app is not the one that you chose, but‚Ä¶ None of them. Or all of them. Or any of them. It depends.</p>
<p>The <strong>first app</strong> loads in just 3 seconds - the fastest of them all. From the pure numbers perspective, it‚Äôs a clear winner. But it doesn‚Äôt show anything to users for 3 seconds - the longest of them all. Clear loser?</p>
<p>The <strong>second app</strong> loads something on the screen (Sidebar) in just 1 second. From the perspective of showing at least something as fast as possible, it‚Äôs a clear winner. But it‚Äôs the longest of them all to show the main part of the issue. Clear loser?</p>
<p>The <strong>third app</strong> loads the Issue information first. From the perspective of showing the main piece of the app first, it‚Äôs a clear winner. But the ‚Äúnatural‚Äù flow of information for left-to-right languages is from the top-left to the bottom-right. This is how we read usually. This app violates it and it makes the experience the most ‚Äújunky‚Äù one here. Not to mention it‚Äôs the longest of them all to load. Clear loser?</p>
<p>It <strong>always</strong> depends on the message you‚Äôre trying to convey to the users. Think of yourself as a storyteller, and the app is your story. What is the most important piece of the story? What is the second? Does your story have a flow? Can you even tell it in pieces, or you want your users to see the story in full right away, without any intermediate steps?</p>
<p>When, and only when, you have an idea of what your story should look like, then it will be the time to assemble the app and optimize the story to be as fast as possible. And the true power comes here not from various libraries, Graphql or Suspense, but from the knowledge of:</p>
<ul>
<li>when is it okay to start fetching data?</li>
<li>what can we do while the data fetching is in the progress?</li>
<li>what should we do when the data fetching is done?</li>
</ul>
<p>and knowing a few techniques that allow you to control all three stages of the data fetching requests.</p>
<p>But before jumping into actual techniques, we need to understand two more very fundamental things: React lifecycle and browser resources and their influence on our goal.</p>
<h2 id="part4"><a href="#part4">React lifecycle and data fetching</a></h2>
<p>The most important thing to know and remember, when planning your fetch requests strategy, is when React component‚Äôs lifecycle is triggered. Check out this code:</p>
<pre><code class="language-tsx">const Child = () =&gt; {
  useEffect(() =&gt; {
    // do something here, like fetching data for the Child
  }, []);

  return &lt;div&gt;Some child&lt;/div&gt;
};

const Parent = () =&gt; {
  // set loading to true initially
  const [isLoading, setIsLoading] = useState(true);

  if (isLoading) return &#x27;loading&#x27;;

  return &lt;Child /&gt;;
}
</code></pre>
<p>We have our <code>Parent</code> component, it conditionally renders <code>Child</code> component based on state. Will Child‚Äôs <code>useEffect</code> , and therefore the fetch request there, be triggered here? The intuitive answer here is the correct one - it won‚Äôt. <em>Only</em> after Parent‚Äôs <code>isLoading</code> state changes to <code>false</code>, will the rendering and all other effects be triggered in the <code>Child</code> component.</p>
<p>What about this code for the <code>Parent</code>:</p>
<pre><code class="language-tsx">const Parent = () =&gt; {
  // set loading to true initially
  const [isLoading, setIsLoading] = useState(true);

  // child is now here! before return
  const child = &lt;Child /&gt;;

  if (isLoading) return &#x27;loading&#x27;;

  return child;
}
</code></pre>
<p>Functionality is the same: if isLoading set to false show <code>Child</code>, if <code>true</code> - show the loading state. But the <code>&lt;Child /&gt;</code> element this time is before the if condition. Will the <code>useEffect</code> in <code>Child</code> be triggered this time? And the answer is now less intuitive, and I‚Äôve seen a lot of people stumble here. The answer is still the same - no, it won&#x27;t.</p>
<p>When we write <code>const child = &lt;Child /&gt;</code> we don‚Äôt ‚Äúrender‚Äù <code>Child</code> component. <code>&lt;Child /&gt;</code> is nothing more than a syntax sugar for a function that creates a <em>description</em> of a future element. It only is rendered when this description ends up in the actual visible render tree - i.e. returned from the component. Until then it just sits there idly as one massive object and does nothing.</p>
<p>If you want to understand in more detail and with code examples how it works and all the possible edge cases, this article might be interesting to you: <a href="https://www.developerway.com/posts/react-elements-children-parents">The mystery of React Element, children, parents and re-renders</a>.</p>
<p>There are more things to know about React lifecycle of course: the order in which all of this is triggered, what is triggered before or after painting, what slows down what and how, <code>useLayoutEffect</code> hook, etc. But all of this becomes relevant much much later, when you orchestrated everything perfectly already and now fighting for milliseconds in a very big complicated app. So a topic for another article, otherwise this one will turn into a book.</p>
<h2 id="part5"><a href="#part5">Browser limitations and data fetching</a></h2>
<p>You might be thinking at this point: gosh, it‚Äôs so complicated. Can‚Äôt we just fire all the requests as soon as possible, shove that data in some global store, and then just use it when it‚Äôs available? Why even bother with the lifecycle and orchestration of anything?</p>
<p>I feel ya. And sure, we can do it, if the app is simple and only have a few requests to make ever. But in large apps, where we can have dozens of data fetching requests, that strategy can backfire. And I‚Äôm not even talking about server load and whether it can handle it. Let‚Äôs assume that it can. The problem is that our browsers can‚Äôt!</p>
<p>Did you know, that browsers have a limit on how many requests in parallel to the same host they can handle? Assuming the server is HTTP1 (which is still 70% of the internet), the number is not that big. In Chrome it‚Äôs <a href="https://developer.chrome.com/docs/devtools/network/reference/?utm_source=devtools#timing-explanation">just 6</a>. 6 requests in parallel! If you fire more at the same time, all the rest of them will have to queue and wait for the first available ‚Äúslot‚Äù.</p>
<p>And 6 requests for initial data fetching in a big app is not unreasonable. Our very simple ‚Äúissue tracker‚Äù already has 3, and we haven‚Äôt even implemented anything of value yet. Imagine all the angry looks you‚Äôll get, if you just add a somewhat slow analytics request that literally does nothing at the very beginning of the app, and it ends up slowing down the entire experience.</p>
<p>Wanna see it in action? Here‚Äôs the simplest code:</p>
<pre><code class="language-tsx">const App = () =&gt; {
  // I extracted fetching and useEffect into a hook
  const { data } = useData(&#x27;/fetch-some-data&#x27;);

  if (!data) return &#x27;loading...&#x27;;

  return &lt;div&gt;I&#x27;m an app&lt;/div&gt;
}
</code></pre>
<p>Assume that fetch request is super fast there, takes just ~50ms. If I add just 6 requests before that app that take 10 seconds, without waiting for them or resolving them, the whole app load will take those 10 seconds (in Chrome of course).</p>
<pre><code class="language-tsx">// no waiting, no resolving, just fetch and drop it
fetch(&#x27;https://some-url.com/url1&#x27;);
fetch(&#x27;https://some-url.com/url2&#x27;);
fetch(&#x27;https://some-url.com/url3&#x27;);
fetch(&#x27;https://some-url.com/url4&#x27;);
fetch(&#x27;https://some-url.com/url5&#x27;);
fetch(&#x27;https://some-url.com/url6&#x27;);

const App = () =&gt; {
  ... same app code
}
</code></pre>
<p><a href="https://codesandbox.io/s/browser-resources-example-tz60we?file=/src/App.tsx:1336-1434">See it in codesandbox</a> and play around with how just removing one of those useless fetches makes the difference.</p>
<h2 id="part6"><a href="#part6">Requests waterfalls: how they appear</a></h2>
<p>Finally, time to do some serious coding! Now that we have all the needed moving pieces and know how they fit together, time to write the story of our Issue tracking app. Let‚Äôs implement those examples from the beginning of the article, and see what is possible.</p>
<p>Let‚Äôs start with laying out components first, then wire the data fetching afterward. We‚Äôll have the app component itself, it will render Sidebar and Issue, and Issue will render Comments.</p>
<pre><code class="language-tsx">const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;Sidebar /&gt;
      &lt;Issue /&gt;
    &lt;/&gt;
  )
}

const Sidebar = () =&gt; {
  return // some sidebar links
}

const Issue = () =&gt; {
  return &lt;&gt;
    // some issue data
    &lt;Comments /&gt;
  &lt;/&gt;
}

const Comments = () =&gt; {
  return // some issue comments
}
</code></pre>
<p>Now to the data fetching. Let‚Äôs first extract the actual fetch and useEffect and state management into a nice hook, to simplify the examples:</p>
<pre><code class="language-tsx">export const useData = (url) =&gt; {
  const [state, setState] = useState();

  useEffect(() =&gt; {
    const dataFetch = async () =&gt; {
      const data = await (await fetch(url)).json();

      setState(data);
    };

    dataFetch();
  }, [url]);

  return { data: state };
};
</code></pre>
<p>Then, I would probably naturally want to co-locate fetching requests with the bigger components: issue data in <code>Issue</code> and comments list in <code>Comments</code>. And would want to show the loading state while we‚Äôre waiting of course!</p>
<pre><code class="language-tsx">const Comments = () =&gt; {
  // fetch is triggered in useEffect there, as normal
  const { data } = useData(&#x27;/get-comments&#x27;);

  // show loading state while waiting for the data
  if (!data) return &#x27;loading&#x27;;

  // rendering comments now that we have access to them!
  return data.map(comment =&gt; &lt;div&gt;{comment.title}&lt;/div&gt;)
}
</code></pre>
<p>And exactly the same code for <code>Issue</code>, only it will render <code>Comments</code> component after loading:</p>
<pre><code class="language-tsx">const Issue = () =&gt; {
  // fetch is triggered in useEffect there, as normal
  const { data } = useData(&#x27;/get-issue&#x27;);

  // show loading state while waiting for the data
  if (!data) return &#x27;loading&#x27;;

  // render actual issue now that the data is here!
  return (
    &lt;div&gt;
      &lt;h3&gt;{data.title}&lt;/h3&gt;
      &lt;p&gt;{data.description}&lt;/p&gt;
      &lt;Comments /&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>And the app itself:</p>
<pre><code class="language-tsx">const App = () =&gt; {
  // fetch is triggered in useEffect there, as normal
  const { data } = useData(&#x27;/get-sidebar&#x27;);

  // show loading state while waiting for the data
  if (!data) return &#x27;loading&#x27;;

  return (
    &lt;&gt;
      &lt;Sidebar data={data} /&gt;
      &lt;Issue /&gt;
    &lt;/&gt;
  )
}
</code></pre>
<p>Boom, done! Check out the actual <a href="https://codesandbox.io/s/basic-waterfall-example-3b95wk?file=/src/App.tsx">implementation in codesandbox</a>.  Have you noticed how sloooow it is? Slower than all our examples from above!</p>
<p>What we did here is implemented a classic waterfall of requests. Remember the react lifecycle part? Only components that are actually returned will be mounted, rendered, and as a result, will trigger useEffect and data fetching in it. In our case, every single component returns &quot;loading&quot; state while it waits for data. And only when data is loaded, does they switch to a component next in the render tree, it triggers its own data fetching, returns ‚Äúloading‚Äù state and the cycle repeats itself.</p>
<p><img src="/assets/how-to-fetch-data-in-react/classic-waterfall-example.png" alt=""/></p>
<p>Waterfalls like that are not the best solution when you need to show the app as fast as possible. Likely, there are a few ways to deal with them (but not Suspense, about that one later).</p>
<h2 id="part7"><a href="#part7">How to solve requests waterfall</a></h2>
<h3 id="part7.1"><a href="#part7.1">Promise.all solution</a></h3>
<p>The first and easiest solution is to pull all those data fetching requests as high in the render tree as possible. In our case, it‚Äôs our root component <code>App</code>. But there is a catch there: you can‚Äôt just ‚Äúmove‚Äù them and leave as-is. We can‚Äôt just do something like this:</p>
<pre><code class="language-tsx">useEffect(async () =&gt; {
  const sidebar = await fetch(&#x27;/get-sidebar&#x27;);
  const issue = await fetch(&#x27;/get-issue&#x27;);
  const comments = await fetch(&#x27;/get-comments&#x27;);
}, [])
</code></pre>
<p>This is just yet another waterfall, only co-located in a single component: we fetch sidebar data, <code>await</code> for it, then fetch issue, <code>await</code>, fetch comments, <code>await</code>. The time when all the data will be available for render will be the sum of all those waiting times: 1s + 2s + 3s = 6 seconds. Instead, we need to fire them all <em>at the same time</em>, so that they are sent in parallel. That way we will be waiting for all of them no longer than the longest of them: 3 seconds. 50% performance improvement!</p>
<p>One way to do it is to use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">Promise.all</a>:</p>
<pre><code class="language-tsx">useEffect(async () =&gt; {
  const [sidebar, issue, comments] = await Promise.all([
    fetch(&#x27;/get-sidebar&#x27;),
    fetch(&#x27;/get-issue&#x27;),
    fetch(&#x27;/get-comments&#x27;)
  ])
}, [])
</code></pre>
<p>and then save all of them to state in the parent component and pass them down to the children components as props:</p>
<pre><code class="language-tsx">const useAllData = () =&gt; {
  const [sidebar, setSidebar] = useState();
  const [comments, setComments] = useState();
  const [issue, setIssue] = useState();

  useEffect(() =&gt; {
    const dataFetch = async () =&gt; {
      // waiting for allthethings in parallel
      const result = (
        await Promise.all([
          fetch(sidebarUrl),
          fetch(issueUrl),
          fetch(commentsUrl)
        ])
      ).map((r) =&gt; r.json());

      // and waiting a bit more - fetch API is cumbersome
      const [sidebarResult, issueResult, commentsResult] = await Promise.all(
        result
      );

      // when the data is ready, save it to state
      setSidebar(sidebarResult);
      setIssue(issueResult);
      setComments(commentsResult);
    };

    dataFetch();
  }, []);

  return { sidebar, comments, issue };
};

const App = () =&gt; {
  // all the fetches were triggered in parallel
  const { sidebar, comments, issue } = useAllData()

  // show loading state while waiting for all the data
  if (!sidebar || !comments || !issue) return &#x27;loading&#x27;;

  // render the actual app here and pass data from state to children
  return (
    &lt;&gt;
      &lt;Sidebar data={state.sidebar} /&gt;
      &lt;Issue comments={state.comments} issue={state.issue} /&gt;
    &lt;/&gt;
  )
}
</code></pre>
<p><a href="https://codesandbox.io/s/promise-all-example-37hs86?file=/src/App.tsx:1578-2288">See example in codesandbox</a></p>
<p>This is how the very first app from the test at the beginning is implemented.</p>
<p><img src="/assets/how-to-fetch-data-in-react/promise-all-example.png" alt=""/></p>
<h3 id="part7.2"><a href="#part7.2">Parallel promises solution</a></h3>
<p>But what if we don‚Äôt want to wait for them all? Our comments are the slowest and the least important part of the page, it doesn‚Äôt make much sense to block rendering of the sidebar while we‚Äôre waiting for them. Can I fire all requests in parallel, but wait for them independently?</p>
<p>Of course! We just need to transform those <code>fetch</code> from <code>async/await</code> syntax to proper <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">old-fashioned</a> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promises</a> and save the data inside then callback:</p>
<pre><code class="language-tsx">fetch(&#x27;/get-sidebar&#x27;).then(data =&gt; data.json()).then(data =&gt; setSidebar(data));
fetch(&#x27;/get-issue&#x27;).then(data =&gt; data.json()).then(data =&gt; setIssue(data));
fetch(&#x27;/get-comments&#x27;).then(data =&gt; data.json()).then(data =&gt; setComments(data));
</code></pre>
<p>Now every fetch request is fired in parallel but resolved independently. And now in the App‚Äôs render we can do pretty cool things, like render <code>Sidebar</code> and <code>Issue</code> as soon as their data ends up in the state:</p>
<pre><code class="language-tsx">const App = () =&gt; {
  const { sidebar, issue, comments } = useAllData();

  // show loading state while waiting for sidebar
  if (!sidebar) return &#x27;loading&#x27;;

  // render sidebar as soon as its data is available
  // but show loading state instead of issue and comments while we&#x27;re waiting for them
  return (
    &lt;&gt;
      &lt;Sidebar data={sidebar} /&gt;
      &lt;!-- render local loading state for issue here if its data not available --&gt;
      &lt;!-- inside Issue component we&#x27;d have to render &#x27;loading&#x27; for empty comments as well --&gt;
      {issue ? &lt;Issue comments={comments} issue={issue} /&gt; : &#x27;loading&#x27;&#x27;}
    &lt;/&gt;
  )
}
</code></pre>
<p>In here, we render <code>Sidebar</code>, <code>Issue</code> and <code>Comments</code> components as soon as their data becomes available - exactly the same behavior as the initial waterfall. But since we fired those requests in parallel, the overall waiting time will drop from 6 seconds to just 3 seconds. We just massively improved performance of the app, while keeping its behavior intact!</p>
<p><a href="https://codesandbox.io/s/parallel-promises-example-689gxb?file=/src/App.tsx">See example in codesandbox</a></p>
<p><img src="/assets/how-to-fetch-data-in-react/parallel-promises-example.png" alt=""/></p>
<p>One thing to note here, is that in this solution we‚Äôre triggering state change three times independently, which will cause three re-render of the parent component. And considering that it‚Äôs happening at the top of the app, unnecessary re-render like this might cause half of the app to re-render unnecessarily. The performance impact really depends on the order of your components of course and how big they are, but something to keep in mind. A helpful guide on how to deal with re-renders is here: <a href="https://www.developerway.com/posts/react-re-renders-guide">React re-renders guide: everything, all at once</a></p>
<h3 id="part7.3"><a href="#part7.3">Data providers to abstract away fetching</a></h3>
<p>Lifting data loading up like in the examples above, although good for performance, is terrible for app architecture and code readability. Suddenly, instead of nicely co-located data fetching requests and their components we have one giant component that fetches everything and massive props drilling throughout the entire app.</p>
<p>Likely, there is an easy(ish) solution to this: we can introduce the concept of ‚Äúdata providers‚Äù to the app. ‚ÄúData provider‚Äù here would be just an abstraction around data fetching that gives us the ability to fetch data in one place of the app and access that data in another, bypassing all components in between. Essentially like a mini-caching layer per request. In ‚Äúraw‚Äù React it‚Äôs just a simple context:</p>
<pre><code class="language-tsx">const Context = React.createContext();

export const CommentsDataProvider = ({ children }) =&gt; {
  const [comments, setComments] = useState();

  useEffect(async () =&gt; {
    fetch(&#x27;/get-comments&#x27;).then(data =&gt; data.json()).then(data =&gt; setComments(data));
  }, [])

  return (
    &lt;Context.Provider value={comments}&gt;
      {children}
    &lt;/Context.Provider&gt;
  )
}

export const useComments = () =&gt; useContext(commentsContext);
</code></pre>
<p>Exactly the same logic for all three of our requests. And then our monster <code>App</code> component turns into something as simple as this:</p>
<pre><code class="language-tsx">const App = () =&gt; {
  const sidebar = useSidebar();
  const issue = useIssue();

  // show loading state while waiting for sidebar
  if (!sidebar) return &#x27;loading&#x27;;

  // no more props drilling for any of those
  return (
    &lt;&gt;
      &lt;Sidebar /&gt;
      {issue ? &lt;Issue /&gt; : &#x27;loading&#x27;&#x27;}
    &lt;/&gt;
  )
}
</code></pre>
<p>Our three providers will wrap the <code>App</code> component and will fire fetching requests as soon as they are mounted in parallel:</p>
<pre><code class="language-tsx">export const VeryRootApp = () =&gt; {
  return (
    &lt;SidebarDataProvider&gt;
      &lt;IssueDataProvider&gt;
        &lt;CommentsDataProvider&gt;
          &lt;App /&gt;
        &lt;/CommentsDataProvider&gt;
      &lt;/IssueDataProvider&gt;
    &lt;/SidebarDataProvider&gt;
  )
}
</code></pre>
<p>And then in something like <code>Comments</code> (i.e. far far deep into the render tree from the root app) we‚Äôll just access that data from ‚Äúdata provider‚Äù:</p>
<pre><code class="language-tsx">const Comments = () =&gt; {
  // Look! No props drilling!
  const comments = useComments();
}
</code></pre>
<p><a href="https://codesandbox.io/s/data-providers-example-w0rl2m?file=/src/App.tsx">See example in codesandbox</a></p>
<p>If you‚Äôre not a huge fan of Context - not to worry, exactly the same concept will work with any state management solution of your choosing. And if you want to give Context a try, check out this article: <a href="https://www.developerway.com/posts/how-to-write-performant-react-apps-with-context">How to write performant React apps with Context</a>, it has some patterns for Context-related performance.</p>
<h3 id="part7.4"><a href="#part7.4">What if I fetch data before React?</a></h3>
<p>One final trick to learn about waterfalls fighting. That one is very important to know so that you can stop your colleagues from using it during PR reviews üòÖ . What I‚Äôm trying to say here: it‚Äôs a very dangerous thing to do, use it wisely.</p>
<p>Let‚Äôs take a look at our Comments component from the times we implemented the very first waterfall, the one that was fetching data by itself (I moved the getData hook inside).</p>
<pre><code class="language-tsx">const Comments = () =&gt; {
  const [data, setData] = useState();

  useEffect(() =&gt; {
    const dataFetch = async () =&gt; {
      const data = await (await fetch(&#x27;/get-comments&#x27;)).json();

      setData(data);
    };

    dataFetch();
  }, [url]);


  if (!data) return &#x27;loading&#x27;;

  return data.map(comment =&gt; &lt;div&gt;{comment.title}&lt;/div&gt;)
}
</code></pre>
<p>And pay special attention to the 6th line there. What is <code>fetch(&#x27;/get-comments&#x27;)</code>? It‚Äôs nothing more than just a promise, that we await inside our <code>useEffect</code>. It doesn‚Äôt depend on anything of React in this case - no props, state or internal variables dependencies. So what will happen if I just move it to the very top, before I even declare <code>Comments</code> component? And then just <code>await</code> that promise inside <code>useEffect</code> hook?</p>
<pre><code class="language-tsx">const commentsPromise = fetch(&#x27;/get-comments&#x27;);

const Comments = () =&gt; {
  useEffect(() =&gt; {
    const dataFetch = async () =&gt; {
      // just await the variable here
      const data = await (await commentsPromise).json();

      setState(data);
    };

    dataFetch();
  }, [url]);
}
</code></pre>
<p>Really fancy thing: our fetch call basically ‚Äúescapes‚Äù all React lifecycle and will be fired as soon as javascript is loaded on the page, before any of <code>useEffect</code> anywere are called. Even before the very first request in the roop <code>App</code> component will be called. It will be fired, javascript will move on to other things to process, and the data will just sit there quietly until someone actually resolves it. Which is what we‚Äôre doing in our <code>useEffect</code> in <code>Comments</code>.</p>
<p>Remember our initial waterfall pic?</p>
<p><img src="/assets/how-to-fetch-data-in-react/classic-waterfall-example.png" alt=""/></p>
<p>Just moving fetch call outside of <code>Comments</code> resulted in this instead:</p>
<p><img src="/assets/how-to-fetch-data-in-react/fetch-outside.png" alt=""/></p>
<p><a href="https://codesandbox.io/s/waterfall-with-fetch-outside-483owd?file=/src/App.tsx">See example in codesandbox</a></p>
<p>Technically speaking, we could‚Äôve just moved all of our promises outside of components, that would‚Äôve solved the waterfalls and we wouldn‚Äôt have to deal with lifting fetching up or data providers.</p>
<p>So why didn‚Äôt we? And why it‚Äôs not a very common pattern?</p>
<p>Easy. Remember the <strong>Browsers limitation</strong> chapter? Only 6 requests in parallel, the next one will queue. And fetches like that will be fired immediately and completely uncontrollably. A component that fetches heavy data and rendered once in a blue moon, in your app with ‚Äútraditional‚Äù waterfall approach won‚Äôt bother anyone until it‚Äôs actually rendered. But with this hack, it has the potential to steal the most valuable milliseconds of initial fetching of critical data. And good luck to anyone who‚Äôs trying to figure out how a component that sits in some existential corner of the code and is never even rendered on a screen can slow down the entire app.</p>
<p>There are only two ‚Äúlegit‚Äù use cases that I can think of for that pattern: pre-fetching of some critical resources on the router level and pre-fetching data in lazy-loaded components.</p>
<p>In the first one, you actually need to fetch data as soon as possible, and you know for sure that the data is critical and required immediately. And lazy-loaded components&#x27; javascript will be downloaded and executed only when they end up in the render tree, so by definition after all the critical data is fetched and rendered. So it‚Äôs safe.</p>
<h3 id="part7.5"><a href="#part7.5">What if I use libraries for data fetching?</a></h3>
<p>Up until now in all code examples, I‚Äôve been using only native <code>fetch</code>. This is on purpose: I wanted to show you fundamental data fetching patterns in React, and those are libraries-independent. Regardless of any library you‚Äôre using or want to use, the principle of waterfalls, fetching data within or outside of React lifecycle stays the same.</p>
<p>React-independent libraries like <a href="https://github.com/axios/axios">Axios</a> just abstract away the complexities of dealing with actual <code>fetch</code>, nothing more. I can replace all <code>fetch</code> with <code>axios.get</code> in the examples and the result will stay the same.</p>
<p>React-integrated libraries with hooks and query-like API like <a href="https://swr.vercel.app/docs/getting-started">swr</a> in addition abstract away dealing with <code>useCallback</code>, state, and many other things like error handling and caching. Instead of this monstrosity of a code that still needs a lot of things to be production-ready:</p>
<pre><code class="language-tsx">const Comments = () =&gt; {
  const [data, setData] = useState();

  useEffect(() =&gt; {
    const dataFetch = async () =&gt; {
      const data = await (await fetch(&#x27;/get-comments&#x27;)).json();

      setState(data);
    };

    dataFetch();
  }, [url]);

  // the rest of comments code
}
</code></pre>
<p>with swr I can just write this:</p>
<pre><code class="language-tsx">const Comments = () =&gt; {
  const { data } = useSWR(&#x27;/get-comments&#x27;, fetcher);

  // the rest of comments code
}
</code></pre>
<p>Underneath, all of them will use <code>useEffect</code> or eqivalent to fetch the data, and state to update the data and trigger re-render of the host component.</p>
<h2 id="part8"><a href="#part8">What about Suspense?</a></h2>
<p>The data fetching in React story without at least mentioning Suspence would be incomplete üòÖ So, what about Suspense? Well, nothing. At the time of writing the article, Suspense for data fetching is still flagged as Experimental, so I would not recommend using it in anything remotely production-related.</p>
<p>But let‚Äôs imagine that the API will stay the same and it will become production-ready tomorrow. Will it fundamentally solve data fetching and will it make everything above obsolete? Not at all. We are still going to be bound by browsers resources limit, React lifecycle, and the nature of requests waterfalls as a result.</p>
<p>Suspense is just a really fancy and clever way to replace fiddling with loading states. Instead of this:</p>
<pre><code class="language-tsx">const Comments = ({ commments }) =&gt; {
  if (!comments) return &#x27;loading&#x27;;

  // render comments
}
</code></pre>
<p>we‚Äôre just going to lift that loading state up and do this:</p>
<pre><code class="language-tsx">const Issue = () =&gt; {
  return &lt;&gt;
    // issue data
    &lt;Suspence fallback=&quot;loading&quot;&gt;
      &lt;Comments /&gt;
    &lt;/Suspence&gt;
  &lt;/&gt;
}
</code></pre>
<p>This is a really nice article if you want to start building with Suspense already: <a href="https://blog.logrocket.com/react-suspense-data-fetching/">Experimental React: Using Suspense for data fetching - LogRocket Blog</a>. Just don‚Äôt forget all the core principles and limitations from the above when suspending stuff.</p>
<hr/>
<p>Huh, that was a lot to cover for me and digest for you. Hope you are not going to see waterfalls in your sleep (I definitely see them now!). Little things to take away:</p>
<ul>
<li>you don‚Äôt have to have a library to fetch data in React, but they help</li>
<li>performance is subjective and always depends on user experience</li>
<li>browser resources available to you are limited, just 6 requests in parallel. Don‚Äôt go wild with pre-fetching the world</li>
<li>useEffect doesn‚Äôt cause waterfalls by itself, they are just a natural consequence of composition and loading state</li>
</ul>
<p>Have a great fetching experience and see you next time! üêà‚Äç‚¨õ</p>]]></content:encoded>
      <enclosure url="https://www.developerway.com//assets/how-to-fetch-data-in-react/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title><![CDATA[How it's made: the blog's story and the future]]></title>
      <link>https://www.developerway.com/posts/how-its-made-the-blog-story</link>
      <guid>how-its-made-the-blog-story</guid>
      <pubDate>Tue, 20 Sep 2022 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Sneak peek behind the scenes. How the blog has started, how I come up with the ideas, how the blog is promoted, the money question: present and future. And the secret of the cats of course!]]></description>
      <content:encoded><![CDATA[<p>When I look back at just one year ago, I can‚Äôt believe it was real. It was the middle of Australia‚Äôs toughest covid lockdown with no hope or end in sight, everyone in Sydney was on a 5 km leash, and I was preparing to yet again turn my life completely upside down: <a href="https://www.developerway.com/posts/prison-break-solving-life-as-a-developer">ü¶ò Prison break, or solving life like a developerÔ∏è</a>. Long story short: I escaped Australia, become a digital nomad in Europe, and started ‚ÄúDeveloper way‚Äù blog, where now I write about advanced-level stuff for developers, mostly focusing on React and the technology around React.</p>
<p>It‚Äôs been 10 months now since the blog launched. Its popularity is growing, the overall number of visitors recently surpassed 100k people (30k in the last 30 days) and the free bandwidth threshold on Netlify has been exceeded. This feels like a good time to do a bit of self-reflection, share a few ‚Äúbehind the scenes‚Äù stories, and think about the blog‚Äôs future.</p>
<p>And reveal the secret of the cats of course üòâ.</p>
<p><img src="/assets/how-its-made/users-overall-statistics.png" alt=""/></p>
<h2 id="part1"><a href="#part1">How the blog started</a></h2>
<p>After all the bureaucratic hoops were jumped through, I <a href="https://www.developerway.com/posts/prison-break-solving-life-as-a-developer">escaped Australia‚Äôs lockdown</a>, and landed in Europe, I needed a new big side project to focus on. Something different to the coding ‚Äúday‚Äù job, but also something that is related to it in some way, so it doesn‚Äôt split day-to-day focus too much. I was writing here and now before that, so this felt like a good opportunity to start doing it more consistently and publicly.</p>
<p>For any side projects that I do (or anything for that matter) I need a purpose. I can‚Äôt do things just for the sake of doing things. Considering that I‚Äôve never done consistent blogging before and didn‚Äôt have much of an audience, I decided that the goal for this project would be:</p>
<ul>
<li>write consistently for at least a year</li>
<li>learn things about marketing, SEO, and other cool stuff that can help promote the blog</li>
<li><s>beat Dan Abramov in the number of Twitter followers</s> apply freshly learned things and tools and see how much of an audience I can build (and maybe turn it into passive income at some point in the future, but on that later)</li>
</ul>
<p>A few discussions and sparring sessions with one of my dearest friends later, and the blog with the name ‚ÄúDeveloper way‚Äù came to life. Initial goal: in a year it should have at least 5k visitors a month.</p>
<p>5 months later it turned out that I‚Äôm really shit at setting numbered goals and need a new one üòÖ</p>
<p><img src="/assets/how-its-made/5-months-later.png" alt=""/></p>
<h2 id="part2"><a href="#part2">How I come up with ideas?</a></h2>
<p>Where to source ideas from to write consistently is usually the main concern when starting a new tech blog. One of the most useful articles that I‚Äôve read on the topic is this: <a href="https://bloggingfordevs.com/tech-blog-ideas/">7 Ways to Find Unique Tech Blog Post Ideas</a>. Here I want to share a few strategies that work particularly well for me.</p>
<h3>Keyword research</h3>
<p><a href="https://moz.com/beginners-guide-to-seo/keyword-research">‚ÄúKeyword research‚Äù</a> is something that every single article on ‚Äúhow to become a blogger‚Äù will mention and I use it a lot when I‚Äôm looking for a new topic to write about. ‚ÄúKeyword research‚Äù is a SEO technique and it‚Äôs basically just a fancy term for staring at the most popular google search queries on the topic of your interest. When you don‚Äôt have a huge backlog of ideas to write about, understanding what people actually search for can be a big source of inspiration.</p>
<p>There are a lot of tools out there for this purpose. For the actual research, I usually use <a href="https://keywordseverywhere.com/">Keywords Everywhere</a> Chrome plugin. It integrates into the google search results page and shows the keywords information with it: related keywords, long tail keywords, and what people also search for.</p>
<p><img src="/assets/how-its-made/people-search-for.png" alt=""/></p>
<p>So the normal research process for me looks something like this: search for a topic (‚ÄúuseMemo‚Äù for example), look at the related keywords and searches, see what speaks to me, if something clicks - write it down. Narrow the search down or search for a different topic, and repeat the whole process until I have a decent backlog of ideas to think about and investigate in more detail. Quite a few articles, especially at the very beginning, were a direct result of this process.</p>
<h3>People asking questions</h3>
<p>Actual people asking questions is probably one of the most important sources of ideas and inspiration for me. The article on <a href="https://www.developerway.com/posts/components-composition-how-to-get-it-right">components composition</a> was written because a few people just asked me on <a href="https://twitter.com/adevnadia">Twitter</a> &amp; email to write something about composition. <a href="https://www.developerway.com/posts/react-elements-children-parents">The mystery of React Elements</a> was born from a question in the comments in one of the previous articles.</p>
<p>Another very useful source of questions is StackOverflow and various subreddits on Reddit. I just browse from time to time through the most popular and the most frequent questions there. Usually, it‚Äôs enough to get a glimpse of where are the major pain points for people, and whether I want to say something on the topic.</p>
<h3>People arguing</h3>
<p>People love to argue, isn‚Äôt it? Who among us didn‚Äôt stay up unforgivably late just because someone was <em>wrong</em> on the internet?</p>
<p>Those heated discussions and dramas in comments under popular articles are not only a fun read, but also a good source of inspiration for future articles. At the very least you know for sure that a topic like that is something people care about, so it might be worth writing about it as well. This is how the latest article <a href="https://www.developerway.com/posts/pure-components-vs-functional-and-hooks">PureComponents vs Functional Components with hooks</a> was born: under popular articles about re-renders, performance or memoization there will always be comments on how easier life was in PureComponents world.</p>
<p><img src="/assets/how-its-made/duty-calls.png" alt=""/></p>
<h2 id="part3"><a href="#part3">How do I promote the blog?</a></h2>
<p>For something like a technical blog, a constantly growing audience is a strong signal of its success. And who doesn‚Äôt love to be successful?</p>
<p>Considering that the blog started from almost zero, it was a good opportunity to try different promotion strategies and compare their impact and required time &amp; effort investment. Also, turned out that trying various strategies and noticing different patterns in different systems is great fun by itself.</p>
<h3>Social media: Twitter</h3>
<p><a href="https://twitter.com/adevnadia">Twitter</a> turned out to be the most annoying thing ever for me. Posts there are extremely short-lived: everything just disappears into the void in a few hours. The character limit is ridiculous: I only start writing a thought, and it‚Äôs already exceeded. The chaos of Twitter threads makes my eyes bleed and the process of writing them is just agonizing.</p>
<p>After trying a few different things I just gave up on it. Currently, I just post announcements of the latest articles, occasional reposts, and rely on ‚Äúnatural‚Äù growth. ‚ÄúNatual‚Äù growth is relatively steady but slow: I started with ~250 followers, 10 months later it‚Äôs ~1100.</p>
<h3>Social media: Linkedin</h3>
<p><a href="https://www.linkedin.com/in/adevnadia/">Linkedin</a> turned out to be much easier: no limits, a normal comments system, no annoying threads. Posts remain ‚Äúactive‚Äù longer, for at least a few days, not hours. And some residual activity due to its feed algorithm also continues for a very long time: I get likes or comments on posts from weeks back. In Twitter, a post is ‚Äúdead‚Äù completely after just a day or two.</p>
<p>Also relying on just ‚Äúnatural‚Äù growth here, also slow but steady: from ~500 followers (half of which were random recruiters) to ~1400 today.</p>
<h3>Content syndication: dev.to and medium</h3>
<p>Content syndication is a fancy marketing term for republishing your own articles on other platforms. I have two ‚Äúclones‚Äù of the blog: on <a href="https://adevnadia.medium.com/">medium</a> and on <a href="https://dev.to/adevnadia">dev.to</a>. Syndication, especially at the very beginning, turned out to be one the most useful promotion strategy for me.</p>
<p>First, it provides more exposure and audience to the actual content of the articles: those platforms have a huge devs community. Second, they also serve as another source of visitors to the blog: links to the previous articles, footnote that ‚Äúthis article was published elsewhere‚Äù, links to the blog from the profile. And lastly, they are also a good source of ‚Äúnatural‚Äù growth for <a href="https://twitter.com/adevnadia">Twitter</a>/<a href="https://www.linkedin.com/in/adevnadia/">Linkedin</a>: people like to connect with authors they read on social networks.</p>
<p>The standard marketing recommendation is to repost articles 2-3 weeks after the original is published, so that Google has time to index the original. I usually ignore it (I‚Äôm too lazy for that üòÖ) and publish them after a few days. For your own reposts, I don‚Äôt think it really matters that much: even if Google indexes ‚Äúclones‚Äù first, it will quickly correct itself as long as the canonical link is set correctly.</p>
<p>Currently, traffic from those platforms to the blog is comparable with traffic from <a href="https://twitter.com/adevnadia">Twitter</a> &amp; <a href="https://www.linkedin.com/in/adevnadia/">Linkedin</a>.</p>
<h3>React newsletters</h3>
<p>It was a big surprise to me, how many email newsletters are out there, and how popular they are. For beginners, being shared in one of the big newsletters trumps all other strategies tenfold. The first time one of my articles appeared in <a href="https://react.statuscode.com/">React Status</a> newsletter (~50k subscribers), the number of visitors ‚Äúin the last 30 min‚Äù (real-time view in analytics) jumped from 3-4 to <strong>60-80</strong>.</p>
<p>Even today, when traffic from google constitutes the majority of visitors to the blog and 60-80 is a daily norm, I still see some good bumps in the visitors when big newsletters share my articles.</p>
<p>How to appear among the ‚Äúchosen‚Äù ones? üßê No idea, to be honest, seems like a big lottery. But writing an article that becomes popular before that is the most obvious way ‚Äúin‚Äù, almost a guarantee. After that it‚Äôs a chain of re-shares: everyone is stealing from each other üòÖ</p>
<h3>Google search</h3>
<p>Knowing the basics of SEO is a must for an ambitious aspiring tech blogger. Reading through half of <a href="https://moz.com/resources?type=guides">Moz‚Äôs guide on SEO</a> and learning stuff like ranking, backlinks, indexing, domain authority, and so on turned out to be one of the best time investments from the ‚Äúsuccessful promotion strategy‚Äù perspective.</p>
<p>Investing in ‚Äúgoogle‚Äù promotion is a long-term and time-consuming investment, but it‚Äôs worth it: currently, I get ~1300 daily clicks from google on weekdays, and it&#x27;s growing rapidly. The graph of clicks from google search in the last 6 months looks like this:</p>
<p><img src="/assets/how-its-made/google-last-6-months.png" alt=""/></p>
<h3>Blog‚Äôs email subscription</h3>
<p>My blog, as any respectable blog, of course, has its own email subscription üòÖ That one is probably the most controversial for me: by itself, compared to all other promotion strategies, it‚Äôs pretty useless. Today I have almost 800 subscribers, with very good open and click rates (70/30), but when the email goes out it‚Äôs almost unnoticeable in the usual visitors&#x27; rate.</p>
<p>On the other hand, as a delivery method, it‚Äôs much, much more reliable and visible, compared to the instantly evaporating Twitter feed. Not to mention that subscribing to something through email (with the confirmation afterward) is a much more intentional act than just clicking ‚Äúfollow‚Äù on Twitter. So technically speaking, email subscribers have to be the most committed and loyal audience compared to all other mediums. Kinda cool, if you think about it üôÉ</p>
<h2 id="part4"><a href="#part4">How much does it cost?</a></h2>
<p>It‚Äôs amazing, how much of everything described above can be done for free. Technically speaking, the only required investment with the number of visitors that I have is the domain name. Everything else is optional and more of a nice to have. Quick breakdown:</p>
<ol>
<li>Domain name and google workspace (for email at @developerway.com)</li>
</ol>
<p>18$ per year - domain itself, ~10$ per month for workspace</p>
<ol start="2">
<li>Blog building and hosting</li>
</ol>
<p>Basic static blog on Nextjs with deployment to Netlify, no CMS, backend, or lambda functions. Was free until last month, then they forced all private repos to Pro plan. Now 19$ per month.</p>
<p>If I switch to AWS, will again be free for a very long time, my usage is well within AWS Free tier.</p>
<ol start="3">
<li>Email subscription service.</li>
</ol>
<p>Free until 1000 subscribers, after that will be 29$ per month</p>
<ol start="4">
<li>Comments service</li>
</ol>
<p>Currently 5$ a month</p>
<p><strong>Overall</strong>, around 64$ per month. Could‚Äôve been worst.</p>
<h2 id="part5"><a href="#part5">What about monetization?</a></h2>
<p>From time to time people ask why I don‚Äôt monetize the blog now, and whether I plan to do that in the future. I thought about it of course: the idea of having some steady passive income sounds very appealing.</p>
<p>What I don‚Äôt like, however, are the ‚Äústandard‚Äù ways to monetize a blog like that, i.e. advertising, sponsorship, or paywalls. None of those are worth broken trust from the readers that come with it, especially in the long run. If I decide to monetize the blog in the future, I‚Äôll look for more ‚Äúethical‚Äù ways to do that.</p>
<p>For example, I may or may not write a book or make a course on React, if I pass the next milestone I set for myself üôÉ</p>
<p><a href="https://developerway.com/">Subscribe to the newsletter</a>, or follow on <a href="https://twitter.com/adevnadia">Twitter</a> or <a href="https://www.linkedin.com/in/adevnadia/">Linkedin</a> to not miss the big announcement when it happens.</p>
<h2 id="part6"><a href="#part6">üêà‚Äç‚¨õ The secret of the cats</a></h2>
<p>Lots of people noticed the cats theme in the blog üêà‚Äç‚¨õ. Curious: how many of you noticed that the cats are not random? üòâ</p>
<p>When I was just building the blog, I designed the main page in a way that every blog card should have a picture associated with it. And the very first article that I wrote for the blog was about my <a href="https://www.developerway.com/posts/prison-break-solving-life-as-a-developer">escape from Australia to Malta</a>. The article is illustrated by a photo of Malta‚Äôs cats, they are everywhere there. And the article before that, with the title <a href="https://www.developerway.com/posts/custom-eslint-rules-typescript-monorepo">‚ÄúCustom eslint rules + typescript monorepo = ‚ù§Ô∏è‚Äù</a>, is illustrated by two cats in love.</p>
<p>So it seemed only logical that the next article should also have a cat. Why break such a cute trend? Hence the <strong>Rule of Cats</strong> was born: every article should have an intro pic with a cat (or something equally cute) on it. The cat should illustrate what is written in the article.</p>
<p><a href="https://www.developerway.com/posts/why-custom-react-hooks-could-destroy-your-app-performance">The custom hooks</a> article has a cat with a hook: Captain Hook Cat. <a href="https://www.developerway.com/posts/how-to-use-memo-use-callback">How to useMemo and useCallback</a> article is about memoization (i.e. memory), and has a cat that remembers a fish (i.e. the fish is memoized üòÜ). <a href="https://www.developerway.com/posts/react-component-as-prop-the-right-way">React component as prop</a> article has three similar cats of different colors that sing the same song, and the article describes three patterns that essentially do exactly the same thing (i.e. sing the same song).</p>
<p><img src="/assets/how-its-made/cats-in-a-row.jpg" alt=""/></p>
<p>I‚Äôll let your imagination figure out the rest of them üòú</p>
<hr/>
<p>That is all for today, hope you enjoyed that little ‚Äúbehind the scenes‚Äù sneak peek. Don‚Äôt hesitate to contact me on <a href="https://twitter.com/adevnadia">Twitter</a> or <a href="https://www.linkedin.com/in/adevnadia/">Linkedin</a> if you have ideas or suggestions: after all, y‚Äôall are the reason why this blog exists and continues to grow!</p>
<p>See ya next time, and remember: <s>this</s> cats is the way!</p>]]></content:encoded>
      <enclosure url="https://www.developerway.com//assets/how-its-made/welcome.png" length="0"
        type="image/png"/>
    </item>
    <item>
      <title><![CDATA[PureComponents vs Functional Components with hooks]]></title>
      <link>https://www.developerway.com/posts/pure-components-vs-functional-and-hooks</link>
      <guid>pure-components-vs-functional-and-hooks</guid>
      <pubDate>Wed, 07 Sep 2022 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Looking into PureComponent and the problem it solved, how it can be replaced now in the hooks & functional components world, and discovering an interesting quirk of React re-renders behavior]]></description>
      <content:encoded><![CDATA[<p>Do you agree that everything was better in the good old days? Cats were fluffier, unlimited chocolate didn‚Äôt cause diabetes and in React we didn‚Äôt have to worry about re-renders: <code>PureComponent</code> or <code>shouldComponentUpdate</code> would take care of them for us.</p>
<p>When I read comments or articles on React re-renders, the opinion that because of hooks and functional components we‚Äôre now in re-rendering hell keeps popping up here and there. This got me curious: I don‚Äôt remember the ‚Äúgood old days‚Äù being particularly good in that regard. Am I missing something? Is it true that functional components made things worse from re-renders perspective? Should we all migrate back to classes and <code>PureComponent</code>?</p>
<p>So here is another investigation for you: looking into <code>PureComponent</code> and the problem it solved, understanding whether it can be replaced now in the hooks &amp; functional components world, and discovering an interesting (although a bit useless) quirk of React re-renders behavior that I bet you also didn‚Äôt know üòâ</p>
<h2 id="part1"><a href="#part1">PureComponent, shouldComponentUpdate: which problems do they
solve?</a></h2>
<p>First of all, let‚Äôs remember what exactly is <code>PureComponent</code> and why we needed <code>shouldComponentUpdate</code>.</p>
<h3 id="part1.1"><a href="#part1.1">Unnecessary re-renders because of parents</a></h3>
<p>As we know, today a parent&#x27;s re-render is one of the reasons <a href="https://www.developerway.com/posts/react-re-renders-guide#part2.2">why a component can re-render itself</a>. If I change state in the <code>Parent</code> component it will case its re-render, and as a consequence, the <code>Child</code> component will re-render as well:</p>
<pre><code class="language-tsx">const Child = () =&gt; &lt;div&gt;render something here&lt;/div&gt;;

const Parent = () =&gt; {
  const [counter, setCounter] = useState(1);

  return (
    &lt;&gt;
      &lt;button onClick={() =&gt; setCounter(counter + 1)}&gt;Click me&lt;/button&gt;
      &lt;!-- child will re-render when &quot;counter&quot; changes--&gt;
      &lt;Child /&gt;
    &lt;/&gt;
  )
}
</code></pre>
<p>It‚Äôs exactly the same behavior as it was before, with class-based components: state change in <code>Parent</code> will trigger re-render of the <code>Child</code>:</p>
<pre><code class="language-tsx">class Child extends React.Component {
  render() {
    return &lt;div&gt;render something here&lt;/div&gt;
  }
}

class Parent extends React.Component {
  super() {
    this.state = { counter: 1 }
  }

  render() {
    return &lt;&gt;
      &lt;button onClick={() =&gt; this.setState({ counter: this.state.counter + 1 })}&gt;Click me&lt;/button&gt;
      &lt;!-- child will re-render when state here changes --&gt;
      &lt;Child /&gt;
    &lt;/&gt;
  }
}
</code></pre>
<p><a href="https://codesandbox.io/s/parent-child-re-renders-ipbe3l?file=/src/App.tsx">See example in codesandbox</a></p>
<p>And again, exactly the same story as today: <a href="https://www.developerway.com/posts/how-to-write-performant-react-code">too many or too heavy re-renders</a> in the app could cause performance problems.</p>
<p>In order to prevent that, React allows us to override <code>shouldComponentUpdate</code> method for the class components. This method is triggered before the component is supposed to re-render. If it returns <code>true</code>, the component proceeds with its lifecycle and re-renders; if <code>false</code> - it won‚Äôt. So if we wanted to prevent our <code>Child</code> components from parent-induced re-renders, all we needed to do is to return <code>false</code> in <code>shouldComponentUpdate</code>:</p>
<pre><code class="language-tsx">class Child extends React.Component {
  shouldComponentUpdate() {
    // now child component won&#x27;t ever re-render
    return false;
  }

  render() {
    return &lt;div&gt;render something here&lt;/div&gt;
  }
}
</code></pre>
<p>But what if we want to pass some props to the <code>Child</code> component? We actually need this component to update itself (i.e. re-render) when they change. To solve this, <code>shouldComponentUpdate</code> gives you access to <code>nextProps</code> as an argument and you have access to the previous props via <code>this.props</code>:</p>
<pre><code class="language-tsx">class Child extends React.Component {
  shouldComponentUpdate(nextProps) {
    // now if &quot;someprop&quot; changes, the component will re-render
    if (nextProps.someprop !== this.props.someprop) return true;

    // and won&#x27;t re-render if anything else changes
    return false;
  }

  render() {
    return &lt;div&gt;{this.props.someprop}&lt;/div&gt;
  }
}
</code></pre>
<p>Now, <em>if and only if</em> <code>someprop</code> changes, <code>Child</code> component will re-render itself.</p>
<p>Even if we add some state to it üòâ. Interestingly enough, <code>shouldComponentUpdate</code> is called before state updates as well. So this method is actually very dangerous: if not used carefully, it could cause the component to misbehave and not update itself properly on its state change. Like this:</p>
<pre><code class="language-tsx">class Child extends React.Component {
  constructor(props) {
    super(props);
    this.state = { somestate: &#x27;nothing&#x27; }
  }

  shouldComponentUpdate(nextProps) {
    // re-render component if and only if &quot;someprop&quot; changes
    if (nextProps.someprop !== this.props.someprop) return true;
    return false;
  }

  render() {
    return (
      &lt;div&gt;
        &lt;!-- click on a button should update state --&gt;
        &lt;!-- but it won&#x27;t re-render because of shouldComponentUpdate --&gt;
        &lt;button onClick={() =&gt; this.setState({ somestate: &#x27;updated&#x27; })}&gt;Click me&lt;/button&gt;
        {this.state.somestate}
        {this.props.someprop}
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>In addition to props, <code>Child</code> component has some state now, which is supposed to be updated on button click. But clicking on this button won‚Äôt cause <code>Child</code> component to re-render, since it‚Äôs not included in the <code>shouldComponentUpdate</code>, so the user will actually never see the updated state on the screen.</p>
<p><a href="https://codesandbox.io/s/should-component-update-broken-ytvzu0?file=/src/App.tsx">See example in codesandbox</a></p>
<p>In order to fix it, we also need to add state comparison to the <code>shouldComponentUpdate</code> function: React sends us <code>nextState</code> there as the second argument:</p>
<pre><code class="language-tsx">shouldComponentUpdate(nextProps, nextState) {
    // re-render component if &quot;someprop&quot; changes
    if (nextProps.someprop !== this.props.someprop) return true;

    // re-render component if &quot;somestate&quot; changes
    if (nextState.somestate !== this.state.somestate) return true;
    return false;
  }
</code></pre>
<p>As you can imagine, writing that manually for every state and prop is a recipe for a disaster. So most of the time it would be something like this instead:</p>
<pre><code class="language-tsx">shouldComponentUpdate(nextProps, nextState) {
    // re-render component if any of the prop change
    if (!isEqual(nextProps, this.prop)) return true;

    // re-render component if &quot;somestate&quot; changes
    if (!isEqual(nextState, this.state)) return true;

    return false;
  }
</code></pre>
<p>And since this is such a common use case, React gives us <code>PureComponent</code> in addition to just <code>Component</code>, where this comparison logic is implemented already. So if we wanted to prevent our <code>Child</code> component from unnecessary re-renders, we could just extend <code>PureComponent</code> without writing any additional logic:</p>
<pre><code class="language-tsx">// extend PureComponent rather than normal Component
// now child component won&#x27;t re-render unnecessary
class PureChild extends React.PureComponent {
  constructor(props) {
    super(props);
    this.state = { somestate: &#x27;nothing&#x27; }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;button onClick={() =&gt; this.setState({ somestate: &#x27;updated&#x27; })}&gt;Click me&lt;/button&gt;
        {this.state.somestate}
        {this.props.someprop}
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Now, if we use that component in the <code>Parent</code> from above, it will not re-render if the parent‚Äôs state changes, and the Child‚Äôs state will work as expected:</p>
<pre><code class="language-tsx">class Parent extends React.Component {
  super() {
    this.state = { counter: 1 }
  }

  render() {
    return &lt;&gt;
      &lt;button onClick={() =&gt; this.setState({ counter: this.state.counter + 1 })}&gt;Click me&lt;/button&gt;
      &lt;!-- child will NOT re-render when state here changes --&gt;
      &lt;PureChild someprop=&quot;something&quot; /&gt;
    &lt;/&gt;
  }
}
</code></pre>
<p><a href="https://codesandbox.io/s/pure-components-example-072li4?file=/src/App.tsx">See example in codesandbox</a></p>
<h3 id="part1.2"><a href="#part1.2">Unnecessary re-renders because of state</a></h3>
<p>As mentioned above, <code>shouldComponentUpdate</code> provides us with both props AND state. This is because it is triggered before <em>every</em> re-render of a component: regardless of whether it‚Äôs coming from parents or its own state. Even worst: it will be triggered on <em>every</em> call of <code>this.setState</code>, regardless of whether the actual state changed or not.</p>
<pre><code class="language-tsx">class Parent extends React.Component {
  super() {
    this.state = { counter: 1 }
  }

  render() {
    &lt;!-- every click of the button will cause this component to re-render --&gt;
    &lt;!-- even though actual state doesn&#x27;t change --&gt;
    return &lt;&gt;
      &lt;button onClick={() =&gt; this.setState({ counter: 1 })}&gt;Click me&lt;/button&gt;
    &lt;/&gt;
  }
}
</code></pre>
<p><a href="https://codesandbox.io/s/just-component-with-state-emhncm?file=/src/App.tsx">See example in codesandbox</a></p>
<p>Extend this component from <code>React.PureComponent</code> and see how re-renders are not triggered anymore on every button click.</p>
<p>Because of this behavior, every second recommendation on ‚Äúhow to write state in React‚Äù from the good old days mentions ‚Äúset state only when actually necessary‚Äù and this is why we should explicitly check whether state has changed in <code>shouldComponentUpdate</code> and why <code>PureComponent</code> already implements it for us.</p>
<p>Without those, it is actually possible to cause performance problems because of unnecessary state updates!</p>
<hr/>
<p>To summarise this first part: <code>PureComponent</code> or <code>shouldComponentUpdate</code> were used to prevent performance problems caused by unnecessary re-renders of components caused by their state updates or their parents re-renders.</p>
<h2 id="part2"><a href="#part2">PureComponent/shouldComponentUpdate vs functional components &amp;
hooks</a></h2>
<p>And now back to the future (i.e. today). How do state and parent-related updates behave now?</p>
<h3 id="part2.1"><a href="#part2.1">Unnecessary re-renders because of parents: React.memo</a></h3>
<p>As we know, <a href="https://www.developerway.com/posts/react-re-renders-guide#part2.2">re-renders from parents</a> are still happening, and they behave in exactly the same way as in the classes world: if a parent re-renders, its child will re-render as well. Only in functional components we don‚Äôt have neither <code>shouldComponentUpdate</code> nor <code>PureComponent</code> to battle those.</p>
<p>Instead, we have <code>React.memo</code>: it‚Äôs a higher-order component supplied by React. It behaves almost exactly the same as <code>PureComponent</code> when it comes to props: even if a parent re-renders, re-render of a child component wrapped in React.memo won‚Äôt happen unless its props change.</p>
<p>If we wanted to re-implement our <code>Child</code> component from above as a functional component with the performance optimization that <code>PureComponent</code> provides, we‚Äôd do it like this:</p>
<pre><code class="language-tsx">const Child = ({ someprop }) =&gt; {
  const [something, setSomething] = useState(&#x27;nothing&#x27;);

  render() {
    return (
      &lt;div&gt;
        &lt;button onClick={() =&gt; setSomething(&#x27;updated&#x27;)}&gt;Click me&lt;/button&gt;
        {somestate}
        {someprop}
      &lt;/div&gt;
    )
  }
}

// Wrapping Child in React.memo - almost the same as extending PureComponent
export const PureChild = React.memo(Child);
</code></pre>
<p>And then when <code>Parent</code> component changes its state, <code>PureChild</code> won‚Äôt re-render: exactly the same as a <code>PureChild</code> based on <code>PureComponent</code>:</p>
<pre><code class="language-tsx">const Parent = () =&gt; {
  const [counter, setCounter] = useState(1);

  return (
    &lt;&gt;
      &lt;button onClick={() =&gt; setCounter(counter + 1)}&gt;Click me&lt;/button&gt;
      &lt;!-- won&#x27;t re-render because of counter change --&gt;
      &lt;PureChild someprop=&quot;123&quot; /&gt;
    &lt;/&gt;
  )
}
</code></pre>
<p><a href="https://codesandbox.io/s/child-in-memo-v6r22i?file=/src/App.tsx:682-686">See example in codesandbox</a></p>
<h3 id="part2.2"><a href="#part2.2">Props with functions: React.memo comparison function</a></h3>
<p>Now let‚Äôs assume <code>PureChild</code> accepts <code>onClick</code> callback as well as a primitive prop. What will happen if I just pass it like an arrow function?</p>
<pre><code class="language-tsx">&lt;PureChild someprop=&quot;123&quot; onClick={() =&gt; doSomething()} /&gt;
</code></pre>
<p><strong>Both</strong> <code>React.memo</code> and <code>PureComponent</code> implementation will be broken: <code>onClick</code> is a function (non-primitive value), on every <code>Parent</code> re-render it will be re-created, which means on every <code>Parent</code> re-render <code>PureChild</code> will think that <code>onClick</code> prop has changed and will re-render as well. Performance optimization is gone for both.</p>
<p>And here is where functional components have an advantage.</p>
<p><code>PureChild</code> on <code>PureComponent</code> can‚Äôt do anything about the situation: it would be either up to the parent to pass the function properly, or we would have to ditch <code>PureComponent</code> and re-implement props and state comparison manually with <code>shouldComponentUpdate</code>, with <code>onClick</code> being excluded from the comparison.</p>
<p>With <code>React.memo</code> it‚Äôs easier: we can just pass to it the comparison function as a second argument:</p>
<pre><code class="language-tsx">// exclude onClick from comparison
const areEqual = (prevProps, nextProps) =&gt; prevProps.someprop === nextProps.someprop;

export const PureChild = React.memo(Child, areEqual);
</code></pre>
<p>Essentially <code>React.memo</code> combines both <code>PureComponent</code> and <code>shouldComponentUpdate</code> in itself when it comes to props. Pretty convenient!</p>
<p><a href="https://codesandbox.io/s/child-in-memo-with-comparison-44yhbe?file=/src/App.tsx">See example in codesandbox</a></p>
<p>Another convenience: we don‚Äôt need to worry about state anymore, as we‚Äôd do with <code>shouldComponentUpdate</code>. <code>React.memo</code> and its comparison function only deals with props, Child‚Äôs state will be unaffected.</p>
<h3 id="part2.3"><a href="#part2.3">Props with functions: memoization</a></h3>
<p>While comparison functions from above are fun and look good on paper, to be honest, I wouldn‚Äôt use it in a real-world app. (And I wouldn‚Äôt use <code>shouldComponentUpdate</code> either). Especially if I‚Äôm not the only developer on the team. It‚Äôs just too easy to screw it up and add a prop without updating those functions, which can lead to such easy-to-miss and impossible-to-understand bugs, that you can say goodbye to your karma and the sanity of the poor fella who has to fix it.</p>
<p>And this is where actually <code>PureComponent</code> takes the lead in convenience competition. What we would do in the good old days instead of creating inline functions? Well, we‚Äôd just bind the callback to the class instance:</p>
<pre><code class="language-tsx">class Parent extends React.Component {
  onChildClick = () =&gt; {
    // do something here
  }

  render() {
    return &lt;PureChild someprop=&quot;something&quot; onClick={this.onChildClick} /&gt;
  }
}
</code></pre>
<p>This callback will be created only once, will stay the same during all re-renders of <code>Parent</code> regardless of any state changes, and won‚Äôt destroy PureComponent‚Äôs shallow props comparison.</p>
<p>In functional components we don‚Äôt have class instance anymore, everything is just a function now, so we can‚Äôt attach anything to it. Instead, we have‚Ä¶ <s>nothing</s>‚Ä¶ a few ways to preserve the reference to the callback, depending on your use case and how severe are the performance consequences of Child‚Äôs unnecessary re-renders.</p>
<h4 id="part2.3.1"><a href="#part2.3.1">1. useCallback hook</a></h4>
<p>The simplest way that will be enough for probably 99% of use cases is just to use <a href="https://reactjs.org/docs/hooks-reference.html#usecallback">useCallback</a> hook. Wrapping our <code>onClick</code> function in it will preserve it between re-renders if dependencies of the hook don‚Äôt change:</p>
<pre><code class="language-tsx">const Parent = () =&gt; {
  const onChildClick = () =&gt; {
    // do something here
  }

  // dependencies array is empty, so onChildClickMemo won&#x27;t change during Parent re-renders
  const onChildClickMemo = useCallback(onChildClick, []);

  return &lt;PureChild someprop=&quot;something&quot; onClick={onChildClickMemo} /&gt;
}
</code></pre>
<p>What if the <code>onClick</code> callback needs access to some Parent‚Äôs state? In class-based components that was easy: we had access to the entire state in callbacks (if we bind them properly):</p>
<pre><code class="language-tsx">class Parent extends React.Component {
  onChildClick = () =&gt; {
    // check that count is not too big before updating it
    if (this.state.counter &gt; 100) return;
    // do something
  }

  render() {
    return &lt;PureChild someprop=&quot;something&quot; onClick={this.onChildClick} /&gt;
  }
}
</code></pre>
<p>In functional components it‚Äôs also easy: we just add that state to the dependencies of <code>useCallback</code> hook:</p>
<pre><code class="language-tsx">const Parent = () =&gt; {
  const onChildClick = () =&gt; {
    if (counter &gt; 100) return;
    // do something
  }

  // depends on somestate now, function reference will change when state change
  const onChildClickMemo = useCallback(onChildClick, [counter]);

  return &lt;PureChild someprop=&quot;something&quot; onClick={onChildClickMemo} /&gt;
}
</code></pre>
<p>With a small caveat: <code>useCallback</code> now depends on <code>counter</code> state, so it will return a different function when the counter changes. This means <code>PureChild</code> will re-render, even though it doesn‚Äôt depend on that state explicitly. Technically - unnecessary re-render. Does it matter? In most cases, it won‚Äôt make a difference, and performance will be fine. Always measure the actual impact before proceeding to further optimizations.</p>
<p>In <strong>very</strong> rare cases when it actually matters (measure first!), you have at least two more options to work around that limitation.</p>
<h4 id="part2.3.2"><a href="#part2.3.2">2. setState function</a></h4>
<p>If all that you do in the callback is setting state based on some conditions, you can just use the pattern called <a href="https://beta.reactjs.org/apis/react/useState#updating-state-based-on-the-previous-state">‚Äúupdater function‚Äù</a> and move the condition inside that function.</p>
<p>Basically, if you‚Äôre doing something like this:</p>
<pre><code class="language-tsx">const onChildClick = () =&gt; {
  // check &quot;counter&quot; state
  if (counter &gt; 100) return;
  // change &quot;counter&quot; state - the same state as above
  setCounter(counter + 1);
}
</code></pre>
<p>You can do this instead:</p>
<pre><code class="language-tsx">const onChildClick = () =&gt; {
  // don&#x27;t depend on state anymore, checking the condition inside
  setCounter((counter) =&gt; {
    // return the same counter - no state updates
    if (counter &gt; 100) return counter;

    // actually updating the counter
    return counter + 1;
  });
}
</code></pre>
<p>That way <code>onChildClick</code> doesn‚Äôt depend on the counter state itself and state dependency in the <code>useCallback</code> hook won‚Äôt be needed.</p>
<p><a href="https://codesandbox.io/s/memo-with-callbacks-kjzo9y?file=/src/App.tsx">See example in codesandbox</a></p>
<h4 id="part2.3.3"><a href="#part2.3.3">3. mirror state to ref</a></h4>
<p>In case you <em>absolutely</em> have to have access to different states in your callback, and <em>absolutely</em> have to make sure that this callback doesn‚Äôt trigger re-renders of the <code>PureChild</code> component, you can ‚Äúmirror‚Äù whichever state you need to a ref object.</p>
<p><a href="https://beta.reactjs.org/apis/react/useRef">Ref object</a> is just a mutable object that is preserved between re-renders: pretty much like state, but:</p>
<ul>
<li>it‚Äôs mutable</li>
<li>it doesn‚Äôt trigger re-renders when updated</li>
</ul>
<p>You can use it to store values that are not used in render function (see <a href="https://beta.reactjs.org/apis/react/useRef#referencing-a-value-with-a-ref">the docs</a> for more details), so in case of our callbacks it will be something like this:</p>
<pre><code class="language-tsx">const Parent = () =&gt; {
  const [counter, setCounter] = useState(1);
  // creating a ref that will store our &quot;mirrored&quot; counter
  const mirrorStateRef = useRef(null);

  useEffect(() =&gt; {
    // updating ref value when the counter changes
    mirrorStateRef.current = counter;
  }, [counter])

  const onChildClick = () =&gt; {
    // accessing needed value through ref, not statej - only in callback! never during render!
    if (mirrorStateRef.current &gt; 100) return;
    // do something here
  }

  // doesn&#x27;t depend on state anymore, so the function will be preserved through the entire lifecycle
  const onChildClickMemo = useCallback(onChildClick, []);

  return &lt;PureChild someprop=&quot;something&quot; onClick={onChildClickMemo} /&gt;
}
</code></pre>
<p>First: creating a ref object. Then in useEffect hook updating that object with the state value: ref is mutable, so it‚Äôs okay, and its update won‚Äôt trigger re-render, so it‚Äôs safe. Lastly, using the ref value to access data in the callback, that you‚Äôd normally access directly via state. And tada üéâ: you have access to state value in your memoized callback without actually depending on it.</p>
<p><a href="https://codesandbox.io/s/mirror-state-in-ref-13i71j?file=/src/App.tsx">See example in codesandbox</a></p>
<p>Full disclaimer: I have <strong>never</strong> needed this trick in production apps. It‚Äôs more of a thought exercise. If you find yourself in a situation where you‚Äôre actually using this trick to fix actual performance problems, then chances are something is wrong with your app architecture and there are easier ways to solve those problems. Take a looks at <a href="https://www.developerway.com/posts/react-re-renders-guide#part3">Preventing re-renders with composition</a> part of <a href="https://www.developerway.com/posts/react-re-renders-guide">React re-renders guide</a>, maybe you can use those patterns instead.</p>
<h3 id="part2.4"><a href="#part2.4">Props with arrays and objects: memoization</a></h3>
<p>Props that accept arrays or objects are equally tricky for <code>PureComponent</code> and <code>React.memo</code> components. Passing them directly will ruin performance gains since they will be re-created on every re-render:</p>
<pre><code class="language-tsx">&lt;!-- will re-render on every parent re-render --&gt;
&lt;PureChild someArray={[1,2,3]} /&gt;
</code></pre>
<p>And the way to deal with them is exactly the same in both worlds: you either pass state directly to them, so that reference to the array is preserved between re-renders. Or use any memoization techniques to prevent their re-creation. In the old days, those would be dealt with via external libraries like <code>memoize</code>. Today we can still use them, or we can use <a href="https://reactjs.org/docs/hooks-reference.html#usememo">useMemo</a> hook that React gives us:</p>
<pre><code class="language-tsx">// memoize the value
const someArray = useMemo(() =&gt; ([1,2,3]), [])
&lt;!-- now it won&#x27;t re-render --&gt;
&lt;PureChild someArray={someArray} /&gt;
</code></pre>
<h3 id="part2.5"><a href="#part2.5">Unnecessary re-renders because of state</a></h3>
<p>And the final piece of the puzzle. Other than parent re-renders, <code>PureComponent</code> prevents unnecessary re-renders from state updates for us. Now that we don‚Äôt have it, how do we prevent those?</p>
<p>And yet another point to functional components: we don‚Äôt have to think about it anymore! In functional components, state updates that don‚Äôt actually change state don‚Äôt trigger re-render. This code will be completely safe and won‚Äôt need any workarounds from re-renders perspective:</p>
<pre><code class="language-tsx">const Parent = () =&gt; {
  const [state, setState] = useState(0);

  return (
    &lt;&gt;
      &lt;!-- we don&#x27;t actually change state after setting it to 1 when we click on the button --&gt;
      &lt;!-- but it&#x27;s okay, there won&#x27;t be any unnecessary re-renders--&gt;
      &lt;button onClick={() =&gt; setState(1)}&gt;Click me&lt;/button&gt;
    &lt;/&gt;
  )
}
</code></pre>
<p>This behavior is called <a href="https://reactjs.org/docs/hooks-reference.html#bailing-out-of-a-state-update">‚Äúbailing out from state updates‚Äù</a> and is supported natively in useState hook.</p>
<h2 id="part3"><a href="#part3">Bonus: bailing out from state updates quirk</a></h2>
<p>Fun fact: if you don‚Äôt believe me and react docs in the example above, decide to verify how it works by yourself and place <code>console.log</code> in the render function, the result will break your brain:</p>
<pre><code class="language-tsx">const Parent = () =&gt; {
  const [state, setState] = useState(0);

  console.log(&#x27;Log parent re-renders&#x27;);

  return (
    &lt;&gt;
      &lt;button onClick={() =&gt; setState(1)}&gt;Click me&lt;/button&gt;
    &lt;/&gt;
  )
}
</code></pre>
<p>You‚Äôll see that the first click on the button <code>console.log</code> is triggered: which is expected, we change state from 0 to 1. But the second click, where we change state from 1 to 1, which is supposed to bail, will also trigger <code>console.log</code>! But third and all the following clicks will do nothing‚Ä¶ ü§Ø WTF?</p>
<p>Turns out this is a feature, not a bug: React is being smartass here and tries to make sure that it‚Äôs actually safe to bail out on the first ‚Äúsafe‚Äù state update. The ‚Äúbailing out‚Äù in this context means that children won‚Äôt re-render, and <code>useEffect</code> hooks won‚Äôt be triggered. But React will still trigger Parent‚Äôs render function the first time, just in case. See this issue for more details and rationale: <a href="https://github.com/facebook/react/issues/14994">useState not bailing out when state does not change ¬∑ Issue #14994 ¬∑ facebook/react</a></p>
<p><a href="https://codesandbox.io/s/bailing-out-state-updates-vwvp8e?file=/src/App.tsx">See example in codesandbox</a></p>
<h2 id="part4"><a href="#part4">TL;DR Summary</a></h2>
<p>That is all for today, hope you had fun comparing the past and the future, and learned something useful in the process. Quick bullet points of the above wall of text:</p>
<ul>
<li>when migrating PureComponent to functional components, wrapping component in React.memo will give you the same behavior from re-renders perspective as PureComponent</li>
<li>complicated props comparison logic from shouldComponentUpdate can be re-written as an updater function in React.memo</li>
<li>no need to worry about unnecessary state updates in functional components - React handles them for us</li>
<li>when using ‚Äúpure‚Äù components in functional components, passing functions as props can be tricky if they need access to state since we don‚Äôt have instance anymore. But we can use instead:
<ul>
<li>useCallback hook</li>
<li>updater function in state setter</li>
<li>‚Äúmirror‚Äù necessary state data in ref</li>
</ul>
</li>
<li>arrays and objects as props of ‚Äúpure‚Äù components need to be memoized both for PureComponent and React.memo components</li>
</ul>
<p>Live long and prosper in re-renders-free world! ‚úåüèº</p>]]></content:encoded>
      <enclosure
        url="https://www.developerway.com//assets/pure-components-vs-functional-and-hooks/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title><![CDATA[React re-renders guide: everything, all at once]]></title>
      <link>https://www.developerway.com/posts/react-re-renders-guide</link>
      <guid>react-re-renders-guide</guid>
      <pubDate>Tue, 02 Aug 2022 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[React re-renders "cheatsheet". Short descriptions with visual aid and code examples of: what are re-renders, what triggers them, most important re-renders related patterns and antipatterns to remember.]]></description>
      <content:encoded><![CDATA[<h2 id="part1"><a href="#part1">What is re-render in React?</a></h2>
<p>When talking about React performance, there are two major stages that we need to care about:</p>
<ul>
<li><strong>initial render</strong> - happens when a component first appears on the screen</li>
<li><strong>re-render</strong> - second and any consecutive render of a component that is already on the screen</li>
</ul>
<p>Re-render happens when React needs to update the app with some new data. Usually, this happens as a result of a user interacting with the app or some external data coming through via an asynchronous request or some subscription model.</p>
<p>Non-interactive apps that don‚Äôt have any asynchronous data updates will <strong>never</strong> re-render, and therefore don‚Äôt need to care about re-renders performance optimization.</p>
<h3 id="part1.1"><a href="#part1.1">üßê What is a necessary and unnecessary re-render?</a></h3>
<p><strong>Necessary re-render</strong> - re-render of a component that is the source of the changes, or a component that directly uses the new information. For example, if a user types in an input field, the component that manages its state needs to update itself on every keystroke, i.e. re-render.</p>
<p><strong>Unnecessary re-render</strong> - re-render of a component that is propagated through the app via different re-renders mechanisms due to either mistake or inefficient app architecture. For example, if a user types in an input field, and the entire page re-renders on every keystroke, the page has been re-rendered unnecessarily.</p>
<p>Unnecessary re-renders by themselves are <strong>not a problem</strong>: React is very fast and usually able to deal with them without users noticing anything.</p>
<p>However, if re-renders happen too often and/or on very heavy components, this could lead to user experience appearing ‚Äúlaggy‚Äù, visible delays on every interaction, or even the app becoming completely unresponsive.</p>
<hr/>
<h2 id="part2"><a href="#part2">When React component re-renders itself?</a></h2>
<p>There are four reasons why a component would re-render itself: state changes, parent (or children) re-renders, context changes, and hooks changes. There is also a big myth: that re-renders happen when the component‚Äôs props change. By itself, it‚Äôs not true (see the explanation below).</p>
<h3 id="part2.1"><a href="#part2.1">üßê Re-renders reason: state changes</a></h3>
<p>When a component‚Äôs state changes, it will re-render itself. Usually, it happens either in a callback or in <code>useEffect</code> hook.</p>
<p>State changes are the ‚Äúroot‚Äù source of all re-renders.</p>
<p><a href="https://codesandbox.io/s/part2-1-re-renders-because-of-state-ngh8uc?file=/src/App.tsx">See example in codesandbox</a></p>
<p><img src="/assets/react-re-renders-guide/part2-state-changes-example.png" alt=""/></p>
<h3 id="part2.2"><a href="#part2.2">üßê Re-renders reason: parent re-renders</a></h3>
<p>A component will re-render itself if its parent re-renders. Or, if we look at this from the opposite direction: when a component re-renders, it also re-renders all its children.</p>
<p>It always goes ‚Äúdown‚Äù the tree: the re-render of a child doesn‚Äôt trigger the re-render of a parent. (There are a few caveats and edge cases here, see the full guide for more details: <a href="https://www.developerway.com/posts/react-elements-children-parents">The mystery of React Element, children, parents and re-renders</a>).</p>
<p><a href="https://codesandbox.io/s/part-2-2-re-renders-because-of-parent-b0xvxt?file=/src/App.tsx">See example in codesandbox</a></p>
<p><img src="/assets/react-re-renders-guide/part2-parent-example.png" alt=""/></p>
<h3 id="part2.3"><a href="#part2.3">üßê Re-renders reason: context changes</a></h3>
<p>When the value in Context Provider changes, <strong>all</strong> components that use this Context will re-render, even if they don‚Äôt use the changed portion of the data directly. Those re-renders can not be prevented with memoization directly, but there are a few workarounds that can simulate it (see <a href="#part7">Part 7: preventing re-renders caused by Context</a>).</p>
<p><a href="https://codesandbox.io/s/part-2-3-re-render-because-of-context-i75lwh?file=/src/App.tsx">See example in codesandbox</a></p>
<p><img src="/assets/react-re-renders-guide/part2-context-example.png" alt=""/></p>
<h3 id="part2.4"><a href="#part2.4">üßê Re-renders reason: hooks changes</a></h3>
<p>Everything that is happening inside a hook ‚Äúbelongs‚Äù to the component that uses it. The same rules regarding Context and State changes apply here:</p>
<ul>
<li>state change inside the hook will trigger an <strong>unpreventable</strong> re-rerender of the ‚Äúhost‚Äù component</li>
<li>if the hook uses Context and Context‚Äôs value changes, it will trigger an <strong>unpreventable</strong> re-rerender of the ‚Äúhost‚Äù component</li>
</ul>
<p>Hooks can be chained. Every single hook inside the chain still ‚Äúbelongs‚Äù to the ‚Äúhost‚Äù component, and the same rules apply to any of them.</p>
<p><a href="https://codesandbox.io/s/part-2-4-re-render-because-of-hooks-5kpdrp?file=/src/App.tsx">See example in codesandbox</a></p>
<p><img src="/assets/react-re-renders-guide/part2-hooks-example.png" alt=""/></p>
<h3 id="part2.5"><a href="#part2.5">‚õîÔ∏è Re-renders reason: props changes (the big myth)</a></h3>
<p>It doesn‚Äôt matter whether the component‚Äôs props change or not when talking about re-renders of not memoized components.</p>
<p>In order for props to change, they need to be updated by the parent component. This means the parent would have to re-render, which will trigger re-render of the child component regardless of its props.</p>
<p><a href="https://codesandbox.io/s/part-2-5-re-render-props-not-relevant-2b8o0p?file=/src/App.tsx">See example in codesandbox</a></p>
<p>Only when memoization techniques are used (<code>React.memo</code>, <code>useMemo</code>), then props change becomes important.</p>
<p><img src="/assets/react-re-renders-guide/part2-props-myth.png" alt=""/></p>
<hr/>
<h2 id="part3"><a href="#part3">Preventing re-renders with composition</a></h2>
<h3 id="part3.1"><a href="#part3.1">‚õîÔ∏è Antipattern: Creating components in render function</a></h3>
<p>Creating components inside render function of another component is an anti-pattern that can be the biggest performance killer. On every re-render React will re-mount this component (i.e. destroy it and re-create it from scratch), which is going to be much slower than a normal re-render. On top of that, this will lead to such bugs as:</p>
<ul>
<li>possible ‚Äúflashes‚Äù of content during re-renders</li>
<li>state being reset in the component with every re-render</li>
<li>useEffect with no dependencies triggered on every re-render</li>
<li>if a component was focused, focus will be lost</li>
</ul>
<p><a href="https://codesandbox.io/s/part-3-1-creating-components-inline-t2vmkj?file=/src/App.tsx">See example in codesandbox</a></p>
<p>Additional resources to read: <a href="https://www.developerway.com/posts/how-to-write-performant-react-code">How to write performant React code: rules, patterns, do&#x27;s and don&#x27;ts</a></p>
<p><img src="/assets/react-re-renders-guide/part3-creating-components.png" alt=""/></p>
<h3 id="part3.2"><a href="#part3.2">‚úÖ Preventing re-renders with composition: moving state down</a></h3>
<p>This pattern can be beneficial when a heavy component manages state, and this state is only used on a small isolated portion of the render tree. A typical example would be opening/closing a dialog with a button click in a complicated component that renders a significant portion of a page.</p>
<p>In this case, the state that controls modal dialog appearance, dialog itself, and the button that triggers the update can be encapsulated in a smaller component. As a result, the bigger component won‚Äôt re-render on those state changes.</p>
<p><a href="https://codesandbox.io/s/part-3-2-moving-state-down-vlh4gf?file=/src/App.tsx">See example in codesandbox</a></p>
<p>Additional resources to read: <a href="https://www.developerway.com/posts/react-elements-children-parents">The mystery of React Element, children, parents and re-renders</a>, <a href="https://www.developerway.com/posts/how-to-write-performant-react-code">How to write performant React code: rules, patterns, do&#x27;s and don&#x27;ts</a></p>
<p><img src="/assets/react-re-renders-guide/part3-moving-state-down.png" alt=""/></p>
<h3 id="part3.3"><a href="#part3.3">‚úÖ Preventing re-renders with composition: children as props</a></h3>
<p>This can also be called ‚Äúwrap state around children‚Äù. This pattern is similar to ‚Äúmoving state down‚Äù: it encapsulates state changes in a smaller component. The difference here is that state is used on an element that wraps a slow portion of the render tree, so it can‚Äôt be extracted that easily. A typical example would be <code>onScroll</code> or <code>onMouseMove</code> callbacks attached to the root element of a component.</p>
<p>In this situation, state management and components that use that state can be extracted into a smaller component, and the slow component can be passed to it as <code>children</code>. From the smaller component perspective <code>children</code> are just prop, so they will not be affected by the state change and therefore won‚Äôt re-render.</p>
<p><a href="https://codesandbox.io/s/part-3-3-children-as-props-59icyq?file=/src/App.tsx">See example in codesandbox</a></p>
<p>Additional resources to read: <a href="https://www.developerway.com/posts/react-elements-children-parents">The mystery of React Element, children, parents and re-renders</a></p>
<p><img src="/assets/react-re-renders-guide/part3-passing-as-children.png" alt=""/></p>
<h3 id="part3.4"><a href="#part3.4">‚úÖ Preventing re-renders with composition: components as props</a></h3>
<p>Pretty much the same as the previous pattern, with the same behavior: it encapsulates the state inside a smaller component, and heavy components are passed to it as props. Props are not affected by the state change, so heavy components won‚Äôt re-render.</p>
<p>Can be useful when a few heavy components are independent from the state, but can‚Äôt be extracted as children as a group.</p>
<p><a href="https://codesandbox.io/s/part-3-4-passing-components-as-props-9h3o5u?file=/src/App.tsx">See example in codesandbox</a></p>
<p>Read more about passing components as props here: <a href="https://www.developerway.com/posts/react-component-as-prop-the-right-way">React component as prop: the right way‚Ñ¢Ô∏è</a>, <a href="https://www.developerway.com/posts/react-elements-children-parents">The mystery of React Element, children, parents and re-renders</a></p>
<p><img src="/assets/react-re-renders-guide/part3-passing-as-props.png" alt=""/></p>
<hr/>
<h2 id="part4"><a href="#part4">Preventing re-renders with React.memo</a></h2>
<p>Wrapping a component in <code>React.memo</code> will stop the downstream chain of re-renders that is triggered somewhere up the render tree, unless this component‚Äôs props have changed.</p>
<p>This can be useful when rendering a heavy component that is not dependent on the source of re-renders (i.e. state, changed data).</p>
<p><a href="https://codesandbox.io/s/part-4-simple-memo-fz4xhw?file=/src/App.tsx">See example in codesandbox</a></p>
<p><img src="/assets/react-re-renders-guide/part4-memo-normal-example.png" alt=""/></p>
<h3 id="part4.1"><a href="#part4.1">‚úÖ React.memo: component with props</a></h3>
<p><strong>All props</strong> that are not primitive values have to be memoized for React.memo to work</p>
<p><a href="https://codesandbox.io/s/part-4-1-memo-on-component-with-props-fq55hm?file=/src/App.tsx">See example in codesandbox</a></p>
<p><img src="/assets/react-re-renders-guide/part4-memo-with-props.png" alt=""/></p>
<h3 id="part4.2"><a href="#part4.2">‚úÖ React.memo: components as props or children</a></h3>
<p><code>React.memo</code> has to be applied to the elements passed as children/props. Memoizing the parent component will not work: children and props will be objects, so they will change with every re-render.</p>
<p>See here for more details on how memoization works for children/parent relationships:  <a href="https://www.developerway.com/posts/react-elements-children-parents">The mystery of React Element, children, parents and re-renders</a></p>
<p><a href="https://codesandbox.io/s/part-4-2-memo-on-components-in-props-55tebl?file=/src/App.tsx">See example in codesandbox</a></p>
<p><img src="/assets/react-re-renders-guide/part4-memo-as-props.png" alt=""/></p>
<hr/>
<h2 id="part5"><a href="#part5">Improving re-renders performance with useMemo/useCallback</a></h2>
<h3 id="part5.1"><a href="#part5.1">‚õîÔ∏è Antipattern: unnecessary useMemo/useCallback on props</a></h3>
<p>Memoizing props by themselves will not prevent re-renders of a child component. If a parent component re-renders, it will trigger re-render of a child component regardless of its props.</p>
<p><a href="https://codesandbox.io/s/part-5-1-unnecessary-usememo-lmk8fq?file=/src/App.tsx">See  example in codesandbox</a></p>
<p><img src="/assets/react-re-renders-guide/part5-unnecessary-usememo-on-props.png" alt=""/></p>
<h3 id="part5.2"><a href="#part5.2">‚úÖ Necessary useMemo/useCallback</a></h3>
<p>If a child component is wrapped in <code>React.memo</code>, all props that are not primitive values have to be memoized</p>
<p><a href="https://codesandbox.io/s/part-5-2-usememo-in-props-trx97x?file=/src/App.tsx">See  example in codesandbox</a></p>
<p><img src="/assets/react-re-renders-guide/part5-necessary-usememo-props.png" alt=""/></p>
<p>If a component uses non-primitive value as a dependency in hooks like <code>useEffect</code>, <code>useMemo</code>, <code>useCallback</code>, it should be memoized.</p>
<p><a href="https://codesandbox.io/s/part-5-2-usememo-in-effect-88tbov">See  example in codesandbox</a></p>
<p><img src="/assets/react-re-renders-guide/part5-necessary-usememo-dep.png" alt=""/></p>
<h3 id="part5.3"><a href="#part5.3">‚úÖ useMemo for expensive calculations</a></h3>
<p>One of the use cases for <code>useMemo</code> is to avoid expensive calculations on every re-render.</p>
<p><code>useMemo</code> has its cost (consumes a bit of memory and makes initial render slightly slower), so it should not be used for every calculation. In React, mounting and updating components will be the most expensive calculation in most cases (unless you‚Äôre actually calculating prime numbers, which you shouldn‚Äôt do on the frontend anyway).</p>
<p>As a result, the typical use case for <code>useMemo</code> would be to memoize React elements. Usually parts of an existing render tree or results of generated render tree, like a map function that returns new elements.</p>
<p>The cost of ‚Äúpure‚Äù javascript operations like sorting or filtering an array is usually negligible, compare to components updates.</p>
<p><a href="https://codesandbox.io/s/part-5-3-usememo-for-expensive-calculations-trx97x?file=/src/App.tsx">See  example in codesandbox</a></p>
<p><img src="/assets/react-re-renders-guide/part5-necessary-usememo-complex.png" alt=""/></p>
<hr/>
<h2 id="part6"><a href="#part6">Improving re-render performance of lists</a></h2>
<p>In addition to the regular re-renders rules and patterns, the <code>key</code> attribute can affect the performance of lists in React.</p>
<p><strong>Important</strong>: just providing <code>key</code> attribute will not improve lists&#x27; performance. To prevent re-renders of list elements you need to wrap them in <code>React.memo</code> and follow all of its best practices.</p>
<p>Value in <code>key</code> should be a string, that is consistent between re-renders for every element in the list. Typically, item‚Äôs <code>id</code>  or array‚Äôs <code>index</code> is used for that.</p>
<p>It is okay to use array‚Äôs <code>index</code> as key, if the list is <strong>static</strong>, i.e. elements are not added/removed/inserted/re-ordered.</p>
<p>Using array‚Äôs index on dynamic lists can lead to:</p>
<ul>
<li>bugs if items have state or any uncontrolled elements (like form inputs)</li>
<li>degraded performance if items are wrapped in React.memo</li>
</ul>
<p>Read about this in more details here: <a href="https://www.developerway.com/posts/react-key-attribute">React key attribute: best practices for performant lists</a>.</p>
<p><a href="https://codesandbox.io/s/part-6-static-list-with-index-and-id-as-key-7i0ebi?file=/src/App.tsx">See  example in codesandbox - static list</a></p>
<p><a href="https://codesandbox.io/s/part-6-dynamic-list-with-index-and-id-as-key-s50knr?file=/src/App.tsx">See  example in codesandbox - dynaminc list</a></p>
<p><img src="/assets/react-re-renders-guide/part6-lists-example.png" alt=""/></p>
<h3 id="part6.1"><a href="#part6.1">‚õîÔ∏è Antipattern: random value as key in lists</a></h3>
<p>Randomly generated values should never be used as values in <code>key</code> attribute in lists. They will lead to React re-mounting items on every re-render, which will lead to:</p>
<ul>
<li>very poor performance of the list</li>
<li>bugs if items have state or any uncontrolled elements (like form inputs)</li>
</ul>
<p><a href="https://codesandbox.io/s/part-6-1-random-values-in-keys-z1zhy6?file=/src/App.tsx">See example in codesandbox</a></p>
<p><img src="/assets/react-re-renders-guide/part6-lists-antipattern.png" alt=""/></p>
<hr/>
<h2 id="part7"><a href="#part7">Preventing re-renders caused by Context</a></h2>
<h3 id="part7.1"><a href="#part7.1">‚úÖ Preventing Context re-renders: memoizing Provider value</a></h3>
<p>If Context Provider is placed not at the very root of the app, and there is a possibility it can re-render itself because of changes in its ancestors, its value should be memoized.</p>
<p><a href="https://codesandbox.io/s/part-7-1-memoize-context-provider-value-qgn0me?file=/src/App.tsx">See example in codesandbox</a></p>
<p><img src="/assets/react-re-renders-guide/part7-context-provider-memo.png" alt=""/></p>
<h3 id="part7.2"><a href="#part7.2">‚úÖ Preventing Context re-renders: splitting data and API</a></h3>
<p>If in Context there is a combination of data and API (getters and setters) they can be split into different Providers under the same component. That way, components that use API only won‚Äôt re-render when the data changes.</p>
<p>Read more about this pattern here: <a href="https://www.developerway.com/posts/how-to-write-performant-react-apps-with-context">How to write performant React apps with Context</a></p>
<p><a href="https://codesandbox.io/s/part-7-2-split-context-data-and-api-r8lsws?file=/src/App.tsx">See example in codesandbox</a></p>
<p><img src="/assets/react-re-renders-guide/part7-context-split-api.png" alt=""/></p>
<h3 id="part7.3"><a href="#part7.3">‚úÖ Preventing Context re-renders: splitting data into chunks</a></h3>
<p>If Context manages a few independent data chunks, they can be split into smaller providers under the same provider. That way, only consumers of changed chunk will re-render.</p>
<p>Read more about this pattern here: <a href="https://www.developerway.com/posts/how-to-write-performant-react-apps-with-context">How to write performant React apps with Context</a></p>
<p><a href="https://codesandbox.io/s/part-7-3-split-context-into-chunks-dbg20m?file=/src/App.tsx">See example in codesandbox</a></p>
<p><img src="/assets/react-re-renders-guide/part7-context-split-data.png" alt=""/></p>
<h3 id="part7.4"><a href="#part7.4">‚úÖ Preventing Context re-renders: Context selectors</a></h3>
<p>There is no way to prevent a component that uses a portion of Context value from re-rendering, even if the used piece of data hasn‚Äôt changed, even with <code>useMemo</code> hook.</p>
<p>Context selectors, however, could be faked with the use of higher-order components and <code>React.memo</code>.</p>
<p>Read more about this pattern here: <a href="https://www.developerway.com/posts/higher-order-components-in-react-hooks-era">Higher-Order Components in React Hooks era</a></p>
<p><a href="https://codesandbox.io/s/part-7-4-context-selector-lc8n5g?file=/src/App.tsx">See example in codesandbox</a></p>
<p><img src="/assets/react-re-renders-guide/part7-context-selectors.png" alt=""/></p>]]></content:encoded>
      <enclosure url="https://www.developerway.com//assets/react-re-renders-guide/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title><![CDATA[The mystery of React Element, children, parents and re-renders]]></title>
      <link>https://www.developerway.com/posts/react-elements-children-parents</link>
      <guid>react-elements-children-parents</guid>
      <pubDate>Mon, 04 Jul 2022 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Looking into what is React Element, exploring various children vs parents relationship in React, and how they affect re-renders]]></description>
      <content:encoded><![CDATA[<p>In one of the previous articles about <a href="/posts/components-composition-how-to-get-it-right">React composition</a>, I showed an example of how to improve performance of a component with heavy state operations by passing other components to it as children instead of rendering them directly. This article received a question, which sent me into another investigative spiral on how React works, which in turn at some point made me doubt everything that I know about React and even question my own sanity for a short while. Children are not children, parents are not parents, memoization doesn‚Äôt work as it should, life is meaningless, re-renders control our life and nothing can stop them (spoiler alert: I emerged victorious from it üòÖ).</p>
<p>Intrigued I hope? üòâ Let me explain.</p>
<h2>The ‚Äúchildren‚Äù pattern and a few mysteries</h2>
<p>The pattern itself goes like this: imagine you have some frequent state changes in a component. For example, the state is updated in <code>onMouseMove</code> callback.</p>
<pre><code class="language-tsx">const MovingComponent = () =&gt; {
  const [state, setState] = useState({ x: 100, y: 100 });

  return (
    &lt;div
      // when the mouse moves inside this component, update the state
      onMouseMove={(e) =&gt; setState({ x: e.clientX - 20, y: e.clientY - 20 })}
      // use this state right away - the component will follow mouse movements
      style={{ left: state.x, top: state.y }}
    &gt;
      &lt;ChildComponent /&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>Now, we know that React components re-render themselves and all their children when the state is updated. In this case, on every mouse move the state of <code>MovingComponent</code> is updated, its re-render is triggered, and as a result, <code>ChildComponent</code> will re-render as well. If the <code>ChildComponent</code> is heavy, its frequent re-renders can cause performance problems for your app.</p>
<p>The way to fight this, other than <code>React.memo</code>, is to extract <code>ChildComponent</code> outside and pass it as children.</p>
<pre><code class="language-tsx">const MovingComponent = ({ children }) =&gt; {
  const [state, setState] = useState({ x: 100, y: 100 });

  return (
    &lt;div onMouseMove={(e) =&gt; setState({ x: e.clientX - 20, y: e.clientY - 20 })} style={{ left: state.x, top: state.y }}&gt;
      // children now will not be re-rendered
      {children}
    &lt;/div&gt;
  );
};
</code></pre>
<p>And compose those two components together like this:</p>
<pre><code class="language-tsx">const SomeOutsideComponent = () =&gt; {
  return (
    &lt;MovingComponent&gt;
      &lt;ChildComponent /&gt;
    &lt;/MovingComponent&gt;
  );
};
</code></pre>
<p>The <code>ChildComponent</code> ‚Äúbelongs‚Äù to the <code>SomeOutsideComponent</code> now, which is a parent component of <code>MovingComponent</code> and not affected by the state change in it. As a result, it won‚Äôt be re-rendered on every mouse move. <a href="https://codesandbox.io/s/childrens-pattern-example-29bi9p">See the codesandbox</a> with both examples.</p>
<p><strong>Mystery1: but wait, they are still children!</strong>. They are rendered inside a div that changes its style on every mouse move <code>&lt;div style={{ left: state.x, top: state.y }}&gt;</code>, i.e. this div is the parent that re-renders. Why exactly children don‚Äôt re-render here? ü§î</p>
<p>It gets even more interesting.</p>
<p><strong>Mystery2: children as a render function</strong>. If I pass children as a render function (a common pattern for cross-components data sharing), <code>ChildComponent</code> starts re-rendering itself again, even if it doesn‚Äôt depend on the changed state:</p>
<pre><code class="language-tsx">const MovingComponent = ({ children }) =&gt; {
  ...
  return (
    &lt;div ...// callbacks same as before
    &gt;
      // children as render function with some data
      // data doesn&#x27;t depend on the changed state!
      {children({ data: &#x27;something&#x27; })}
    &lt;/div&gt;
  );
};

const SomeOutsideComponent = () =&gt; {
  return (
    &lt;MovingComponent&gt;
      // ChildComponent re-renders when state in MovingComponent changes!
      // even if it doesn&#x27;t use the data that is passed from it
      {() =&gt; &lt;ChildComponent /&gt;}
    &lt;/MovingComponent&gt;
  )
}
</code></pre>
<p>But why? It still ‚Äúbelongs‚Äù to the <code>SomeOutsideComponent</code> component, and this one doesn‚Äôt re-render ü§î <a href="https://codesandbox.io/s/childrens-pattern-example-with-render-function-dk662n?file=/src/App.tsx">Codesandbox with the example</a>.</p>
<p><strong>Mystery 3: React.memo behavior</strong>. What if I introduce some state to the outside component <code>SomeOutsideComponent</code> and try to prevent re-renders of its children with R<code>eact.memo</code>? In the ‚Äúnormal‚Äù parent-child relationship just wrapping <code>MovingComponent</code> with it is enough, but when <code>ChildComponent</code> is passed as children, it still re-renders, even if <code>MovingComponent</code> is memoized!</p>
<pre><code class="language-tsx">// wrapping MovingComponent in memo to prevent it from re-rendering
const MovingComponentMemo = React.memo(MovingComponent);

const SomeOutsideComponent = () =&gt; {
  // trigger re-renders here with state
  const [state, setState] = useState();

  return (
    &lt;MovingComponentMemo&gt;
      &lt;!-- ChildComponent will still re-render when SomeOutsideComponent re-renders --&gt;
      &lt;ChildComponent /&gt;
    &lt;/MovingComponentMemo&gt;
  )
}
</code></pre>
<p>It works though if I memoize just <code>ChildComponent</code> without its parent:</p>
<pre><code class="language-tsx">// wrapping ChildComponent in memo to prevent it from re-rendering
const ChildComponentMemo = React.memo(ChildComponent);

const SomeOutsideComponent = () =&gt; {
  // trigger re-renders here with state
  const [state, setState] = useState();

  return (
    &lt;MovingComponent&gt;
      &lt;!-- ChildComponent won&#x27;t re-render, even if the parent is not memoized --&gt;
      &lt;ChildComponentMemo /&gt;
    &lt;/MovingComponent&gt;
  )
}
</code></pre>
<p><a href="https://codesandbox.io/s/childrens-pattern-example-with-react-memo-vx9qqv?file=/src/App.tsx">See codesandbox.</a></p>
<p><strong>Mystery4: useCallback hook behavior</strong>. But when I pass <code>ChildComponent</code> as a render function, and try to prevent its re-renders by memoizing that function, it just doesn‚Äôt work üò¨</p>
<pre><code class="language-tsx">const SomeOutsideComponent = () =&gt; {
  // trigger re-renders here with state
  const [state, setState] = useState();

  // trying to prevent ChildComponent from re-rendering by memoising render function. Won&#x27;t work!
  const child = useCallback(() =&gt; &lt;ChildComponent /&gt;, []);

  return (
    &lt;MovingComponent&gt;
      &lt;!-- Memoized render function. Didn&#x27;t help with re-renders though --&gt;
      {child}
    &lt;/MovingComponent&gt;
  )
}
</code></pre>
<p><a href="https://codesandbox.io/s/childrens-pattern-example-with-render-func-and-use-callback-i381k7?file=/src/App.tsx">See codesandbox</a>.</p>
<p>Can you solve those mysteries now, without looking further into the answers? üòâ</p>
<p>If you decided you want to know the answers right now, a few key concepts we need to understand first, before jumping into the solutions.</p>
<h2>What exactly are React ‚Äúchildren‚Äù?</h2>
<p>First of all, what exactly are ‚Äúchildren‚Äù, when they are passed like this?</p>
<pre><code class="language-tsx">const Parent = ({ children }) =&gt; {
  return &lt;&gt;{children}&lt;/&gt;;
};

&lt;Parent&gt;
  &lt;Child /&gt;
&lt;/Parent&gt;;
</code></pre>
<p>Well, the answer is simple - <a href="https://reactjs.org/docs/composition-vs-inheritance.html#containment">they are just a prop</a>. The fact that we‚Äôre accessing them through the rest of the props kinda gives it away üòÅ</p>
<pre><code class="language-tsx">const Parent = (props) =&gt; {
  return &lt;&gt;{props.children}&lt;/&gt;;
};
</code></pre>
<p>The fancy ‚Äúcomposition‚Äù pattern that we use is nothing more than a syntax sugar for our convenience. We can even re-write it to be a prop explicitly, it will be exactly the same:</p>
<pre><code class="language-tsx">&lt;Parent children={&lt;Child /&gt;} /&gt;
</code></pre>
<p>And same as any other prop, we can pass components there as Elements, Functions, or Components - this is where the ‚Äúrender function in children‚Äù pattern comes from. We can totally do this:</p>
<pre><code class="language-tsx">// as prop
&lt;Parent children={() =&gt; &lt;Child /&gt;} /&gt;

// &quot;normal&quot; syntax
&lt;Parent&gt;
  {() =&gt; &lt;Child /&gt;}
&lt;/Parent&gt;

// implementation
const Parent = ({ children }) =&gt; {
  return &lt;&gt;{children()}&lt;/&gt;
}
</code></pre>
<p>or even this:</p>
<pre><code class="language-tsx">&lt;Parent children={Child} /&gt;;

const Parent = ({ children: Child }) =&gt; {
  return &lt;&gt;{&lt;Child /&gt;}&lt;/&gt;;
};
</code></pre>
<p>Although the last one probably shouldn‚Äôt do, no one on your team will appreciate it.</p>
<p>See this article for more details on those patterns, how they work and the re-renders related caveats: <a href="/posts/react-component-as-prop-the-right-way">React component as prop: the right way‚Ñ¢Ô∏è</a></p>
<p>In a way, this gives us the answer to the mystery number one, if the answer ‚Äúcomponents passed as ‚Äúchildren‚Äù don‚Äôt re-render since they are just props‚Äù is acceptable.</p>
<h2>What is React Element?</h2>
<p>The second important thing to understand is what exactly is happening when I do this:</p>
<pre><code class="language-tsx">const child = &lt;Child /&gt;;
</code></pre>
<p>Quite often people assume that this is how components are rendered, and this is when the rendering cycle for the <code>Child</code> component kicks in. This is not true.</p>
<p><code>&lt;Child /&gt;</code> is what is called an ‚ÄúElement‚Äù. This is nothing more than syntax sugar again for a function <a href="https://reactjs.org/docs/react-api.html#createelement">React.createElement</a> that returns an object. And this object is just a description of the things you want to see on the screen <em>when this element actually ends up in the render tree</em>. Not sooner.</p>
<p>Basically, if I do this:</p>
<pre><code class="language-tsx">const Parent = () =&gt; {
  // will just sit there idly
  const child = &lt;Child /&gt;;

  return &lt;div /&gt;;
};
</code></pre>
<p><code>child</code> constant will be just a constant that contains an object that just sits there idly.</p>
<p>You can even replace this syntax sugar with a direct function call:</p>
<pre><code class="language-tsx">const Parent = () =&gt; {
  // exactly the same as &lt;Child /&gt;
  const child = React.createElement(Child, null, null);

  return &lt;div /&gt;;
};
</code></pre>
<p><a href="https://codesandbox.io/s/react-create-element-w1izhe?file=/src/App.tsx">See codesandbox.</a></p>
<p><strong>Only</strong> when I actually include it in the return result (which is a synonym for ‚Äúrender those stuff‚Äù in functional components), and <strong>only</strong> after <code>Parent</code> component renders itself, will the actual render of <code>Child</code> component be triggered.</p>
<pre><code class="language-tsx">const Parent = () =&gt; {
  // render of Child will be triggered when Parent re-renders
  // since it&#x27;s included in the return
  const child = &lt;Child /&gt;;

  return &lt;div&gt;{child}&lt;/div&gt;;
};
</code></pre>
<h2>Updating Elements</h2>
<p>Elements are immutable objects. The only way to update an Element, and trigger its corresponding component re-render, is to re-create an object itself. This is exactly what is happening during re-renders:</p>
<pre><code class="language-tsx">const Parent = () =&gt; {
  // child definition object will be re-created.
  // so Child component will be re-rendered when Parent re-renders
  const child = &lt;Child /&gt;;

  return &lt;div&gt;{child}&lt;/div&gt;;
};
</code></pre>
<p>If the <code>Parent</code> component re-renders, the content of the <code>child</code> constant will be re-created from scratch, which is fine and super cheap since it‚Äôs just an object. <code>child</code> is a new Element from React perspective (we re-created the object), but in exactly the same place and exactly the same type, so React will just update the existing component with the new data (re-render the existing <code>Child</code>).</p>
<p>And this is what allows memoization to work: if I wrap <code>Child</code> in <code>React.memo</code></p>
<pre><code class="language-tsx">const ChildMemo = React.memo(Child);

const Parent = () =&gt; {
  const child = &lt;ChildMemo /&gt;;

  return &lt;div&gt;{child}&lt;/div&gt;;
};
</code></pre>
<p>or memoize the result of the function call</p>
<pre><code class="language-tsx">const Parent = () =&gt; {
  const child = useMemo(() =&gt; &lt;Child /&gt;, []);

  return &lt;div&gt;{child}&lt;/div&gt;;
};
</code></pre>
<p>the definition object will not be re-created, React will think that it doesn‚Äôt need updating, and Child‚Äôs re-render won‚Äôt happen.</p>
<p>React docs give a bit more details on how all of this works if you fancy an even deeper dive: <a href="https://reactjs.org/docs/rendering-elements.html">Rendering Elements</a>, <a href="https://reactjs.org/docs/react-without-jsx.html">React Without JSX</a>, <a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html#elements-describe-the-tree">React Components, Elements, and Instances</a>.</p>
<h2>Resolving the mysteries</h2>
<p>Now, that we know all of the above, it‚Äôs very easy to resolve all the mysteries that triggered this investigation. Key points to remember:</p>
<ol>
<li>When we‚Äôre writing <code>const child = &lt;Child /&gt;</code>, we‚Äôre just creating an <code>Element</code>, i.e. component definition, not rendering it. This definition is an immutable object.</li>
<li>Component from this definition will be rendered only when it ends up in the actual render tree. For functional components, it‚Äôs when you actually return it from the component.</li>
<li>Re-creating the definition object will trigger the corresponding component‚Äôs re-render</li>
</ol>
<p>And now to the mysteries&#x27; solutions.</p>
<p><strong>Mystery 1</strong>: why components that are passed as props don‚Äôt re-render?</p>
<pre><code class="language-tsx">const MovingComponent = ({ children }) =&gt; {
  // this will trigger re-render
  const [state, setState] = useState();
  return (
    &lt;div
      // ...
      style={{ left: state.x, top: state.y }}
    &gt;
      &lt;!-- those won&#x27;t re-render because of the state change --&gt;
      {children}
    &lt;/div&gt;
  );
};

const SomeOutsideComponent = () =&gt; {
  return (
    &lt;MovingComponent&gt;
      &lt;ChildComponent /&gt;
    &lt;/MovingComponent&gt;
  )
}
</code></pre>
<p>‚Äúchildren‚Äù is a <code>&lt;ChildComponent /&gt;</code> element that is created in <code>SomeOutsideComponent</code>. When <code>MovingComponent</code> re-renders because of its state change, its props stay the same. Therefore any <code>Element</code> (i.e. definition object) that comes from props won‚Äôt be re-created, and therefore re-renders of those components won‚Äôt happen.</p>
<p><strong>Mystery 2</strong>: if children are passed as a render function, they start re-rendering. Why?</p>
<pre><code class="language-tsx">const MovingComponent = ({ children }) =&gt; {
  // this will trigger re-render
  const [state, setState] = useState();
  return (
    &lt;div ///...
    &gt;
      &lt;!-- those will re-render because of the state change --&gt;
      {children()}
    &lt;/div&gt;
  );
};

const SomeOutsideComponent = () =&gt; {
  return (
    &lt;MovingComponent&gt;
      {() =&gt; &lt;ChildComponent /&gt;}
    &lt;/MovingComponent&gt;
  )
}
</code></pre>
<p>In this case ‚Äúchildren‚Äù are a function, and the Element (definition object) is the result of calling this function. We call this function inside <code>MovingComponent</code>, i.e. we will call it on every re-render. Therefore on every re-render, we will re-create the definition object <code>&lt;ChildComponent /&gt;</code>, which as a result will trigger ChildComponent‚Äôs re-render.</p>
<p><strong>Mystery 3</strong>: why wrapping ‚Äúparent‚Äù component in <code>React.memo</code> won&#x27;t prevent the &quot;child&quot; from outside re-render? And why if ‚Äúchild‚Äù is wrapped in it, there is no need to wrap the parent?</p>
<pre><code class="language-tsx">// wrapping MovingComponent in memo to prevent it from re-rendering
const MovingComponentMemo = React.memo(MovingComponent);

const SomeOutsideComponent = () =&gt; {
  // trigger re-renders here with state
  const [state, setState] = useState();

  return (
    &lt;MovingComponentMemo&gt;
      &lt;!-- ChildComponent will re-render when SomeOutsideComponent re-renders --&gt;
      &lt;ChildComponent /&gt;
    &lt;/MovingComponentMemo&gt;
  )
}
</code></pre>
<p>Remember that children are just props? We can re-write the code above to make the flow clearer:</p>
<pre><code class="language-tsx">const SomeOutsideComponent = () =&gt; {
  // ...
  return &lt;MovingComponentMemo children={&lt;ChildComponent /&gt;} /&gt;;
};
</code></pre>
<p>We are memoizing only <code>MovingComponentMemo</code> here, but it still has children prop, which accepts an Element (i.e. an object). We re-create this object on every re-render, <a href="https://reactjs.org/docs/react-api.html#reactmemo">memoized component</a> will try to do the props check, will detect that children prop changed, and will trigger re-render of <code>MovingComponentMemo</code>. And since ChildComponent‚Äôs definition was re-created, it will trigger its re-render as well.</p>
<p>And if we do the opposite and just wrap <code>ChildComponent</code>:</p>
<pre><code class="language-tsx">// wrapping ChildComponent in memo to prevent it from re-rendering
const ChildComponentMemo = React.memo(ChildComponent);

const SomeOutsideComponent = () =&gt; {
  // trigger re-renders here with state
  const [state, setState] = useState();

  return (
    &lt;MovingComponent&gt;
      &lt;!-- ChildComponent won&#x27;t be re-rendered anymore --&gt;
      &lt;ChildComponentMemo /&gt;
    &lt;/MovingComponent&gt;
  )
}
</code></pre>
<p>In this case, <code>MovingComponent</code> will still have ‚Äúchildren‚Äù prop, but it will be memoized, so its value will be preserved between re-renders. <code>MovingComponent</code> is not memoized itself, so it will re-render, but when React reaches the ‚Äúchildren‚Äù part, it will see that definition of <code>ChildComponentMemo</code> hasn‚Äôt changed, so it will skip this part. Re-render won‚Äôt happen.</p>
<p><a href="https://codesandbox.io/s/childrens-pattern-example-with-react-memo-vx9qqv">See the codesandbox</a>.</p>
<p><strong>Mystery 4</strong>: when passing children as a function, why memoizing this function doesn‚Äôt work?</p>
<pre><code class="language-tsx">const SomeOutsideComponent = () =&gt; {
  // trigger re-renders here with state
  const [state, setState] = useState();

  // this memoization doesn&#x27;t prevent re-renders of ChildComponent
  const child = useCallback(() =&gt; &lt;ChildComponent /&gt;, []);

  return &lt;MovingComponent&gt;{child}&lt;/MovingComponent&gt;;
};
</code></pre>
<p>Let‚Äôs first re-write it with ‚Äúchildren‚Äù as a prop, to make the flow easier to understand:</p>
<pre><code class="language-tsx">const SomeOutsideComponent = () =&gt; {
  // trigger re-renders here with state
  const [state, setState] = useState();

  // this memoization doesn&#x27;t prevent re-renders of ChildComponent
  const child = useCallback(() =&gt; &lt;ChildComponent /&gt;, []);

  return &lt;MovingComponent children={child} /&gt;;
};
</code></pre>
<p>Now, what we have here is: <code>SomeOutsideComponent</code> triggers re-render. <code>MovingComponent</code> is its child, and it‚Äôs not memoized, so it will re-render as well. When it re-renders, it will call the children function during re-render. The function is memoized, yes, but its return is not. So on every call, it will call <code>&lt;ChildComponent /&gt;</code>, i.e. will create a new definition object, which in turn will trigger re-render of <code>ChildComponent</code>.</p>
<p>That flow also means, that if we want to prevent <code>ChildComponent</code> from re-renders here, we have two ways to do that. We either need to memoize the function as it is now <strong>AND</strong> wrap <code>MovingComponent</code> in <code>React.memo</code>: this will prevent <code>MovingComponent</code> from re-rendering, which means the ‚Äúchildren‚Äù function never will be called, and <code>ChildComponent</code> definition will never be updated.</p>
<p><strong>OR</strong>, we can remove function memoization here, and just wrap <code>ChildComponent</code> in <code>React.memo</code>: <code>MovingComponent</code> will re-render, ‚Äúchildren‚Äù function will be triggered, but its result will be memoized, so <code>ChildComponent</code> will never re-render.</p>
<p>And indeed, both of them work, <a href="https://codesandbox.io/s/childrens-pattern-example-with-render-func-and-use-callback-solution-qnmemy?file=/src/App.tsx">see this codesandbox</a>.</p>
<p>That is all for today, hope you enjoyed those little mysteries and will have full control over who renders what next time you write components ‚úåüèº</p>]]></content:encoded>
      <enclosure
        url="https://www.developerway.com//assets/react-elements-children-parents/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title><![CDATA[How to useMemo and useCallback: you can remove most of them]]></title>
      <link>https://www.developerway.com/posts/how-to-use-memo-use-callback</link>
      <guid>how-to-use-memo-use-callback</guid>
      <pubDate>Mon, 13 Jun 2022 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[What is the purpose of useMemo and useCallback hooks, mistakes and best practices in using them, and why removing most of them might be a good idea.]]></description>
      <content:encoded><![CDATA[<p>If you‚Äôre not completely new to React, you‚Äôre probably already at least familiar with <a href="https://reactjs.org/docs/hooks-reference.html#usememo">useMemo</a> and <a href="https://reactjs.org/docs/hooks-reference.html#usecallback">useCallback</a> hooks. And if you work on a medium to large-scale application, chances are you can describe some parts of your app as an ‚Äúincomprehensible chain of <code>useMemo</code> and <code>useCallback</code>s that is impossible to read and debug&quot;. Those hooks somehow have the ability to just spread around the code uncontrollably, until they just completely take over and you find yourself writing them just because they are everywhere and everyone around you is writing them.</p>
<p>And do you know the sad part? All of this is completely unnecessary. You can probably remove 90% of all <code>useMemo</code> and <code>useCallbacks</code> in your app right now, and the app will be fine and might even become slightly faster. Don‚Äôt get me wrong, I‚Äôm not saying that <code>useMemo</code> or <code>useCallback</code> are useless. Just that their use is limited to a few very specific and concrete cases. And most of the time we‚Äôre wrapping things in them unnecessary.</p>
<p>So this is what I want to talk about today: what kind of mistakes developers make with <code>useMemo</code> and <code>useCallback</code>, what is their actual purpose, and how to use them properly.</p>
<p>There are two major sources of the poisonous spread of those hooks in the app:</p>
<ul>
<li>memoizing props to prevent re-renders</li>
<li>memoizing values to avoid expensive calculations on every re-render</li>
</ul>
<p>We‚Äôll take a look at them later in the article, but first: what exactly is the purpose of <code>useMemo</code> and <code>useCallback</code>?</p>
<h2>Why do we need useMemo and useCallback</h2>
<p>The answer is simple - memoization <strong>between re-renders</strong>. If a value or a function is wrapped in one of those hooks, react will cache it during the initial render, and return the reference to that saved value during consecutive renders. Without it, non-primitive values like arrays, objects, or functions, will be re-created from scratch on every re-render. memoization is useful when those values are compared. It‚Äôs just your normal javascript:</p>
<pre><code class="language-js">const a = { &quot;test&quot;: 1 };
const b = { &quot;test&quot;: 1&#x27;};

console.log(a === b); // will be false

const c = a; // &quot;c&quot; is just a reference to &quot;a&quot;

console.log(a === c); // will be true
</code></pre>
<p>Or, if closer to our typical React use case:</p>
<pre><code class="language-tsx">const Component = () =&gt; {
  const a = { test: 1 };

  useEffect(() =&gt; {
    // &quot;a&quot; will be compared between re-renders
  }, [a]);

  // the rest of the code
};
</code></pre>
<p><code>a</code> value is a dependency of <code>useEffect</code> hook. On every re-render of <code>Component</code> React will compare it with the previous value. <code>a</code> is an object defined within the <code>Component</code>, which means that on every re-render it will be re-created from scratch. Therefore a comparison of <code>a</code> ‚Äúbefore re-render‚Äù with <code>a</code> ‚Äúafter re-render‚Äù will return <code>false</code>, and <code>useEffect</code> will be triggered on every re-render.</p>
<p>To avoid it, we can wrap the <code>a</code> value in <code>useMemo</code> hook:</p>
<pre><code class="language-tsx">const Component = () =&gt; {
  // preserving &quot;a&quot; reference between re-renders
  const a = useMemo(() =&gt; ({ test: 1 }), []);

  useEffect(() =&gt; {
    // this will be triggered only when &quot;a&quot; value actually changes
  }, [a]);

  // the rest of the code
};
</code></pre>
<p>Now <code>useEffect</code> will be triggered only when the a value actually changes (i.e. never in this implementation).</p>
<p>Exactly the same story with <code>useCallback</code>, only it‚Äôs more useful for memoizing functions:</p>
<pre><code class="language-tsx">const Component = () =&gt; {
  // preserving onClick function between re-renders
  const fetch = useCallback(() =&gt; {
    console.log(&#x27;fetch some data here&#x27;);
  }, []);

  useEffect(() =&gt; {
    // this will be triggered only when &quot;fetch&quot; value actually changes
    fetch();
  }, [fetch]);

  // the rest of the code
};
</code></pre>
<p>The most important thing to remember here is that both <code>useMemo</code> and <code>useCallback</code> are useful only <strong>during the re-renders phase</strong>. During the initial render, they are not only useless but even harmful: they make React do some additional work. This means that your app will become <strong>slightly slower</strong> during the initial render. And if your app has hundreds and hundreds of them everywhere, this slowing down can even be measurable.</p>
<h2>Memoizing props to prevent re-renders</h2>
<p>Now that we know the purpose of those hooks, let&#x27;s take a look at their practical usage. And one of the most important ones and the most often used is to memoize props values to prevent re-renders. Make some noise if you‚Äôve seen the code below somewhere in your app:</p>
<ol>
<li>Had to wrap <code>onClick</code> in <code>useCallback</code> to prevent re-renders</li>
</ol>
<pre><code class="language-tsx">const Component = () =&gt; {
  const onClick = useCallback(() =&gt; {
    /* do something */
  }, []);
  return (
    &lt;&gt;
      &lt;button onClick={onClick}&gt;Click me&lt;/button&gt;
      ... // some other components
    &lt;/&gt;
  );
};
</code></pre>
<ol start="2">
<li>Had to wrap <code>onClick</code> in <code>useCallback</code> to prevent re-renders</li>
</ol>
<pre><code class="language-tsx">const Item = ({ item, onClick, value }) =&gt; &lt;button onClick={onClick}&gt;{item.name}&lt;/button&gt;;

const Component = ({ data }) =&gt; {
  const value = { a: someStateValue };

  const onClick = useCallback(() =&gt; {
    /* do something on click */
  }, []);

  return (
    &lt;&gt;
      {data.map((d) =&gt; (
        &lt;Item item={d} onClick={onClick} value={value} /&gt;
      ))}
    &lt;/&gt;
  );
};
</code></pre>
<ol start="3">
<li>Had to wrap <code>value</code> in <code>useMemo</code>, because it‚Äôs a dependency of a memoized <code>onClick</code>:</li>
</ol>
<pre><code class="language-tsx">const Item = ({ item, onClick }) =&gt; &lt;button onClick={onClick}&gt;{item.name}&lt;/button&gt;;

const Component = ({ data }) =&gt; {
  const value = useMemo(() =&gt; ({ a: someStateValue }), [someStateValue]);
  const onClick = useCallback(() =&gt; {
    console.log(value);
  }, [value]);

  return (
    &lt;&gt;
      {data.map((d) =&gt; (
        &lt;Item item={d} onClick={onClick} /&gt;
      ))}
    &lt;/&gt;
  );
};
</code></pre>
<p>Is this something that you‚Äôve done or seen other people around you do? Do you agree with the use case and how the hook solved it? If the answer to those questions is ‚Äúyes‚Äù, congratulations: <code>useMemo</code> and <code>useCallback</code> took you hostage and unnecessary control your life. In all of the examples, those hooks are useless, unnecessary complicate code, slow down initial render and prevent nothing.</p>
<p>To understand why, we need to remember one important thing about how React works: the reasons why a component can re-render itself.</p>
<h2>Why a component can re-render itself?</h2>
<p>‚ÄúComponent re-renders itself when state or prop value changes‚Äù is common knowledge. Even <a href="https://reactjs.org/docs/react-component.html#updating">React docs</a> phrase it like this. And I think this statement is exactly what leads to the false conclusion that ‚Äúif props don‚Äôt change (i.e. memoized), then it will prevent the component from re-render‚Äù.</p>
<p>Because there is another very important reason for a component to re-render: when its parent re-renders itself. Or, if we go from the opposite direction: when a component re-renders itself, it also re-renders all of its children. Take a look at this code for example:</p>
<pre><code class="language-tsx">const App = () =&gt; {
  const [state, setState] = useState(1);

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;button onClick={() =&gt; setState(state + 1)}&gt; click to re-render {state}&lt;/button&gt;
      &lt;br /&gt;
      &lt;Page /&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p><code>App</code> component has some state and some children, including <code>Page</code> component. What will happen when a button is clicked here? State will change, it will trigger App&#x27;s re-render, and that will trigger re-render of all of its children, including <code>Page</code> component. It doesn‚Äôt even have props!</p>
<p>Now, inside of this <code>Page</code> component, if we have some children as well:</p>
<pre><code class="language-tsx">const Page = () =&gt; &lt;Item /&gt;;
</code></pre>
<p>Completely empty, it doesn‚Äôt have neither state nor props. But its re-render will be triggered when <code>App</code> re-renders, and as a result, it will trigger the re-render of its <code>Item</code> child. <code>App</code> component state change triggers a chain of re-renders across the entire app. See the <a href="https://codesandbox.io/s/parent-children-re-renders-gihtcw?file=/src/App.tsx">full example in this codesandbox</a>.</p>
<p>The only way to interrupt this chain is to memoize some of the components in it. We can do it either with <code>useMemo</code> hook, or, even better, with <a href="https://reactjs.org/docs/react-api.html#reactmemo">React.memo</a> util. <em>Only</em> if the component is wrapped with it will React stop before re-rendering it and check, whether the props value changes.</p>
<p>Memoizing the component:</p>
<pre><code class="language-tsx">const Page = () =&gt; &lt;Item /&gt;;
const PageMemoized = React.memo(Page);
</code></pre>
<p>Using it in App with state change:</p>
<pre><code class="language-tsx">const App = () =&gt; {
  const [state, setState] = useState(1);

  return (
    ... // same code as before
      &lt;PageMemoized /&gt;
  );
};
</code></pre>
<p>In this, and <strong>only</strong> this scenario it‚Äôs important whether props are memoized or not.</p>
<p>To illustrate, let&#x27;s assume that <code>Page</code> component has <code>onClick</code> prop that accepts a function. What will happen if I pass it to <code>Page</code> without memoizing it first?</p>
<pre><code class="language-tsx">const App = () =&gt; {
  const [state, setState] = useState(1);
  const onClick = () =&gt; {
    console.log(&#x27;Do something on click&#x27;);
  };
  return (
    // page will re-render regardless of whether onClick is memoized or not
    &lt;Page onClick={onClick} /&gt;
  );
};
</code></pre>
<p><code>App</code> will re-render, React will find <code>Page</code> in its children, and will re-render it. Whether <code>onClick</code> is wrapped in useCallback or not is irrelevant.</p>
<p>And if I memoize <code>Page</code>?</p>
<pre><code class="language-tsx">const PageMemoized = React.memo(Page);

const App = () =&gt; {
  const [state, setState] = useState(1);
  const onClick = () =&gt; {
    console.log(&#x27;Do something on click&#x27;);
  };
  return (
    // PageMemoized WILL re-render because onClick is not memoized
    &lt;PageMemoized onClick={onClick} /&gt;
  );
};
</code></pre>
<p><code>App</code> will re-render, React will find <code>PageMemoized</code> in its children, realise that it‚Äôs wrapped in <code>React.memo</code>, stop the chain of re-renders, and check first whether props on this component change. In this case, since <code>onClick</code> is a not memoized function, the result of props comparison will fail, and <code>PageMemoized</code> will re-render itself. Finally, some use for <code>useCallback</code>:</p>
<pre><code class="language-tsx">const PageMemoized = React.memo(Page);

const App = () =&gt; {
  const [state, setState] = useState(1);
  const onClick = useCallback(() =&gt; {
    console.log(&#x27;Do something on click&#x27;);
  }, []);

  return (
    // PageMemoized will NOT re-render because onClick is memoized
    &lt;PageMemoized onClick={onClick} /&gt;
  );
};
</code></pre>
<p>Now, when React stops on <code>PageMemoized</code> to check its props, <code>onClick</code> will stay the same, and <code>PageMemoized</code> will not be re-rendered.</p>
<p>What will happen if I add another non-memoized value to <code>PageMemoized</code>? Exactly the same scenario:</p>
<pre><code class="language-tsx">const PageMemoized = React.memo(Page);

const App = () =&gt; {
  const [state, setState] = useState(1);
  const onClick = useCallback(() =&gt; {
    console.log(&#x27;Do something on click&#x27;);
  }, []);

  return (
    // page WILL re-render because value is not memoized
    &lt;PageMemoized onClick={onClick} value={[1, 2, 3]} /&gt;
  );
};
</code></pre>
<p>React stops on <code>PageMemoized</code> to check its props, <code>onClick</code> will stay the same, but <code>value</code> will change, and <code>PageMemoized</code> will re-render itself. See the <a href="https://codesandbox.io/s/everything-memoized-8oltqg?file=/src/App.tsx">full example</a> here, try to remove memoization to see how everything starts re-rendering again.</p>
<p>Considering the above, there is only one scenario, when memoizing props on a component makes sense: <strong>when every single prop and the component itself are memoized</strong>. Everything else is just a waste of memory and unnecessarily complicates your code.</p>
<p>Feel free to remove all <code>useMemo</code> and <code>useCallbacks</code> from the code if:</p>
<ul>
<li>they passed as attributes, directly or through a chain of dependencies, to DOM elements</li>
<li>they passed as props, directly or through a chain of dependencies, to a component that is not memoized</li>
<li>they passed as props, directly or through a chain of dependencies, to a component with at least one prop not memoized</li>
</ul>
<p><strong>Why remove, not just fix memoization?</strong> Well, if you had performance problems because of re-renders in that area, you would‚Äôve noticed and fixed it already, isn‚Äôt it? üòâ And since there is no performance problem, there is no need to fix it. Removing useless <code>useMemo</code> and <code>useCallback</code> will simplify the code and speed up initial render a bit, without negatively impacting existing re-renders performance.</p>
<h2>Avoiding expensive calculations on every render</h2>
<p>The primary goal of useMemo, according to <a href="https://reactjs.org/docs/hooks-reference.html#usememo">React docs</a>, is to avoid expensive calculations on every render. No hints though of what constitutes the ‚Äúexpensive‚Äù calculation. As a result, developers sometimes wrap in <code>useMemo</code> pretty much every calculation in the render function. Create a new date? Filter, map or sort an array? Create an object? <code>useMemo</code> for all!</p>
<p>Okay, let‚Äôs take a look at some numbers. Imagine we have an array of countries (~250 of them), and we want to render them on the screen and allow users to sort them.</p>
<pre><code class="language-tsx">const List = ({ countries }) =&gt; {
  // sorting list of countries here
  const sortedCountries = orderBy(countries, &#x27;name&#x27;, sort);

  return (
    &lt;&gt;
      {sortedCountries.map((country) =&gt; (
        &lt;Item country={country} key={country.id} /&gt;
      ))}
    &lt;/&gt;
  );
};
</code></pre>
<p>The question is: is sorting an array of 250 elements an expensive operation? Feels like it, isn‚Äôt it? We probably should wrap it in <code>useMemo</code> to avoid re-calculating it on every re-render, right? Well, easy to measure:</p>
<pre><code class="language-tsx">const List = ({ countries }) =&gt; {
  const before = performance.now();

  const sortedCountries = orderBy(countries, &#x27;name&#x27;, sort);

  // this is the number we&#x27;re after
  const after = performance.now() - before;

  return (
    // same
  )
};
</code></pre>
<p>The end result? Without memoization, with 6x CPU slowdown, sorting of this array with ~250 items takes <strong>less than 2 milliseconds</strong>. To compare, rendering this list - just native buttons with text - takes more than 20 milliseconds. 10 times more! <a href="https://codesandbox.io/s/measure-without-memo-tnhggk?file=/src/page.tsx">See the codesandbox.</a></p>
<p>And in real life, the array likely will be much smaller, and whatever is rendered much more complicated, and therefore slower. So the difference in performance will be even bigger than 10 times.</p>
<p>Instead of memoizing the array operation, we should memoize the actual most expensive calculation here - re-rendering and updating components. Something like this:</p>
<pre><code class="language-tsx">const List = ({ countries }) =&gt; {
  const content = useMemo(() =&gt; {
    const sortedCountries = orderBy(countries, &#x27;name&#x27;, sort);

    return sortedCountries.map((country) =&gt; &lt;Item country={country} key={country.id} /&gt;);
  }, [countries, sort]);

  return content;
};
</code></pre>
<p>That <code>useMemo</code> drops unnecessary re-renders time of the entire component from ~20ms to less than 2ms.</p>
<p>Considering the above, this is the rule about memoizing ‚Äúexpensive‚Äù operations that I want to introduce: unless you actually calculating factorials of big numbers, remove <code>useMemo</code> hook on all pure javascript operations. Re-rendering children will always be your bottleneck. Use useMemo only to memoize heavy parts of the render tree.</p>
<p><strong>Why remove though?</strong> Wouldn‚Äôt it be better to just memoize everything? Wouldn‚Äôt it be a compound effect that degrades performance if we just remove them all? One millisecond here, 2 there, and soon our app is not as fast as it could be‚Ä¶</p>
<p>Fair point. And that thinking would be 100% valid, if it wasn‚Äôt for one caveat: memoization doesn‚Äôt come for free. If we‚Äôre using <code>useMemo</code>, during the initial render React needs to cache the result value - that takes time. Yes, it will be tiny, in our app above memoizing those sorted countries takes less than a millisecond. But! This will be the true compound effect. The initial render happens when your app first appears on the screen. <strong>Every</strong> component that is supposed to show up goes through it. In a big app with hundreds of components, even if a third of those memoize something, that could result in 10, 20, at worst maybe even 100 milliseconds added to the initial render.</p>
<p>Re-render, on the other hand, only happens after something in one part of the app changes. And in a well-architectured app only this particular small part going to be re-rendered, not the entire app. How many of the ‚Äúcalculations‚Äù similar to the case above we‚Äôll have in that changed part? 2-3? Let‚Äôs say 5. Each memoization will save us less than 2 milliseconds, i.e. overall less than 10 milliseconds. 10 milliseconds that may or may not happen (depends on whether the event that triggers it happens), that are not visible with the naked eye, and that will be lost in children‚Äôs re-renders that will take 10 times that much anyway. At the cost of slowing down the initial render that will always happen üòî.</p>
<h2>Enough for today</h2>
<p>That was quite a lot of information to process, hope you found it useful and are now eager to review your apps and get rid of all the useless <code>useMemo</code> and <code>useCallback</code> that accidentally took over your code. Quick summary to solidify the knowledge before you go:</p>
<ul>
<li><code>useCallback</code> and <code>useMemo</code> are hooks that are useful only for consecutive renders (i.e. re-renders), for the initial render they are actually harmful</li>
<li><code>useCallback</code> and <code>useMemo</code> for props don‚Äôt prevent re-renders by themselves. Only when every single prop and the component itself are memoized, then re-renders can be prevented. One single mistake and it all falls apart and makes those hooks useless. Remove them if you find them.</li>
<li>Remove <code>useMemo</code> around ‚Äúnative‚Äù javascript operations - compare to components updates those are invisible and just take additional memory and valuable time during the initial render</li>
</ul>
<p>One small thing: considering how complicated and fragile all of this is, <code>useMemo</code> and <code>useCallback</code> for performance optimisations really should be your last resort. Try other performance optimisation techniques first. Take a look at those articles that describe some of those:</p>
<ul>
<li><a href="/posts/how-to-write-performant-react-code">How to write performant React code: rules, patterns, do&#x27;s and don&#x27;ts</a></li>
<li><a href="/posts/why-custom-react-hooks-could-destroy-your-app-performance">Why custom react hooks could destroy your app performance</a></li>
<li><a href="/posts/how-to-write-performant-react-apps-with-context">How to write performant React apps with Context</a></li>
<li><a href="/posts/react-key-attribute">React key attribute: best practices for performant lists</a></li>
<li><a href="/posts/components-composition-how-to-get-it-right">React components composition: how to get it right</a>.</li>
</ul>
<p>And of course, goes without saying: measure first!</p>
<p>May this day be your last day in <code>useMemo</code> and <code>useCallback</code> hell! ‚úåüèº</p>]]></content:encoded>
      <enclosure url="https://www.developerway.com//assets/how-to-use-memo-use-callback/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title>
        <![CDATA[React project structure for scale: decomposition, layers and hierarchy]]></title>
      <link>https://www.developerway.com/posts/react-project-structure</link>
      <guid>react-project-structure</guid>
      <pubDate>Mon, 23 May 2022 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[How to organize React projects in a way that is scalable, structured, modular, consistent and logical.]]></description>
      <content:encoded><![CDATA[<p>How to structure React apps ‚Äúthe right way‚Äù seems to be the hot topic <s>recently</s> for as long as React existed. React‚Äôs official opinion on it is that it <a href="https://reactjs.org/docs/faq-structure.html#is-there-a-recommended-way-to-structure-react-projects">‚Äúdoesn‚Äôt have opinions‚Äù</a>. This is great, it gives us total freedom to do whatever we want. And also it‚Äôs bad. It leads to so many fundamentally different and very strong opinions about the proper React app structure, that even the most experienced developers sometimes feel lost, overwhelmed and the need to cry in a dark corner because of it.</p>
<p>I, of course, also have a strong opinion on the topic üòà. And it‚Äôs not even going to be ‚Äúit depends‚Äù this time üòÖ (almost). What I want to share today is the system, that I‚Äôve seen working pretty well in:</p>
<ul>
<li>an environment with dozens of loosely connected teams in the same repository working on the same product</li>
<li>in a fast-paced environment of a small startup with just a few engineers</li>
<li>or even for one-person projects (yeah, I use it all the time for my personal stuff)</li>
</ul>
<p>Just remember, same as the <a href="https://youtu.be/k9ojK9Q_ARE?t=42">Pirate‚Äôs Code</a>, all of this is more what you&#x27;d call &quot;guidelines&quot; than actual rules.</p>
<h2>What do we need from the project structure convention</h2>
<p>I don‚Äôt want to go into details on why we need conventions like this in the first place: if you landed on this article you probably already decided that you need it. What I want to talk about a little bit though, before jumping into solutions, is what makes a project structure convention great.</p>
<h3>Replicability</h3>
<p>Code convention should be understandable and easy enough to reproduce by any member of the team, including a recently joined intern with minimal React experience. If the way of working in your repo requires a PhD, a few months of training and deeply philosophical debates over every second PR‚Ä¶ Well, it‚Äôs probably going to be a really beautiful system, but it won‚Äôt exist anywhere other than on paper.</p>
<h3>Inferrability</h3>
<p>You can write a book and shoot a few movies on ‚ÄúThe way of working in our repo‚Äù. You can probably even convince everyone on the team to read and watch it (although you probably won&#x27;t). The fact remains: most people are not going to memorise every word of it, if at all. For the convention to actually work, it should be so obvious and intuitive, so that people in the team ideally are able to reverse-engineer it by just reading the code. In the perfect world, same as with code comments, you wouldn‚Äôt even need to write it down anywhere - the code and structure itself would be your documentation.</p>
<h3>Independence</h3>
<p>One of the most important requirements from coding structure guidelines for multiple people, and especially multiple teams, is to solidify a way for developers to operate independently. The last thing that you want is multiple developers working on the same file, or teams constantly invading each other&#x27;s areas of responsibility.</p>
<p>Therefore, our coding structure guidelines should provide such a structure, where teams are able to peacefully co-exist within the same repository.</p>
<h3>Optimised for refactoring</h3>
<p>Last one, but in the modern frontend world, it‚Äôs the most important one. Frontend today is incredibly fluid. Patterns, frameworks, and best practices are changing constantly. On top of that, we are expected to deliver features fast nowadays. No, FAST. And then re-write it completely after a month. And then maybe re-write it again.</p>
<p>So it becomes very important for our coding convention to not force us to ‚Äúglue‚Äù the code in some permanent place with no way to move it around. It should organize things in such a way that refactoring is something that is performed casually on a daily basis. The worst thing a convention can do is to make refactoring so hard and time-consuming that everyone is terrified of it. Instead, it should be as simple as breathing.</p>
<center>‚Ä¶</center>
<p>Now, that we have our general requirements for the project structure convention, time to go into details. Let‚Äôs start with the big picture, and then drill down into the details.</p>
<h2>Organising the project itself: decomposition</h2>
<p>The first and the most important part of organizing a large project that is aligned with the principles we defined above is ‚Äúdecomposition‚Äù: instead of thinking of it as a monolithic project, it can be thought of as a composition of more or less independent features. Good old ‚Äúmonolith‚Äù vs ‚Äúmicroservices‚Äù discussion, only within one React application. With this approach every feature is essentially a ‚Äúnanoservice‚Äù in a way, that is isolated from the rest of the features and communicates with them through an external ‚ÄúAPI‚Äù (usually just React props).</p>
<p><img src="https://www.developerway.com/assets/react-project-structure/app-to-features.png" alt=""/></p>
<p>Even just following this mindset, compared to the more traditional ‚ÄúReact project‚Äù approach, will give you pretty much everything from our list above: teams/people will be able to work independently on features in parallel if they implement them as a bunch of ‚Äúblack boxes‚Äù plugged into each other. If the set-up is right, it should be pretty obvious for anyone as well, just would require a bit of practice to adjust to the mind shift. If you need to remove a feature you can just ‚Äúun-plug‚Äù it, or replace it with another feature. Or if you need to refactor the internals of a feature, you can do it. And as long as the public ‚ÄúAPI‚Äù of it stays functional no one outside will even notice it.</p>
<p>I‚Äôm describing a React component, isn‚Äôt it? üòÖ Well, the concept is the same, and this makes React perfect for this mindset. I would define a ‚Äúfeature‚Äù, to distinguish it from a ‚Äúcomponent‚Äù, as ‚Äúa bunch of components and other elements tied together in a complete from an end-user perspective functionality‚Äù.</p>
<p>Now, how to organise this for a single project? Especially considering, that compare to microservices, it should come with much less plumbing: in a project with hundreds of features, extracting them all into actual microservices will be close to impossible. What we can do instead, is to use <a href="https://monorepo.tools/">multi-package monorepo</a> architecture: it‚Äôs perfect for organizing and isolating independent features as packages. A package is a concept that should be already familiar to anyone who installed anything from npm. And a monorepo - is just a repo, where you have source code of multiple packages living together in harmony, sharing tools, scripts, dependencies and sometimes each other.</p>
<p>So the concept is simple: React project ‚Üí split it into independent features ‚Üí place those features into packages.</p>
<p><img src="https://www.developerway.com/assets/react-project-structure/app-to-features-to-packages.png" alt=""/></p>
<p>If you never worked with locally set up monorepo and now, after I mentioned ‚Äúpackage‚Äù and ‚Äúnpm‚Äù, feel uneasy about the idea of publishing your private project: don‚Äôt be. Neither publishing nor open-source are a requirement for a monorepo to exist and for developers to get the benefits out of it. From the code perspective, a package is just a folder, that has <code>package.json</code> file with some properties. That folder is then linked via Node‚Äôs <a href="https://en.wikipedia.org/wiki/Symbolic_link">symlinks</a> to <code>node_modules</code> folder, where &quot;traditional&quot; packages are installed. This linking is performed by tools like <a href="https://classic.yarnpkg.com/lang/en/docs/workspaces/">Yarn</a> or <a href="https://docs.npmjs.com/cli/v8/using-npm/workspaces">Npm</a> themselves: it‚Äôs called ‚Äúworkspaces‚Äù, and both of them support it. And they make packages accessible in your local code as any other package downloaded from npm.</p>
<p>It would look like this:</p>
<pre><code class="language-tsx">/packages
  /my-feature
    /some-folders-in-feature
    index.ts
    package.json // this is what defines the my-feature package
  /another-feature
    /some-folders-in-feature
    index.ts
    package.json // this is what defines the another-feature package
</code></pre>
<p>and in package.json I would have those two important fields:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;@project/my-feature&quot;,
  &quot;main&quot;: &quot;index.ts&quot;
}
</code></pre>
<p>Where the ‚Äúname‚Äù field is, obviously, the name of the package - basically the alias to this folder, through which it will be accessible to the code in the repo. And ‚Äúmain‚Äù is the main entry point to the package, i.e. which file is going to be imported when I write something like</p>
<pre><code class="language-tsx">import { Something } from &#x27;@project/my-feature&#x27;;
</code></pre>
<p>There are quite a few public repositories of well-known projects that use the multi-packages monorepo approach: <a href="https://github.com/babel/babel/tree/master/packages">Babel</a>, <a href="https://github.com/facebook/react/tree/main/packages">React</a>, <a href="https://github.com/facebook/jest/tree/main/packages">Jest</a> to name a few.</p>
<h3>Why packages rather than just folders</h3>
<p>At first sight, the packages&#x27; approach looks like ‚Äújust split your features into folders, what‚Äôs the big deal‚Äù and doesn‚Äôt seem that groundbreaking. There are, however, a few interesting things packages can give us, that simple folders can‚Äôt.</p>
<p><strong>Aliasing</strong>. With packages, you can refer to your feature by its name, not by its location. Compare this:</p>
<pre><code class="language-tsx">import { Button } from &#x27;@project/button&#x27;;
</code></pre>
<p>with this more ‚Äútraditional‚Äù approach:</p>
<pre><code class="language-tsx">import { Button } from &#x27;../../components/button&#x27;;
</code></pre>
<p>In the first import, it‚Äôs obvious - I‚Äôm using a generic ‚Äúbutton‚Äù component of my project, my version of design systems.</p>
<p>In the second one, it‚Äôs not that clear - what is this button? Is it the generic ‚Äúdesign systems‚Äù button? Or maybe part of this feature? Or a feature ‚Äúabove‚Äù? Can I even use it here, maybe it was written for some very specific use case that is not going to work in my new feature?</p>
<p>It gets even worst if you have multiple ‚Äúutils‚Äù or ‚Äúcommon‚Äù folders in your repo. My worst code-nightmare looks like this:</p>
<pre><code class="language-tsx">import { bla } from &#x27;../../../common&#x27;;
import { blabla } from &#x27;../../common&#x27;;
import { blablabla } from &#x27;../common&#x27;;
</code></pre>
<p>With packages it could look something like this instead:</p>
<pre><code class="language-tsx">import { bla } from &#x27;@project/button/common&#x27;;
import { blabla } from &#x27;@project/something/common&#x27;;
import { blablabla } from &#x27;@project/my-feature/common&#x27;;
</code></pre>
<p>Instantly obvious what comes from where, and what belongs where. And chances are, the ‚Äúmy-feature‚Äù ‚Äúcommon‚Äù code was written just for the feature‚Äôs internal use, was never meant to be used outside of the feature, and re-using it somewhere else is a bad idea. With packages, you‚Äôll see it right away.</p>
<p><strong><em>Separation of concerns</em></strong>. Considering that we all are used to the packages from npm and what they represent, it becomes much easier to think about your feature as an isolated module with its own public API when it is written as a ‚Äúpackage‚Äù right away.</p>
<p>Take a look at this:</p>
<pre><code class="language-tsx">import { dateTimeConverter } from &#x27;../../../../button/something/common/date-time-converter&#x27;;
</code></pre>
<p>vs this:</p>
<pre><code class="language-tsx">import { dateTimeConverter } from &#x27;@project/button&#x27;;
</code></pre>
<p>The first one will likely be lost in all the imports around it and slip unnoticed, turning your code into <a href="https://blog.codinghorror.com/the-big-ball-of-mud-and-other-architectural-disasters/">The Big Ball of Mud</a>. The second will instantly and naturally raise a few eyebrows: a date-time converter? From a button? Really? Which will naturally force more clear boundaries between different features/packages.</p>
<p><strong>Built-in support</strong>. You don‚Äôt need to invent anything, most of the modern tools, like IDE, typescript, linting or bundlers support packages out-of-the-box.</p>
<p><strong>Refactoring is a breeze</strong>. With features separated into packages refactoring becomes enjoyable. Want to refactor the content of your package? Go ahead, you can re-write it fully, as long as you keep the entry‚Äôs API the same the rest of the repo won‚Äôt even notice it. Want to move your package to another location? It‚Äôs just drag-and-drop of a folder if you don‚Äôt rename it, the rest of the repo is not affected. Want to re-name the package? Just search &amp; replace a string in the project, nothing more.</p>
<p><strong>Explicit entry points</strong>. You can be very specific about what exactly from a package is available to the outside consumers if you want to truly embrace the ‚Äúonly public API for the consumers‚Äù mindset. For example, you can restrict all the ‚Äúdeep‚Äù imports, make things like <code>@project/button/some/deep/path</code> impossible and force everyone to only use explicitly defined public API in index.ts file. Take a look at <a href="https://nodejs.org/api/packages.html#package-entry-points">Package entry points</a> and <a href="https://webpack.js.org/guides/package-exports/">Package exports</a> docs for examples of how it works.</p>
<h3>How to split code into packages</h3>
<p>The biggest thing that people struggle with in multi-package architecture, is what is the right time to extract code into a package? Should every small feature be one? Or maybe packages are only for big things like a whole page or even an app?</p>
<p>In my experience, there is a balance here. You don‚Äôt want to extract every little thing into a package: you‚Äôll end up with just a flat list of hundreds of one-file only tiny packages with no structure, which kinda defeats the purpose of introducing them in the first place. At the same time, you wouldn‚Äôt want your package to become too big: you‚Äôll hit all the problems that we‚Äôre trying to solve here, only within that package.</p>
<p>Here are some boundaries that I usually use:</p>
<ul>
<li>‚Äúdesign system‚Äù type of things like buttons, modal dialogs, layouts, tooltips, etc, all should should be packages</li>
<li>features in some ‚Äúnatural‚Äù UI boundaries are good candidates for a package - i.e. something that lives in a modal dialog, in a drawer, in a slide-in panel, etc</li>
<li>‚Äúshareable‚Äù features - those that can be used in multiple places</li>
<li>something that you can describe as an isolated ‚Äúfeature‚Äù with clear boundaries, logical and ideally visible in the UI</li>
</ul>
<p>Also, same as in the previous article about <a href="/posts/components-composition-how-to-get-it-right">how to split code into components</a>, it‚Äôs very important for a package to be responsible only for one conceptual thing. A package, that exports a <code>Button</code>, <code>CreateIssueDialog</code> and <code>DateTimeConverter</code> does too many things at once and needs to be split up.</p>
<h3>How to organize packages</h3>
<p>Although it is possible to just create a flat list of all the packages, and for certain types of projects it would work, for large UI-heavy products it likely won‚Äôt be enough. Seeing something like ‚Äútooltip‚Äù and ‚Äúsettings page‚Äù packages sitting together makes me cringe. Or worse - if you have ‚Äúbackend‚Äù and ‚Äúfrontend‚Äù packages together. This is not only messy but also dangerous: the last thing that you want is to accidentally pull some ‚Äúbackend‚Äù code into your frontend bundle.</p>
<p>The actual repo structure would heavily depend on what exactly is the product you‚Äôre implementing (or even how many products are there), do you have backend or frontend only, and likely will change and evolve significantly over time. Fortunately, this is the huge advantage of packages: the actual structure is completely independent of code, you can drag-and-drop and re-structure them once a week without any consequences if there is a need.</p>
<p>Considering that the cost of ‚Äúmistake‚Äù in the structure is quite low, there is no need to over-think it, at least at the beginning. If your project is frontend-only, you can even start with a flat list:</p>
<pre><code>/packages
  /button
  ...
  /footer
  /settings
  ...
</code></pre>
<p>and evolve it over time into something like this:</p>
<pre><code>/packages
  /core
    /button
    /modal
    /tooltip
    ...
  /product-one
    /footer
    /settings
    ...
  /product-two
    ...
</code></pre>
<p>Or, if you have a backend, it could be something like this:</p>
<pre><code>/packages
  /frontend
    ... // the same as above
  /backend
    ... // some backend-specific packages
  /common
    ... // some packages that are shared between frontend and backend
</code></pre>
<p>Where in ‚Äúcommon‚Äù you‚Äôd put some code that is shared between frontend and backend. Typically it will be some configs, constants, lodash-like utils, shared types.</p>
<h2>How to structure a package itself</h2>
<p>To summarise the big section above: ‚Äúuse monorepo, extract features into packages‚Äù. üôÇ Now to the next part - how to organize the package itself. Three things are important here for me: naming convention, separating the package into distinct layers, and strict hierarchy.</p>
<h3>Naming convention</h3>
<p>Everyone love naming things and debating over how bad others are at naming things, isn‚Äôt it? To reduce time wasted on endless GitHub comments threads and calm down poor geeks with code-related OCD like me, it‚Äôs better to just agree on a naming convention once for everyone.</p>
<p>Which one to use doesn‚Äôt really matter in my opinion, as long as it&#x27;s followed throughout the project consistently. If you have <code>ReactFeatureHere.ts</code> and <code>react-feature-here.ts</code> in the same repo, a kitten cries somewhere üòø. I usually use this one:</p>
<pre><code>/my-feature-name
  /assets     // if I have some images, then they go into their own folder
    logo.svg
  index.tsx   // main feature code
  test.tsx    // tests for the feature if needed
  stories.tsx // stories for storybooks if I use them
  styles.(tsx|scss) // I like to separate styles from component&#x27;s logic
  types.ts    // if types are shared between different files within the feature
  utils.ts    // very simple utils that are used *only* in this feature
  hooks.tsx   // small hooks that I use *only* in this feature
</code></pre>
<p>If a feature has a few smaller components that are imported directly into <code>index.tsx</code>, they would look like this:</p>
<pre><code>/my-feature-name
  ... // the same as before
  header.tsx
  header.test.tsx
  header.styles.tsx
  ... // etc
</code></pre>
<p>or, more likely, I would extract them into folders right away and they would look like this:</p>
<pre><code>/my-feature-name
  ... // index the same as before
  /header
    index.tsx
    ... // etc, exactly the same naming here
  /footer
    index.tsx
    ... // etc, exactly the same naming here
</code></pre>
<p>Folders approach is much more optimized for copy-paste driven development üòä: when creating a new feature by copy-pasting structure from the feature nearby, all you‚Äôd need to do is to rename only one folder. All the files will be named exactly the same. Plus it‚Äôs easier to create a mental model of the package, to refactor and move code around (on that in the next section).</p>
<h3>Layers within a package</h3>
<p>A typical package with a complicated feature would have a few distinct ‚Äúlayers‚Äù: at least ‚ÄúUI‚Äù layer and ‚ÄúData‚Äù layer. While it‚Äôs probably possible to mix everything together, I would still recommend against that: rendering buttons and fetching data from the backend are vastly different concerns. Separating them will give the package more structure and predictability.</p>
<p>And in order for the project to stay relatively healthy architecture- and code-wise, the crucial thing is to be able to clearly identify those layers that are important for your app, map the relationship between them, and organise all of this in a way that is aligned with whatever tools and frameworks are used.</p>
<p>If I was implementing a React project from scratch today, with Graphql for data manipulations and pure React state for state management (i.e. no Redux or any other library), I would have the following layers:</p>
<ul>
<li><strong>‚Äúdata‚Äù</strong> layer - queries, mutation and other things that are responsible for connecting to the external data sources and transforming it. Used only by UI layer, doesn‚Äôt depend on any other layers.</li>
<li><strong>‚Äúshared‚Äù</strong> layer - various utils, functions, hooks, mini-components, types and constants that are used across the entire package by all other layers. Doesn‚Äôt depend on any other layers.</li>
<li><strong>‚Äúui‚Äù</strong> layer - the actual feature implementation. Depends on ‚Äúdata‚Äù and ‚Äúshared‚Äù layers, no-one depends on it</li>
</ul>
<p>That‚Äôs it!</p>
<p><img src="https://www.developerway.com/assets/react-project-structure/simple-package-diagram.png" alt=""/></p>
<p>If I was using some external state management library, I would probably add ‚Äústate‚Äù layer as well. That one would likely be a bridge between ‚Äúdata‚Äù and ‚Äúui‚Äù, and therefore would use ‚Äúshared‚Äù and ‚Äúdata‚Äù layers and ‚ÄúUI‚Äù would use ‚Äústate‚Äù instead of ‚Äúdata‚Äù.</p>
<p><img src="https://www.developerway.com/assets/react-project-structure/simple-package-diagram-with-state.png" alt=""/></p>
<p>And from the implementation details point of view, all layers are top-level folders in a package:</p>
<pre><code>/my-feature-package
  /shared
  /ui
  /data
  index.ts
  package.json
</code></pre>
<p>With every ‚Äúlayer‚Äù using the same naming convention described above. So your ‚Äúdata‚Äù layer would look something like this:</p>
<pre><code>/data
  index.ts
  get-some-data.ts
  get-some-data.test.ts
  update-some-data.ts
  update-some-data.test.ts
</code></pre>
<p>For more complicated packages, I might split those layers apart, while preserving their purpose and the characteristics. ‚ÄúData‚Äù layer could be split into ‚Äúqueries‚Äù (‚Äúgetters‚Äù) and ‚Äúmutations‚Äù (‚Äúsetters‚Äù) for example, and those can either live still in the ‚Äúdata‚Äù folder or move up:</p>
<pre><code>/my-feature-package
  /shared
  /ui
  /queries
  /mutations
  index.ts
  package.json
</code></pre>
<p><img src="https://www.developerway.com/assets/react-project-structure/package-split-data.png" alt=""/></p>
<p>Or you could extract a few sub-layers from the ‚Äúshared‚Äù layer, like ‚Äútypes‚Äù and ‚Äúshared UI components‚Äù (which would instantly turn this sub-layer into ‚ÄúUI‚Äù type btw, since no one other than ‚ÄúUI‚Äù can use UI components).</p>
<pre><code>/my-feature-package
  /shared-ui
  /ui
  /queries
  /mutations
  /types
  index.ts
  package.json
</code></pre>
<p><img src="https://www.developerway.com/assets/react-project-structure/package-split-shared.png" alt=""/></p>
<p>As long as you are can clearly define what‚Äôs every ‚Äúsub-layer‚Äù purpose is, clear about which ‚Äúsub-layer‚Äù belongs to which ‚Äúlayer‚Äù and can visualise and explain it to everyone in the team - everything works!</p>
<h3>Strict hierarchy within layers</h3>
<p>The final piece of the puzzle, which makes this architecture predictable and maintainable, is a strict hierarchy within the layers. This is going to be especially visible in the UI layer since in React apps it usually is the most complicated one.</p>
<p>Let‚Äôs start, for example, scaffolding a simple page, with a header and a footer. We‚Äôd have ‚Äúindex.ts‚Äù file - the main file, where the page comes together, and ‚Äúheader.ts‚Äù and ‚Äúfooter.ts‚Äù components.</p>
<pre><code>/my-page
  index.ts
  header.ts
  footer.ts
</code></pre>
<p>Now, all of them will have their own components that I&#x27;d want to put in their own files. ‚ÄúHeader‚Äù, for example, will have ‚ÄúSearch bar‚Äù and ‚ÄúSend feedback‚Äù components. In the ‚Äútraditional‚Äù flat way to organize apps we‚Äôd put them next to each other, isn‚Äôt it? Would be something like this:</p>
<pre><code>/my-page
  index.ts
  header.ts
  footer.ts
  search-bar.ts
  send-feedback.ts
</code></pre>
<p>And then, if I want to add the same ‚Äúsend-feedback‚Äù button to the footer component, I‚Äôd again just import it to ‚Äúfooter.ts‚Äù from ‚Äúsend-feedback.ts‚Äù, right? After all, it‚Äôs nearby and seems natural.</p>
<p><img src="https://www.developerway.com/assets/react-project-structure/flat-list-components.png" alt=""/></p>
<p>Unfortunately, what just happened, is we violated the boundaries between our layers (‚ÄúUI‚Äù and ‚Äúshared‚Äù) without even noticing it. If I keed adding more and more components to this flat structure, and I probably will, real applications tend to be quite complicated, I‚Äôll likely violate them a few times more. This will turn this folder into its own tiny <a href="https://blog.codinghorror.com/the-big-ball-of-mud-and-other-architectural-disasters/">‚ÄúBall Of Mud‚Äù</a>, where it‚Äôs completely unpredictable which component depends on which. And as a result, untangling all of this and extracting something out of this folder, when the refactoring time comes, might turn into a very head-scratchy exercise.</p>
<p>Instead, we can structure this layer in a hierarchical way. The rules are:</p>
<ul>
<li>only main files (i.e. ‚Äúindex.ts‚Äù) in a folder can have sub-components (sub-modules) and can import them</li>
<li>you can import only from the ‚Äúchildren‚Äù, not from ‚Äúneighbours‚Äù</li>
<li>you can not skip a level and can only import from direct children</li>
</ul>
<p>Or, if you prefer visual, it‚Äôs just a tree:</p>
<p><img src="https://www.developerway.com/assets/react-project-structure/tree.png" alt=""/></p>
<p>And if you need to share some code between different levels of this hierarchy (like our send-feedback component), you‚Äôd instantly see that you‚Äôre violating the rules of hierarchy, since wherever you put it, you‚Äôd have to import it either from parents or from neighbours. So instead, it would be extracted into the ‚Äúshared‚Äù layer and imported from there.</p>
<p><img src="https://www.developerway.com/assets/react-project-structure/tree-with-shared.png" alt=""/></p>
<p>Would look like this:</p>
<pre><code>/my-page
  /shared
    send-feedback.ts
  /ui
    index.ts
    /header
      index.ts
      search-bar.ts
    /footer
      index.ts
</code></pre>
<p>That way the UI layer (or any layer where that rule applies) just turns into a tree structure, where every branch is independent of any other branch. Extracting anything from this package is now a breeze: all you need to do is to drag and drop a folder into a new place. And you know for sure, that not a single component in the UI tree will be affected by it except the one that actually uses it. The only thing that you might need to deal with additionally is the ‚Äúshared‚Äù layer.</p>
<p>The full app with data layer would then look like this:</p>
<p><img src="https://www.developerway.com/assets/react-project-structure/tree-with-shared-and-data.png" alt=""/></p>
<p>A few clearly defined layers, that are completely encapsulated and predictable.</p>
<pre><code>/my-page
  /shared
    send-feedback.ts
  /data
    get-something.ts
    send-something.ts
  /ui
    index.ts
    /header
      index.ts
      search-bar.ts
    /footer
      index.ts
</code></pre>
<h2>React recommends against nesting</h2>
<p>If you read React docs on recommended project structure, you‚Äôll see that React actually recommends <a href="https://reactjs.org/docs/faq-structure.html#avoid-too-much-nesting">against too much nesting</a>. The official recommendation is ‚Äúconsider limiting yourself to a maximum of three or four nested folders within a single project‚Äù. And this recommendation is very relevant for this approach as well: if your package becomes too nested, it‚Äôs a clear sign that you might need to think about splitting it into smaller packages. 3-4 levels of nesting, in my experience, is enough even for very complicated features.</p>
<p>The beauty of packages architecture though, is that you can organize your packages with as much nesting as you need without being bound by this restriction - you never refer to another package via its relative path, only by its name. A package by the name <code>@project/change-setting-dialog</code> that lives at the path <code>packages/change-settings-dialog</code> or is hidden inside <code>/packages/product/features/settings-page/change-setting-dialog</code>, will be referred to as <code>@project/change-setting-dialog</code> regardless of its physical location.</p>
<h2>Monorepo management tool</h2>
<p>It‚Äôs impossible to talk about multi-packages monorepo for your architecture without touching at least a little bit on monorepo management tools. The biggest problem is usually dependency management within it. Imagine, if some of your monorepo packages use an external dependency, <code>lodash</code> for example.</p>
<pre><code>/my-feature-one
  package.json // this one uses lodash@3.4.5
/my-other-feature
  package.json // this one uses lodash@3.4.5
</code></pre>
<p>Now lodash releases a new version, <code>lodash@4.0.0</code>, and you want to move your project to it. You would need to update it everywhere at the same time: the last thing that you want is for some of the packages remaining on the old version, while some using the new one. If you‚Äôre on <code>npm</code> or old <code>yarn</code>, that would be a disaster: they would install multiple copies (<a href="/posts/webpack-and-yarn-magic-against-duplicates-in-bundles">not two, multiple</a>) of <code>lodash</code> in your system, which will result in increasing install and build times, and your bundle sizes going through the roof. Not to mention the fun of developing a new feature when you‚Äôre using two different versions of the same library all over the project.</p>
<p>I‚Äôm not going to touch on what to use if your project is going to be published on <code>npm</code> and open-sourced: probably something like <a href="https://github.com/lerna/lerna">Lerna</a> would be enough, but that is a completely different topic.</p>
<p>If, however, your repo is <strong>private</strong>, things are getting more interesting. Because all that you actually need in order for this architecture to work is packages ‚Äúaliasing‚Äù, nothing more. I.e. just basic symlinking that both <a href="https://classic.yarnpkg.com/lang/en/docs/workspaces/">Yarn</a> and <a href="https://docs.npmjs.com/cli/v8/using-npm/workspaces">Npm</a> provide through the idea of workspaces. It looks like this. You have the ‚Äúroot‚Äù <code>package.json</code> file, where you declare where workspaces (i.e. your local packages):</p>
<pre><code class="language-json">{
  &quot;private&quot;: true,
  &quot;workspaces&quot;: [&quot;packages/**&quot;]
}
</code></pre>
<p>And then next time you run <code>yarn install</code> all packages from the folder packages will turn into ‚Äúproper‚Äù packages and will be available in your project via their name. That‚Äôs the whole monorepo setup!</p>
<p>As for dependencies. What will happen, if you have the same dependency in a few packages?</p>
<pre><code>/packages
  /my-feature-one
    package.json // this one uses lodash@3.4.5
  /my-other-feature
    package.json // this one uses lodash@3.4.5
</code></pre>
<p>When you run <code>yarn install</code> it will ‚Äúhoist‚Äù that package to the root <code>node_modules</code>:</p>
<pre><code>/node_modules
  lodash@3.4.5
/packages
  /my-feature-one
    package.json // this one uses lodash@3.4.5
  /my-other-feature
    package.json // this one uses lodash@3.4.5
</code></pre>
<p>This is <em>exactly</em> the same situation as if you just declare <code>lodash@3.4.5</code> in the root <code>package.json</code> only. What I‚Äôm saying is, and I will probably be buried alive by the purists of the internet for that, including myself two years ago: you don‚Äôt need to declare any of the dependencies in your local packages. Everything can just go to the root <code>package.json</code>. And your <code>package.json</code> files in local packages will be just very lightweight <code>json</code> files, that only specify ‚Äúname‚Äù and ‚Äúmain‚Äù fields.</p>
<p>Much easier set-up to manage, especially if you‚Äôre just starting.</p>
<h2>React project structure for scale: final overview</h2>
<p>Huh, that was a lot of text. And even that is just a short overview: so many more things can be said on the topic! Let‚Äôs recap what has already been said at least:</p>
<p><strong>Decomposition</strong> is the key to successfully scaling your react app. Think of your project not as a monolithic ‚Äúproject‚Äù, but as a combination of independent black-box like ‚Äúfeatures‚Äù with their own public API for the consumers to use. The same discussion as ‚Äúmonolith‚Äù vs ‚Äúmicroservices‚Äù really.</p>
<p><strong>Monorepo architecture</strong> is perfect for that. Extract your features into packages; organise your packages in the way that works best for your project.</p>
<p><strong>Layers</strong> within one package are important to give it some structure. You‚Äôll probably have at least ‚Äúdata‚Äù layer, ‚ÄúUI‚Äù layer and ‚Äúshared‚Äù layer. Can introduce more, depending on your needs, just need to have clear boundaries between them.</p>
<p><strong>Hierarchical structure</strong> of a package is cool. It makes refactoring easier, forces you to have clearer boundaries between layers, and forces you to split your package into smaller ones when it becomes too big.</p>
<p><strong>Dependency management</strong> in a monorepo is a complicated topic, but if your project is private you don‚Äôt need to actually worry about it. Just declare all your dependencies in the root package.json and keep all local packages free from them.</p>
<p>You can take a look at the implementation of this architecture in this example repo: <a href="https://github.com/developerway/example-react-project">https://github.com/developerway/example-react-project</a>. This is just a basic example to demonstrate the principles described in the article, so don‚Äôt be scared by tiny packages with just one index.ts: in a real app they will be much bigger.</p>
<p>That is all for today. Hope you‚Äôll be able to apply some of those principles (or even all of them!) to your apps and see improvements in your day-to-day development right away! ‚úåüèº</p>]]></content:encoded>
      <enclosure url="https://www.developerway.com//assets/react-project-structure/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title><![CDATA[React key attribute: best practices for performant lists]]></title>
      <link>https://www.developerway.com/posts/react-key-attribute</link>
      <guid>react-key-attribute</guid>
      <pubDate>Mon, 09 May 2022 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Looking into how React "key" attribute works, how to use it correctly, how to improve performance of lists with it, and why array index as key is a good idea sometimes]]></description>
      <content:encoded><![CDATA[<p>React ‚Äúkey‚Äù attribute is probably one of the most ‚Äúautopilot‚Äù used features in React üòÖ Who among us honestly can say that they use it because of ‚Äú‚Ä¶some valid reasons‚Äù, rather than ‚Äúbecause eslint rule complained at me‚Äù. And I suspect most people when faced with the question ‚Äúwhy does React need ‚Äúkey‚Äù attribute‚Äù will answer something like ‚Äúerrr‚Ä¶ we‚Äôre supposed to put unique values there so that React can recognise list items, it‚Äôs better for performance‚Äù. And technically this answer is correct. Sometimes.</p>
<p>But what exactly does it mean ‚Äúrecognise items‚Äù? What will happen if I skip the ‚Äúkey‚Äù attribute? Will the app blow up? What if I put a random string there? How unique the value should be? Can I just use array‚Äôs index values there? What are the implications of those choices? How exactly do any of them impact performance and why?</p>
<p>Let‚Äôs investigate together!</p>
<h2>How does React key attribute work</h2>
<p>First of all, before jumping into coding, let‚Äôs figure out the theory: what the ‚Äúkey‚Äù attribute is and why React needs it.</p>
<p>In short, if the ‚Äúkey‚Äù attribute is present, React uses it as a way to identify an element of the same type among its siblings during re-renders (see the docs: <a href="https://reactjs.org/docs/lists-and-keys.html">https://reactjs.org/docs/lists-and-keys.html</a> and <a href="https://reactjs.org/docs/reconciliation.html#recursing-on-children">https://reactjs.org/docs/reconciliation.html#recursing-on-children</a>).In other words, it‚Äôs needed only during re-renders and for neighbouring elements of the same type, i.e. flat lists (this is important!).</p>
<p>A simplified algorithm of the process during re-render looks like this:</p>
<ul>
<li>first, React will generate the ‚Äúbefore‚Äù and ‚Äúafter‚Äù ‚Äúsnapshots‚Äù of the elements</li>
<li>second, it will try to identify those elements that already existed on the page, so that it can re-use them instead of creating them from scratch
<ul>
<li>if the ‚Äúkey‚Äù attribute exists, it will assume that items with the same ‚Äúbefore‚Äù and ‚Äúafter‚Äù key are the same</li>
<li>if the ‚Äúkey‚Äù attribute doesn‚Äôt exist, it will just use sibling‚Äôs indexes as the default ‚Äúkey‚Äù</li>
</ul>
</li>
<li>third, it will:
<ul>
<li>get rid of the items that existed in the ‚Äúbefore‚Äù phase, but don‚Äôt exist in the ‚Äúafter‚Äù (i.e. unmount them)</li>
<li>create from scratch items that haven‚Äôt existed in the ‚Äúbefore‚Äù variant (i.e. mount them)</li>
<li>update items that existed ‚Äúbefore‚Äù and continue to exist ‚Äúafter‚Äù (i.e. re-render them)</li>
</ul>
</li>
</ul>
<p>It‚Äôs much easier to understand when you play with code a little bit, so let‚Äôs do that as well.</p>
<h2>Why random ‚Äúkey‚Äù attributes are a bad idea?</h2>
<p>Let‚Äôs implement a list of countries first. We‚Äôll have an <code>Item</code> component, that renders the country‚Äôs info:</p>
<pre><code class="language-tsx">const Item = ({ country }) =&gt; {
  return (
    &lt;button className=&quot;country-item&quot;&gt;
      &lt;img src={country.flagUrl} /&gt;
      {country.name}
    &lt;/button&gt;
  );
};
</code></pre>
<p>and a <code>CountriesList</code> component that renders the actual list:</p>
<pre><code class="language-tsx">const CountriesList = ({ countries }) =&gt; {
  return (
    &lt;div&gt;
      {countries.map((country) =&gt; (
        &lt;Item country={country} /&gt;
      ))}
    &lt;/div&gt;
  );
};
</code></pre>
<p>Now, I don‚Äôt have the ‚Äúkey‚Äù attribute on my items at the moment. So what will happen when the <code>CountriesList</code> component re-renders?</p>
<ul>
<li>React will see that there is no ‚Äúkey‚Äù there and fall back to using the <code>countries</code> array‚Äôs indexes as keys</li>
<li>our array hasn‚Äôt changed, so all items will be identified as ‚Äúalready existed‚Äù, and the items will be re-rendered</li>
</ul>
<p>Essentially, it will be no different than adding <code>key={index}</code> to the <code>Item</code> explicitly</p>
<pre><code class="language-tsx">countries.map((country, index) =&gt; &lt;Item country={country} key={index} /&gt;);
</code></pre>
<p><img src="https://www.developerway.com/assets/react-key-attribute/index-based-simple-list.png" alt=""/></p>
<p>In short: when <code>CountriesList</code> component re-renders, every <code>Item</code> will re-render as well. And if we wrap <code>Item</code> in <code>React.memo</code>, we even can get rid of those unnecessary re-renders and improve the performance of our list component.</p>
<p>Now the fun part: what if, instead of indexes, we add some random strings to the ‚Äúkey‚Äù attribute?</p>
<pre><code class="language-tsx">countries.map((country, index) =&gt; &lt;Item country={country} key={Math.random()} /&gt;);
</code></pre>
<p>In this case:</p>
<ul>
<li>on every re-render of <code>CountriesList</code>, React will re-generate the ‚Äúkey‚Äù attributes</li>
<li>since the ‚Äúkey‚Äù attribute is present, React will use it as a way to identify ‚Äúexisting‚Äù elements</li>
<li>since all ‚Äúkey‚Äù attributes will be new, all items ‚Äúbefore‚Äù will be considered as ‚Äúremoved‚Äù, every <code>Item</code> will be considered as ‚Äúnew‚Äù, and React will unmount all items and mount them back again</li>
</ul>
<p><img src="https://www.developerway.com/assets/react-key-attribute/random-keys-list.png" alt=""/></p>
<p>In short: when <code>CountriesList</code> component re-renders, every <code>Item</code> will be destroyed and re-created from scratch.</p>
<p>And re-mounting of components is much, much more expensive, compared to the simple re-render when we talk about performance. Also, all performance improvements from wrapping items in <code>React.memo</code> will go away - memoisation won‚Äôt work since items are re-created on every re-render.</p>
<p>Take a look at the above examples in <a href="https://codesandbox.io/s/react-key-attribute-simple-render-vrpcj3?file=/src/country-settings/list.tsx">the codesandbox</a>. Click on buttons to re-render and pay attention to the console output. Throttle your CPU a little, and the delay when you click the button will be visible even with the naked eye!</p>
<b>How to throttle you CPU</b>
<p>In Chrome developer tools open ‚ÄúPerformance‚Äù tab, click the ‚Äúcogwheel‚Äù icon on the top right - it will open an additional panel, with ‚ÄúCPU throttling‚Äù as one of the options.</p>
<h2>Why ‚Äúindex‚Äù as a ‚Äúkey‚Äù attribute is not a good idea</h2>
<p>By now it should be obvious, why we need stable ‚Äúkey‚Äù attributes, that persist between re-renders. But what about array‚Äôs ‚Äúindex‚Äù? Even in the official docs, they are not recommended, with the reasoning that they can cause bugs and performance implications. But what exactly is happening that can cause such consequences when we‚Äôre using ‚Äúindex‚Äù instead of some unique <code>id</code>?</p>
<p>First of all, we won&#x27;t see any of this in the example above. All those bugs and performance implications <strong>only</strong> happen in ‚Äúdynamic‚Äù lists - lists, where the order or number of the items can change between re-renders. To imitate this, let‚Äôs implement sorting functionality for our list:</p>
<pre><code class="language-tsx">const CountriesList = ({ countries }) =&gt; {
  // introduce some state
  const [sort, setSort] = useState(&#x27;asc&#x27;);

  // sort countries base on state value with lodash orderBy function
  const sortedCountries = orderBy(countries, &#x27;name&#x27;, sort);

  // add button that toggles state between &#x27;asc&#x27; and &#x27;desc&#x27;
  const button = &lt;button onClick={() =&gt; setSort(sort === &#x27;asc&#x27; ? &#x27;desc&#x27; : &#x27;asc&#x27;)}&gt;toggle sorting: {sort}&lt;/button&gt;;

  return (
    &lt;div&gt;
      {button}
      {sortedCountries.map((country) =&gt; (
        &lt;ItemMemo country={country} /&gt;
      ))}
    &lt;/div&gt;
  );
};
</code></pre>
<p>Every time I click the button the array‚Äôs order is reversed. And I‚Äôm going to implement the list in two variants, with <code>country.id</code> as a key:</p>
<pre><code class="language-tsx">sortedCountries.map((country) =&gt; &lt;ItemMemo country={country} key={country.id} /&gt;);
</code></pre>
<p>and array‚Äôs <code>index</code> as a key:</p>
<pre><code class="language-tsx">sortedCountries.map((country, index) =&gt; &lt;ItemMemo country={country} key={index} /&gt;);
</code></pre>
<p>And going to memoise <code>Item</code> component right away for performance purposes:</p>
<pre><code class="language-tsx">const ItemMemo = React.memo(Item);
</code></pre>
<p>Here is <a href="https://codesandbox.io/s/react-key-attribute-sorting-1jwd6y?file=/src/country-settings/list.tsx">the codesandbox</a> with the full implementation. Click on the sorting buttons with throttled CPU, notice how &quot;index&quot;-based list is slightly slower, and pay attention to the console output: in the &quot;index&quot;-based list every item re-renders on every button click, even though <code>Item</code> is memoised and technically shouldn‚Äôt do that. The &quot;id&quot;-based implementation, exactly the same as ‚Äúkey‚Äù-based except for the key value, doesn‚Äôt have this problem: no items are re-rendered after the button‚Äôs click, and the console output is clean.</p>
<p>Why is this happening? The secret is the ‚Äúkey‚Äù value of course:</p>
<ul>
<li>React generates ‚Äúbefore‚Äù and ‚Äúafter‚Äù list of elements and tries to identify items that are ‚Äúthe same‚Äù</li>
<li>from React‚Äôs perspective, the ‚Äúsame‚Äù items are the items that have the same keys</li>
<li>in ‚Äúindex‚Äù-based implementation, the first item in the array will always have <code>key=&quot;0&quot;</code>, the second one will have <code>key=&quot;1&quot;</code>, etc, etc - regardless of the sorting of the array</li>
</ul>
<p>So, when React does the comparison, when it sees the item with the <code>key=&quot;0&quot;</code> in both ‚Äúbefore‚Äù and ‚Äúafter‚Äù lists, it thinks that it‚Äôs exactly the same item, only with a different props value: <code>country</code> value has changed after we reversed the array. And therefore it does what it should do for the same item: triggers its re-render cycle. And since it thinks that the <code>country</code> prop value has changed, it will bypass the memo function, and trigger the actual item‚Äôs re-render.</p>
<p><img src="https://www.developerway.com/assets/react-key-attribute/index-based-sorted-list.png" alt=""/></p>
<p>The id-based behaviour is correct and performant: items are recognized accurately, and every item is memoised, so no component is re-rendered.</p>
<p><img src="https://www.developerway.com/assets/react-key-attribute/id-based-sorted.png" alt=""/></p>
<p>This behaviour is going to be especially visible if we introduce some state to the Item component. Let‚Äôs, for example, change its background when it‚Äôs clicked:</p>
<pre><code class="language-tsx">const Item = ({ country }) =&gt; {
  // add some state to capture whether the item is active or not
  const [isActive, setIsActive] = useState(false);

  // when the button is clicked - toggle the state
  return (
    &lt;button className={`country-item ${isActive ? &#x27;active&#x27; : &#x27;&#x27;}`} onClick={() =&gt; setIsActive(!isActive)}&gt;
      &lt;img src={country.flagUrl} /&gt;
      {country.name}
    &lt;/button&gt;
  );
};
</code></pre>
<p>Take a look at <a href="https://codesandbox.io/s/react-key-attribute-sorting-1jwd6y?file=/src/country-settings/list.tsx">the same codesandbox</a>, only this time click on a few countries first, to trigger the background change, and only then click the ‚Äúsort‚Äù button.</p>
<p>The id-based list behaves exactly as you‚Äôd expect. But the index-based list now behaves funny: if I click on the first item in the list, and then click sort - the first item stays selected, regardless of the sorting. And this is the symptom of the behaviour described above: React thinks that the item with <code>key=&quot;0&quot;</code> (first item in the array) is exactly the same before and after the state change, so it re-uses the same component instance, keeps the state as it was (i.e. <code>isActive</code> set to <code>true</code> for this item), and just updates the props values (from the first country to the last country).</p>
<p>And exactly the same thing will happen, if instead of sorting we‚Äôll add an item at the start of the array: React will think that the item with <code>key=&quot;0&quot;</code> (first item) stays the same, and the last item is the new one. So if the first item is selected, in the index-based list the selection will stay at the first item, every item will re-render, and the ‚Äúmount‚Äù even will be triggered for the last item. In the id-based list, only the newly added item will be mounted and rendered, the rest will sit there quietly. Check it out in <a href="https://codesandbox.io/s/react-key-attribute-sorting-and-inserting-first-item-v5r8hf?file=/src/country-settings/list.tsx">the codesandbox</a>. Throttle your CPU, and the delay of adding a new item in the index-based list is yet again visible with the naked eye! The id-based list is blazing fast even with the 6x CPU throttle.</p>
<h2>Why ‚Äúindex‚Äù as a ‚Äúkey‚Äù attribute IS a good idea</h2>
<p>After the previous sections it‚Äôs easy to say ‚Äújust always use a unique item <code>id</code> for ‚Äúkey‚Äù attribute‚Äù, isn‚Äôt it? And for most cases it‚Äôs true and if you use <code>id</code> all the time nobody will probably notice or mind. But when you have the knowledge, you have superpowers. Now, since we know what exactly is happening when React renders lists, we can cheat and make some lists even <em>faster</em> with <code>index</code> instead of <code>id</code>.</p>
<p>A typical scenario: paginated list. You have a limited number of items in a list, you click on a button - and you want to show <em>different</em> items of the same type in the same size list. If you go with <code>key=&quot;id&quot;</code> approach, then every time you change the page you‚Äôll load completely new set of items with completely different ids. Which means React won‚Äôt be able to find any ‚Äúexisting‚Äù items, unmount the entire list, and mount completely fresh set of items. But! If you go with <code>key=&quot;index&quot;</code> approach, React will think that all the items on the new ‚Äúpage‚Äù already existed, and will just update those items with the fresh data, leaving the actual components mounted. This is going to be visibly faster even on relatively small data sets, if item components are complicated.</p>
<p>Take a look at this example in <a href="https://codesandbox.io/s/react-key-attribute-faster-with-index-3mnyxp?file=/src/country-settings/list.tsx">the codesandbox</a>. Pay attention to the console output - when you switch pages in the ‚Äúid&quot;-based list on the right, every item is re-mounted. But in ‚Äúindex&quot;-based list on the left items are only re-rendered. Much faster! With throttled CPU, even with 50 items very simple list (just a text and an image), the difference between switching pages in the ‚Äúid&quot;-based list and ‚Äúindex&quot;-based list is already visible.</p>
<p>And exactly the same situation is going to be with all sorts of dynamic list-like data, where you replace your existing items with the new data set while preserving the list-like appearance: autocomplete components, google-like search pages, paginated tables. Just would need to be mindful about introducing state in those items: they would have to be either stateless, or state should be synced with props.</p>
<h2>All the keys are in the right places!</h2>
<p>That is all for today! Hope you liked the read and have a better understanding now of how React ‚Äúkey‚Äù attribute works, how to use it correctly, and even how to bend its rules to your will and cheat your way through the performance game.</p>
<p>A few key takeaways to leave with:</p>
<ul>
<li>never use random value in the ‚Äúkey‚Äù attribute: it will cause the item to re-mount on every render. Unless of course, this is your intention</li>
<li>there is no harm in using the array‚Äôs index as ‚Äúkey‚Äù in ‚Äústatic‚Äù lists - those whose items number and order stay the same</li>
<li>use item unique identifier (‚Äúid‚Äù) as ‚Äúkey‚Äù when the list can be re-sorted or items can be added in random places</li>
<li>you can use the array‚Äôs index as ‚Äúkey‚Äù for dynamic lists with stateless items, where items are replaced with the new ones - paginated lists, search and autocomplete results and the like. This will improve the list‚Äôs performance.</li>
</ul>
<p>Have a great day, and may your list items never re-render unless you explicitly told them so! ‚úåüèº</p>]]></content:encoded>
      <enclosure url="https://www.developerway.com//assets/react-key-attribute/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title><![CDATA[React components composition: how to get it right]]></title>
      <link>https://www.developerway.com/posts/components-composition-how-to-get-it-right</link>
      <guid>components-composition-how-to-get-it-right</guid>
      <pubDate>Tue, 12 Apr 2022 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[What is components composition? How do you know when to start splitting a big component into smaller pieces and how to compose them properly? What makes a good component?]]></description>
      <content:encoded><![CDATA[<p>One of the most interesting and challenging things in React is not mastering some advanced techniques for state management or how to use Context properly. More complicated to get right is how and when we should separate our code into independent components and how to compose them properly. I often see developers falling into two traps: either they are not extracting them soon enough, and end up with huge components ‚Äúmonoliths‚Äù that do way too many things at the same time, and that are a nightmare to maintain. Or, especially after they have been burned a few times by the previous pattern, they extract components way too early, which results in a complicated combination of multiple abstractions, over-engineered code and again, a nightmare to maintain.</p>
<p>What I want to do today, is to offer a few techniques and rules, that could help identify when and how to extract components on time and how not to fall into an over-engineering trap. But first, let‚Äôs refresh some basics: what is composition and which compositions patterns are available to us?</p>
<h2>React components composition patterns</h2>
<h3>Simple components</h3>
<p>Simple components are a basic building block of React. They can accept props, have some state, and can be quite complicated despite their name. A <code>Button</code> component that accepts <code>title</code> and <code>onClick</code> properties and renders a button tag is a simple component.</p>
<pre><code class="language-tsx">const Button = ({ title, onClick }) =&gt; &lt;button onClick={onClick}&gt;{title}&lt;/button&gt;;
</code></pre>
<p>Any component can render other components - that‚Äôs composition. A <code>Navigation</code> component that renders that <code>Button</code> - also a simple component, that composes other components:</p>
<pre><code class="language-tsx">const Navigation = () =&gt; {
  return (
    &lt;&gt;
      // Rendering out Button component in Navigation component. Composition!
      &lt;Button title=&quot;Create&quot; onClick={onClickHandler} /&gt;
      ... // some other navigation code
    &lt;/&gt;
  );
};
</code></pre>
<p>With those components and their composition, we can implement as complicated UI as we want. Technically, we don‚Äôt even need any other patterns and techniques, all of them are just nice-to-haves that just improve code reuse or solve only specific use cases.</p>
<h3>Container components</h3>
<p>Container components is a more advanced composition technique. The only difference from simple components is that they, among other props, allow passing special prop <code>children</code>, for which React has its own syntax. If our <code>Button</code> from the previous example accepted not <code>title</code> but <code>children</code> it would be written like this:</p>
<pre><code class="language-tsx">// the code is exactly the same! just replace &quot;title&quot; with &quot;children&quot;
const Button = ({ children, onClick }) =&gt; &lt;button onClick={onClick}&gt;{children}&lt;/button&gt;;
</code></pre>
<p>Which is no different from <code>title</code> from <code>Button</code> perspective. The difference is on the consumer side, <code>children</code> syntax is special and looks like your normal HTML tags:</p>
<pre><code class="language-tsx">const Navigation = () =&gt; {
  return (
    &lt;&gt;
      &lt;Button onClick={onClickHandler}&gt;Create&lt;/Button&gt;
      ... // some other navigation code
    &lt;/&gt;
  );
};
</code></pre>
<p>Anything can go into <code>children</code>. We can, for example, add an <code>Icon</code> component there in addition to text, and then <code>Navigation</code> has a composition of <code>Button</code> and <code>Icon</code> components:</p>
<pre><code class="language-tsx">const Navigation = () =&gt; {
  return (
    &lt;&gt;
      &lt;Button onClick={onClickHandler}&gt;
        &lt;!-- Icon component is rendered inside button, but button doesn&#x27;t know --&gt;
        &lt;Icon /&gt;
        &lt;span&gt;Create&lt;/span&gt;
      &lt;/Button&gt;
      ...
      // some other navigation code
    &lt;/&gt;
  )
}
</code></pre>
<p><code>Navigation</code> controls what goes into <code>children</code>, from <code>Button</code>‚Äôs perspective it just renders whatever the consumer wants.</p>
<p>We‚Äôre going to look more into practical examples of this technique further in the article.</p>
<p>There are other composition patterns, like <a href="/posts/higher-order-components-in-react-hooks-era">higher-order components</a>, <a href="/posts/react-component-as-prop-the-right-way">passing components as props</a> or <a href="/posts/how-to-write-performant-react-apps-with-context">context</a>, but those should be used only for very specific use cases. Simple components and container components are the two major pillars of React development, and it‚Äôs better to perfect the use of those before trying to introduce more advanced techniques.</p>
<p>Now, that you know them, you‚Äôre ready to implement as complicated UI as you can possibly need!</p>
<p>Okay, I‚Äôm joking, I&#x27;m not going to do a ‚Äúhow to draw an owl‚Äù type of article here üòÖ</p>
<p><img src="https://www.developerway.com/assets/react-components-composition/how-to-draw-an-owl.jpeg" alt=""/>
It‚Äôs time for some rules and guidelines so that we can actually <s>draw that owl</s> build complicated React apps with ease.</p>
<h2>When is it a good time to extract components?</h2>
<p>The core React development and decomposition rules that I like to follow, and the more I code, the more strongly I feel about them, are:</p>
<ul>
<li>always start implementation from the top</li>
<li>extract components only when there is an actual need for it</li>
<li>always start from ‚Äúsimple‚Äù components, introduce other composition techniques only when there is an actual need for them</li>
</ul>
<p>Any attempt to think ‚Äúin advance‚Äù or start ‚Äúbottom-up‚Äú from small re-usable components always ends up either in over-complicated components API or in components that are missing half of the necessary functionality.</p>
<p>And the very first rule for when a component needs to be decomposed into smaller ones is <strong>when a component is too big</strong>. A good size for a component for me is when it can fit on the screen of my laptop entirely. If I need to scroll to read through the component‚Äôs code - it‚Äôs a clear sign that it‚Äôs too big.</p>
<p>Let‚Äôs start coding now, to see how can this looks in practice. We are going to implement a typical Jira page from scratch today, no less (well, sort of, at least we‚Äôre going to start üòÖ).</p>
<p><img src="https://www.developerway.com/assets/react-components-composition/jira-screen.png" alt=""/></p>
<p>This is a screen of an issue page from my personal project where I keep my favourite recipes found online üç£. In there we need to implement, as you can see:</p>
<ul>
<li>top bar with logo, some menus, ‚Äúcreate‚Äù button and a search bar</li>
<li>sidebar on the left, with the project name, collapsable ‚Äúplanning‚Äù and ‚Äúdevelopment‚Äù sections with items inside (also divided into groups), with an unnamed section with menu items underneath</li>
<li>a big ‚Äúpage content‚Äù section, where all the information about the current issue is shown</li>
</ul>
<p>So let‚Äôs start coding all of this in just one big component to start with. It‚Äôs probably going to look something like this:</p>
<pre><code class="language-tsx">export const JiraIssuePage = () =&gt; {
  return (
    &lt;div className=&quot;app&quot;&gt;
      &lt;div className=&quot;top-bar&quot;&gt;
        &lt;div className=&quot;logo&quot;&gt;logo&lt;/div&gt;
        &lt;ul className=&quot;main-menu&quot;&gt;
          &lt;li&gt;
            &lt;a href=&quot;#&quot;&gt;Your work&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href=&quot;#&quot;&gt;Projects&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href=&quot;#&quot;&gt;Filters&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href=&quot;#&quot;&gt;Dashboards&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href=&quot;#&quot;&gt;People&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href=&quot;#&quot;&gt;Apps&lt;/a&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
        &lt;button className=&quot;create-button&quot;&gt;Create&lt;/button&gt;
        more top bar items here like search bar and profile menu
      &lt;/div&gt;
      &lt;div className=&quot;main-content&quot;&gt;
        &lt;div className=&quot;sidebar&quot;&gt;
          &lt;div className=&quot;sidebar-header&quot;&gt;ELS project&lt;/div&gt;
          &lt;div className=&quot;sidebar-section&quot;&gt;
            &lt;div className=&quot;sidebar-section-title&quot;&gt;Planning&lt;/div&gt;
            &lt;button className=&quot;board-picker&quot;&gt;ELS board&lt;/button&gt;

            &lt;ul className=&quot;section-menu&quot;&gt;
              &lt;li&gt;
                &lt;a href=&quot;#&quot;&gt;Roadmap&lt;/a&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;a href=&quot;#&quot;&gt;Backlog&lt;/a&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;a href=&quot;#&quot;&gt;Kanban board&lt;/a&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;a href=&quot;#&quot;&gt;Reports&lt;/a&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;a href=&quot;#&quot;&gt;Roadmap&lt;/a&gt;
              &lt;/li&gt;
            &lt;/ul&gt;

            &lt;ul className=&quot;section-menu&quot;&gt;
              &lt;li&gt;
                &lt;a href=&quot;#&quot;&gt;Issues&lt;/a&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;a href=&quot;#&quot;&gt;Components&lt;/a&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/div&gt;
          &lt;div className=&quot;sidebar-section&quot;&gt;sidebar development section&lt;/div&gt;
          other sections
        &lt;/div&gt;
        &lt;div className=&quot;page-content&quot;&gt;... here there will be a lot of code for issue view&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>Now, I haven‚Äôt implemented even half of the necessary items there, not to mention any logic, and the component is already way too big to read through it in one glance. See it in <a href="https://codesandbox.io/s/jira-page-one-big-component-twe6l8?file=/src/jira-issue-page.tsx">codesandbox</a>. That‚Äôs good and expected! So before going any further, it‚Äôs time split it into more manageable pieces.</p>
<p>The only thing that I need to do for it, is just to create a few new components and copy-paste code into them. I don‚Äôt have any use-cases for any of the advanced techniques (yet), so everything is going to be a simple component.</p>
<p>I‚Äôm going to create a <code>Topbar</code> component, which will have everything topbar related, <code>Sidebar</code> component, for everything sidebar related, as you can guess, and <code>Issue</code> component for the main part that we‚Äôre not going to touch today. That way our main <code>JiraIssuePage</code> component is left with this code:</p>
<pre><code class="language-tsx">export const JiraIssuePage = () =&gt; {
  return (
    &lt;div className=&quot;app&quot;&gt;
      &lt;Topbar /&gt;
      &lt;div className=&quot;main-content&quot;&gt;
        &lt;Sidebar /&gt;
        &lt;div className=&quot;page-content&quot;&gt;
          &lt;Issue /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>Now let‚Äôs take a look at the new <code>Topbar</code> component implementation:</p>
<pre><code class="language-tsx">export const Topbar = () =&gt; {
  return (
    &lt;div className=&quot;top-bar&quot;&gt;
      &lt;div className=&quot;logo&quot;&gt;logo&lt;/div&gt;
      &lt;ul className=&quot;main-menu&quot;&gt;
        &lt;li&gt;
          &lt;a href=&quot;#&quot;&gt;Your work&lt;/a&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;a href=&quot;#&quot;&gt;Projects&lt;/a&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;a href=&quot;#&quot;&gt;Filters&lt;/a&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;a href=&quot;#&quot;&gt;Dashboards&lt;/a&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;a href=&quot;#&quot;&gt;People&lt;/a&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;a href=&quot;#&quot;&gt;Apps&lt;/a&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;button className=&quot;create-button&quot;&gt;Create&lt;/button&gt;
      more top bar items here like search bar and profile menu
    &lt;/div&gt;
  );
};
</code></pre>
<p>If I implemented all the items there (search bar, all sub-menus, icons on the right), this component also would‚Äôve been too big, so it also needs to be split. And this one is arguably a more interesting case than the previous one. Because, technically, I can just extract <code>MainMenu</code> component from it to make it small enough.</p>
<pre><code class="language-tsx">export const Topbar = () =&gt; {
  return (
    &lt;div className=&quot;top-bar&quot;&gt;
      &lt;div className=&quot;logo&quot;&gt;logo&lt;/div&gt;
      &lt;MainMenu /&gt;
      &lt;button className=&quot;create-button&quot;&gt;Create&lt;/button&gt;
      more top bar items here like search bar and profile menu
    &lt;/div&gt;
  );
};
</code></pre>
<p>But extracting only <code>MainMenu</code> made the <code>Topbar</code> component slightly <em>harder</em> to read for me. Before, when I looked at the <code>Topbar</code>, I could describe it as ‚Äúa component that implements various things in the topbar‚Äù, and focus on the details only when I need to. Now the description would be ‚Äúa component that implements various things in the topbar AND composes some random <code>MainMenu</code> component‚Äù. The reading flow is ruined.</p>
<p>This leads me to my second rule of components decomposition: when extracting smaller components, don‚Äôt stop halfway. A component should be described either as a ‚Äúcomponent that implements various stuff‚Äù or as a ‚Äúcomponent that composes various components together‚Äù, not both.</p>
<p>Therefore, a much better implementatioin of the <code>Topbar</code> component would look like this:</p>
<pre><code class="language-tsx">export const Topbar = () =&gt; {
  return (
    &lt;div className=&quot;top-bar&quot;&gt;
      &lt;Logo /&gt;
      &lt;MainMenu /&gt;
      &lt;Create /&gt;
      more top bar components here like SearchBar and ProfileMenu
    &lt;/div&gt;
  );
};
</code></pre>
<p>Much easier to read now!</p>
<p>And exactly the same story with the <code>Sidebar</code> component - way too big if I‚Äôd implemented all the items, so need to split it:</p>
<pre><code class="language-tsx">export const Sidebar = () =&gt; {
  return (
    &lt;div className=&quot;sidebar&quot;&gt;
      &lt;Header /&gt;
      &lt;PlanningSection /&gt;
      &lt;DevelopmentSection /&gt;
      other sidebar sections
    &lt;/div&gt;
  );
};
</code></pre>
<p>See the full example in <a href="https://codesandbox.io/s/jira-page-splitting-into-components-yje3qe?file=/src/jira-issue-page.tsx">the codesandbox</a>.</p>
<p>And then just repeat those steps every time a component becomes too big. In theory, we can implement this entire Jira page using nothing more than simple components.</p>
<h2>When is it time to introduce Container Components?</h2>
<p>Now the fun part - let‚Äôs take a look at when we should introduce some advanced techniques and why. Starting with Container components.</p>
<p>First, let‚Äôs take a look at the design again. More specifically - at the Planning and Development sections in the sidebar menu.</p>
<p><img src="https://www.developerway.com/assets/react-components-composition/jira-screen-highlight.png" alt=""/></p>
<p>Those not only share the same design for the title, but also the same behaviour: click on the title collapses the section, and in ‚Äúcollapsed‚Äù mode the mini-arrow icon appears. And we implemented it as two different components - <code>PlanningSection</code> and <code>DevelopmentSection</code>. I could, of course, just implement the ‚Äúcollapse‚Äù logic in both of them, it&#x27;s just a matter of a simple state after all:</p>
<pre><code class="language-tsx">const PlanningSection = () =&gt; {
  const [isCollapsed, setIsCollapsed] = useState(false);
  return (
    &lt;div className=&quot;sidebar-section&quot;&gt;
      &lt;div onClick={() =&gt; setIsCollapsed(!isCollapsed)} className=&quot;sidebar-section-title&quot;&gt;
        Planning
      &lt;/div&gt;

      {!isCollapsed &amp;&amp; &lt;&gt;...all the rest of the code&lt;/&gt;}
    &lt;/div&gt;
  );
};
</code></pre>
<p>But:</p>
<ul>
<li>it‚Äôs quite a lot of repetition even between those two components</li>
<li>content of those sections is actually different for every project type or page type, so even more repetition in the nearest future</li>
</ul>
<p>Ideally, I want to encapsulate the logic of collapsed/expanded behavior and the design for the title, while leaving different sections full control over the items that go inside. This is a perfect use case for the Container components. I can just extract everything from the code example above into a component and pass menu items as <code>children</code>. We‚Äôll have a <code>CollapsableSection</code> component:</p>
<pre><code class="language-tsx">const CollapsableSection = ({ children, title }) =&gt; {
  const [isCollapsed, setIsCollapsed] = useState(false);

  return (
    &lt;div className=&quot;sidebar-section&quot;&gt;
      &lt;div className=&quot;sidebar-section-title&quot; onClick={() =&gt; setIsCollapsed(!isCollapsed)}&gt;
        {title}
      &lt;/div&gt;

      {!isCollapsed &amp;&amp; &lt;&gt;{children}&lt;/&gt;}
    &lt;/div&gt;
  );
};
</code></pre>
<p>and <code>PlanningSection</code> (and <code>DevelopmentSection</code> and all other future sections) will become just this:</p>
<pre><code class="language-tsx">const PlanningSection = () =&gt; {
  return (
    &lt;CollapsableSection title=&quot;Planning&quot;&gt;
      &lt;button className=&quot;board-picker&quot;&gt;ELS board&lt;/button&gt;

      &lt;ul className=&quot;section-menu&quot;&gt;... all the menu items here&lt;/ul&gt;
    &lt;/CollapsableSection&gt;
  );
};
</code></pre>
<p>A very similar story is going to be with our root <code>JiraIssuePage</code> component. Right now it looks like this:</p>
<pre><code class="language-tsx">export const JiraIssuePage = () =&gt; {
  return (
    &lt;div className=&quot;app&quot;&gt;
      &lt;Topbar /&gt;
      &lt;div className=&quot;main-content&quot;&gt;
        &lt;Sidebar /&gt;
        &lt;div className=&quot;page-content&quot;&gt;
          &lt;Issue /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>But as soon as we start implementing other pages that are accessible from the sidebar, we‚Äôll see that they all follow exactly the same pattern - sidebar and topbar stay the same, and only the ‚Äúpage content‚Äù area changes. Thanks to the decomposition work we did before we can just copy-paste that layout on every single page - it‚Äôs not that much code after all. But since all of them are exactly the same, it would be good to just extract the code that implements all the common parts and leave only components that change to the specific pages. Yet again a perfect case for the ‚Äúcontainer‚Äù component:</p>
<pre><code class="language-tsx">const JiraPageLayout = ({ children }) =&gt; {
  return (
    &lt;div className=&quot;app&quot;&gt;
      &lt;Topbar /&gt;
      &lt;div className=&quot;main-content&quot;&gt;
        &lt;Sidebar /&gt;
        &lt;div className=&quot;page-content&quot;&gt;{children}&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>And our <code>JiraIssuePage</code> (and future <code>JiraProjectPage</code>, <code>JiraComponentsPage</code>, etc, all the future pages accessible from the sidebar) becomes just this:</p>
<pre><code class="language-tsx">export const JiraIssuePage = () =&gt; {
  return (
    &lt;JiraPageLayout&gt;
      &lt;Issue /&gt;
    &lt;/JiraPageLayout&gt;
  );
};
</code></pre>
<p>If I wanted to summarise the rule in just one sentence, it could be this: extract Container components when there is a need to share some visual or behavioural logic that wraps elements that still need to be under ‚Äúconsumer‚Äù control.</p>
<h3>Container components - performance use case</h3>
<p>Another very important use case for Container components is improving the performance of components. Technically performance is off-topic a bit for the conversation about composition, but it would be a crime not to mention it here.</p>
<p>In actual Jira the Sidebar component is draggable - you can resize it by dragging it left and right by its edge. How would we implement something like this? Probably we‚Äôd introduce a <code>Handle</code> component, some state for the <code>width</code> of the sidebar, and then listen to the ‚Äúmousemove‚Äù event. A rudimentary implementation would look something like this:</p>
<pre><code class="language-tsx">export const Sidebar = () =&gt; {
  const [width, setWidth] = useState(240);
  const [startMoving, setStartMoving] = useState(false);
  const ref = useRef&lt;HTMLDivElement&gt;(null);

  useEffect(() =&gt; {
    if (!ref.current) return;
    const changeWidth = (e: MouseEvent) =&gt; {
      if (!startMoving) return;
      if (!ref.current) return;

      const left = ref.current.getBoundingClientRect().left;
      const wi = e.clientX - left;

      setWidth(wi);
    };

    ref.current.addEventListener(&#x27;mousemove&#x27;, changeWidth);

    return () =&gt; ref.current?.removeEventListener(&#x27;mousemove&#x27;, changeWidth);
  }, [startMoving, ref]);

  const onStartMoving = () =&gt; {
    setStartMoving(true);
  };

  const onEndMoving = () =&gt; {
    setStartMoving(false);
  };

  return (
    &lt;div className=&quot;sidebar&quot; ref={ref} onMouseLeave={onEndMoving} style={{ width: `${width}px` }}&gt;
      &lt;Handle onMouseDown={onStartMoving} onMouseUp={onEndMoving} /&gt;
      ... the rest of the code
    &lt;/div&gt;
  );
};
</code></pre>
<p>There is, however, a problem here: every time we move the mouse we trigger a state update, which in turn will trigger re-rendering of the entire <code>Sidebar</code> component. While on our rudimentary sidebar it‚Äôs not noticeable, it could make the ‚Äúdragging‚Äù of it visibly laggy when the component becomes more complicated. Container components are a perfect solution for it: all we need is to extract all the heavy state operations in a Container component and pass everything else through <code>children</code>.</p>
<pre><code class="language-tsx">const DraggableSidebar = ({ children }: { children: ReactNode }) =&gt; {
  // all the state management code as before

  return (
    &lt;div
      className=&quot;sidebar&quot;
      ref={ref}
      onMouseLeave={onEndMoving}
      style={{ width: `${width}px` }}
    &gt;
      &lt;Handle onMouseDown={onStartMoving} onMouseUp={onEndMoving} /&gt;
      &lt;!-- children will not be affected by this component&#x27;s re-renders --&gt;
      {children}
    &lt;/div&gt;
  );
};
</code></pre>
<p>And our <code>Sidebar</code> component will turn into this:</p>
<pre><code class="language-tsx">export const Sidebar = () =&gt; {
  return (
    &lt;DraggableSidebar&gt;
      &lt;Header /&gt;
      &lt;PlanningSection /&gt;
      &lt;DevelopmentSection /&gt;
      other Sections
    &lt;/DraggableSidebar&gt;
  );
};
</code></pre>
<p>That way <code>DraggableSidebar</code> component will still re-render on every state change, but it will be super cheap since it‚Äôs just one div. And everything that is coming in <code>children</code> will not be affected by this component‚Äôs state updates.</p>
<p>See all the examples of container components in <a href="https://codesandbox.io/s/jira-page-container-components-wrb88p?file=/src/components/sidebar.tsx">this codesandbox</a>. And to compare the bad re-renders use case, <a href="https://codesandbox.io/s/jira-page-container-components-with-bad-rerenders-6ipo1x?file=/src/components/sidebar.tsx">see this codesandbox</a>. Pay attention to the console output while dragging the sidebar in those examples - <code>PlanningSection</code> component logs constantly in the ‚Äúbad‚Äù implementation and only once in the ‚Äúgood‚Äù one.</p>
<p>And if you want to know more about various patterns and how they influence react performance, you might find those articles interesting: <a href="/posts/how-to-write-performant-react-code">How to write performant React code: rules, patterns, do&#x27;s and don&#x27;ts</a>, <a href="/posts/why-custom-react-hooks-could-destroy-your-app-performance">Why custom react hooks could destroy your app performance</a>, <a href="/posts/how-to-write-performant-react-apps-with-context">How to write performant React apps with Context</a>.</p>
<h2>Does this state belong to this component?</h2>
<p>Another thing, other than size, that can signal that a component should be extracted, is state management. Or, to be precise, state management that is irrelevant to the component‚Äôs functionality. Let me show you what I mean.</p>
<p>One of the items in the sidebar in real Jira is ‚ÄúAdd shortcut‚Äù item, which opens a modal dialog when you click on it. How would you implement it in our app? The modal dialog itself is obviously going to be its own component, but where you‚Äôd introduce the state that opens it? Something like this?</p>
<pre><code class="language-tsx">const SomeSection = () =&gt; {
  const [showAddShortcuts, setShowAddShortcuts] = useState(false);

  return (
    &lt;div className=&quot;sidebar-section&quot;&gt;
      &lt;ul className=&quot;section-menu&quot;&gt;
        &lt;li&gt;
          &lt;span onClick={() =&gt; setShowAddShortcuts(true)}&gt;Add shortcuts&lt;/span&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      {showAddShortcuts &amp;&amp; &lt;ModalDialog onClose={() =&gt; setShowAddShortcuts(false)} /&gt;}
    &lt;/div&gt;
  );
};
</code></pre>
<p>You can see something like this everywhere, and there is nothing criminal in this implementation. But if I was implementing it, and if I wanted to make this component perfect from the composition perspective, I would extract this state and components related to it outside. And the reason is simple - this state has nothing to do with the <code>SomeSection</code> component. This state controls a modal dialog that appears when you click on shortcuts item. This makes the reading of this component slightly harder for me - I see a component that is ‚Äúsection‚Äù, and next line - some random state that has nothing to do with ‚Äúsection‚Äù. So instead of the implementation above, I would extract the item and the state that actually belongs to this item into its own component:</p>
<pre><code class="language-tsx">const AddShortcutItem = () =&gt; {
  const [showAddShortcuts, setShowAddShortcuts] = useState(false);

  return (
    &lt;&gt;
      &lt;span onClick={() =&gt; setShowAddShortcuts(true)}&gt;Add shortcuts&lt;/span&gt;
      {showAddShortcuts &amp;&amp; &lt;ModalDialog onClose={() =&gt; setShowAddShortcuts(false)} /&gt;}
    &lt;/&gt;
  );
};
</code></pre>
<p>And the section component becomes much simpler as a bonus:</p>
<pre><code class="language-tsx">const OtherSection = () =&gt; {
  return (
    &lt;div className=&quot;sidebar-section&quot;&gt;
      &lt;ul className=&quot;section-menu&quot;&gt;
        &lt;li&gt;
          &lt;AddShortcutItem /&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>See it in <a href="https://codesandbox.io/s/jira-page-add-shortcuts-dialog-wb3iq8?file=/src/components/sidebar.tsx">the codesandbox</a>.</p>
<p>By the same logic, in the <code>Topbar</code> component I would move the future state that controls menus to a <code>SomeDropdownMenu</code> component, all search-related state to <code>Search</code> component, and everything related to opening ‚Äúcreate issue‚Äù dialog to the <code>CreateIssue</code> component.</p>
<h2>What makes a good component?</h2>
<p>One last thing before closing for today. In the summary I want to write ‚Äúthe secret of writing scalable apps in React is to extract good components at the right time‚Äù. We covered the ‚Äúright time‚Äù already, but what exactly is a ‚Äúgood component‚Äù? After everything that we covered about composition by now, I think I‚Äôm ready to write a definition and a few rules here.</p>
<p>A ‚Äúgood component‚Äù is a component that I can easily read and understand what it does from the first glance.</p>
<p>A ‚Äúgood component‚Äù should have a good self-describing name. <code>Sidebar</code> for a component that renders sidebar is a good name. <code>CreateIssue</code> for a component that handles issue creation is a good name. <code>SidebarController</code> for a component that renders sidebar items specific for ‚ÄúIssues‚Äù page is not a good name (the name indicates that the component is of some generic purpose, not specific to a particular page).</p>
<p>A ‚Äúgood component‚Äù doesn‚Äôt do things that are irrelevant to its declared purpose. <code>Topbar</code> component that only renders items in the top bar and controls only topbar behaviour is a good component. <code>Sidebar</code> component, that controls the state of various modal dialogs is not the best component.</p>
<h2>Closing bullet points</h2>
<p>Now I can write it üòÑ! The secret of writing scalable apps in React is to extract good components at the right time, nothing more.</p>
<p><strong>What makes a good component?</strong></p>
<ul>
<li>size, that allows reading it without scrolling</li>
<li>name, that indicates what it does</li>
<li>no irrelevant state management</li>
<li>easy-to-read implementation</li>
</ul>
<p><strong>When is it time to split a component into smaller ones?</strong></p>
<ul>
<li>when a component is too big</li>
<li>when a component performs heavy state management operations that might affect performance</li>
<li>when a component manages an irrelevant state</li>
</ul>
<p><strong>What are the general components composition rules?</strong></p>
<ul>
<li>always start implementation from the very top</li>
<li>extract components only when you have an actual usecase for it, not in advance</li>
<li>always start with the Simple components, introduce advanced techniques only when they are actually needed, not in advance</li>
</ul>
<p>That is all for today, hope you enjoyed the reading and found it useful! See ya next time ‚úåüèº</p>]]></content:encoded>
      <enclosure url="https://www.developerway.com//assets/react-components-composition/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title><![CDATA[Implementing advanced usePrevious hook with React useRef]]></title>
      <link>https://www.developerway.com/posts/implementing-advanced-use-previous-hook</link>
      <guid>implementing-advanced-use-previous-hook</guid>
      <pubDate>Mon, 21 Mar 2022 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Looking into how refs work when not attached to DOM and how to use them to implement advanced usePrevious hook to get the previous state or props value.]]></description>
      <content:encoded><![CDATA[<p>After Context, ref is probably the most mysterious part of React. We almost got used to the ref attribute on our components, but not everyone is aware, that its usage is not limited to passing it back and forth between components and attaching it to the DOM nodes. We actually can store data there! And even implement things like <a href="https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state">usePrevious hook</a> to get the previous state or props or any other value.</p>
<p>By the way, if you ever used that hook in the way that is written in React docs, have you investigated how it actually works? And what value it returns and why? The result might surprise you üòâ</p>
<p>So this is exactly what I want to do in this article: take a look at ref and how it works when it‚Äôs not attached to a DOM node; investigate how <code>usePrevious</code> works and show why it‚Äôs not always a good idea to use it as-is; implement a more advanced version of the hook as a bonus üôÇ</p>
<p>Ready to join in?</p>
<h2>First of all, what is ref?</h2>
<p>Let‚Äôs remember some basics first, to understand it fully.</p>
<p>Imagine you need to store and manipulate some data in a component. Normally, we have two options: either put it in a variable or in the state. In a variable you‚Äôd put something that needs to be re-calculated on every re-render, like any intermediate value that depends on a prop value:</p>
<pre><code class="language-tsx">const Form = ({ price }) =&gt; {
  const discount = 0.1 * price;

  return &lt;&gt;Discount: {discount}&lt;/&gt;;
};
</code></pre>
<p>Creating a new variable or changing that variable won‚Äôt cause <code>Form</code> component to re-render.</p>
<p>In the state, we usually put values that need to be saved between re-renders, typically coming from users interacting with our UI:</p>
<pre><code class="language-tsx">const Form = () =&gt; {
  const [name, setName] = useState();

  return &lt;input value={name} onChange={(e) =&gt; setName(e.target.value)} /&gt;;
};
</code></pre>
<p>Changing the state will cause the <code>Form</code> component to re-render itself.</p>
<p>There is, however, a third, lesser-known option: ref. It merges the behaviour of those two: it‚Äôs essentially a variable that doesn‚Äôt cause components to re-render, but its value is preserved between re-renders.</p>
<p>Let‚Äôs just implement a counter (I promise, it‚Äôs the first and the last counter example in this blog) to illustrate all those three behaviours.</p>
<pre><code class="language-tsx">const Counter = () =&gt; {
  let counter = 0;

  const onClick = () =&gt; {
    counter = counter + 1;
    console.log(counter);
  };

  return (
    &lt;&gt;
      &lt;button onClick={onClick}&gt;click to update counter&lt;/button&gt;
      Counter value: {counter}
    &lt;/&gt;
  );
};
</code></pre>
<p>This is not going to work of course. In our <code>console.log</code> we‚Äôll see the updated counter value, but the value rendered on the screen is not going to change - variables don‚Äôt cause re-renders, so our render output will never be updated.</p>
<p>State, on the other hand, will work as expected: that‚Äôs exactly what state is for.</p>
<pre><code class="language-tsx">const Counter = () =&gt; {
  const [counter, setCounter] = useState(0);

  const onClick = () =&gt; {
    setCounter(counter + 1);
  };

  return (
    &lt;&gt;
      &lt;button onClick={onClick}&gt;click to update counter&lt;/button&gt;
      Counter value: {counter}
    &lt;/&gt;
  );
};
</code></pre>
<p>Now the interesting part: the same with ref.</p>
<pre><code class="language-tsx">const Counter = () =&gt; {
  // set ref&#x27;s initial value, same as state
  const ref = useRef(0);

  const onClick = () =&gt; {
    // ref.current is where our counter value is stored
    ref.current = ref.current + 1;
  };

  return (
    &lt;&gt;
      &lt;button onClick={onClick}&gt;click to update counter&lt;/button&gt;
      Counter value: {ref.curent}
    &lt;/&gt;
  );
};
</code></pre>
<p>This is also not going to work. <em>Almost</em>. With every click on the button the value in the ref changes, but changing ref value <strong>doesn‚Äôt cause re-render</strong>, so the render output again is not updated. But! If something else causes a render cycle after that, render output will be updated with the latest value from the <code>ref.current</code>. For example, if I add both of the counters to the same function:</p>
<pre><code class="language-tsx">const Counter = () =&gt; {
  const ref = useRef(0);
  const [stateCounter, setStateCounter] = useState(0);

  return (
    &lt;&gt;
      &lt;button onClick={() =&gt; setStateCounter(stateCounter + 1)}&gt;update state counter&lt;/button&gt;
      &lt;button
        onClick={() =&gt; {
          ref.current = ref.current + 1;
        }}
      &gt;
        update ref counter
      &lt;/button&gt;
      State counter value: {stateCounter}
      Ref counter value: {ref.curent}
    &lt;/&gt;
  );
};
</code></pre>
<p>This will lead to an interesting effect: every time you click on the ‚Äúupdate ref counter‚Äù button nothing visible happens. But if after that you click the ‚Äúupdate state counter‚Äù button, the render output will be updated with both of the values. Play around with it in <a href="https://codesandbox.io/s/use-ref-intro-q0tmws?file=/src/App.tsx">the codesandbox.</a></p>
<p>Counter is obviously not the best use of refs. There is, however, a very interesting use case for them, that is even recommended in React docs themselves: to implement a hook usePrevious that returns <a href="https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state">previous state or props</a>. Let‚Äôs implement it next!</p>
<h2>usePrevious hook from React docs</h2>
<p>Before jumping into re-inventing the wheel, let‚Äôs see what <a href="https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state">the docs</a> have to offer:</p>
<pre><code class="language-tsx">const usePrevious = (value) =&gt; {
  const ref = useRef();
  useEffect(() =&gt; {
    ref.current = value;
  });
  return ref.current;
};
</code></pre>
<p>Seems simple enough. Now, before diving into how it actually works, let‚Äôs first try it out on a simple form.</p>
<p>We‚Äôll have a settings page, where you need to type in your name and select a price for your future product. And at the bottom of the page, I‚Äôll have a simple ‚Äúshow price change‚Äù component, that will show the current selected price, and whether this price increased or decreased compared to the previous value - this is where I‚Äôm going to use the <code>usePrevious</code> hook.</p>
<p>Let‚Äôs start with implementing the form with price only since it‚Äôs the most important part of our functionality.</p>
<pre><code class="language-tsx">const prices = [100, 200, 300, 400, 500, 600, 700];

const Page = () =&gt; {
  const [price, setPrice] = useState(100);

  const onPriceChange = (e) =&gt; setPrice(Number(e.target.value));

  return (
    &lt;&gt;
      &lt;select value={price} onChange={onPriceChange}&gt;
        {prices.map((price) =&gt; (&lt;option value={price}&gt;{price}$&lt;/option&gt;))}
      &lt;/select&gt;
      &lt;Price price={price} /&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>And the price component:</p>
<pre><code class="language-tsx">export const Price = ({ price }) =&gt; {
  const prevPrice = usePrevious(price);
  const icon = prevPrice &amp;&amp; prevPrice &lt; price ? &#x27;üò°&#x27; : &#x27;üòä&#x27;;

  return (
    &lt;div&gt;
      Current price: {price}; &lt;br /&gt;
      Previous price: {prevPrice} {icon}
    &lt;/div&gt;
  );
};
</code></pre>
<p>Works like a charm, thank you React docs! See <a href="https://codesandbox.io/s/use-previous-hook-standard-only-price-jo61bm?file=/src/App.tsx">the codesandbox</a>.</p>
<p>Now the final small step: add the name input field to the form, to complete the functionality.</p>
<pre><code class="language-tsx">const Page = () =&gt; {
  const [name, setName] = useState(&quot;&quot;);

  const onNameChange = (e) =&gt; setName(e.target.value);

  // the rest of the code is the same

  return (
    &lt;&gt;
      &lt;input type=&quot;text&quot; value={name} onChange={onNameChange} /&gt;
      &lt;!-- the rest is the same --&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>Works like a charm as well? No! üôÄ When I‚Äôm selecting the price, everything works as before. But as soon as I start typing in the name input - the value in the <code>Price</code> component resets itself to the latest selected value, instead of the previous. See <a href="https://codesandbox.io/s/use-previous-hook-standard-0muql2?file=/src/App.tsx">the codesandbox</a>.</p>
<p>But why? ü§î</p>
<p>Now it‚Äôs time to take a closer look at the implementation of <code>usePrevious</code>, remember how ref behaves, and how React lifecycle and re-renders works.</p>
<pre><code class="language-tsx">const usePrevious = (value) =&gt; {
  const ref = useRef();
  useEffect(() =&gt; {
    ref.current = value;
  });
  return ref.current;
};
</code></pre>
<p>First, during the initial render of the <code>Price</code> component, we call our <code>usePrevious</code> hook. In there we create ref with an empty value. After that, we immediately return the value of the created ref, which in this case will be <code>null</code> (which is intentional, there isn&#x27;t a previous value on the initial render). After the initial render finishes, <code>useEffect</code> is triggered, in which we update the <code>ref.current</code> with the value we passed to the hook. And, since it‚Äôs a ref, not state, the value just ‚Äúsits‚Äù there mutated, without causing the hook to re-render itself and as a result without its consumer component getting the latest ref value.</p>
<p>If it‚Äôs difficult to imagine from the text, here is some visual aid:</p>
<p><img src="https://www.developerway.com/assets/implementing-advanced-use-previous-hook/render-cycle-example.png" alt=""/></p>
<p>So what happens then when I start typing in the name fields? The parent <code>Form</code> component updates its state ‚Üí triggers re-renders of its children ‚Üí <code>Price</code> component starts its re-render ‚Üí calls <code>usePrevious</code> hook with the same price value (we changed only name) ‚Üí hook returns the <em>updated</em> value that we mutated during the previous render cycle ‚Üí render finishes, <code>useEffect</code> is triggered, done. On the pic before we‚Äôll have values <code>300</code> transitioning to <code>300</code>. And that will cause the value rendered in the <code>Price</code> component to be updated.</p>
<p>So what this hook in its current implementation does, is it returns a value <strong>from the previous render cycle</strong>. There are, of course, use cases for using it that way. Maybe you just need to trigger some data fetch when the value changes, and what happens after multiple re-renders doesn‚Äôt really matter. But if you want to show the ‚Äúprevious‚Äù value in the UI anywhere, a much more reliable approach here would be for the hook to return the <em>actual</em> previous value.</p>
<p>Let‚Äôs implement exactly that.</p>
<h2>usePrevious hook to return the actual previous value</h2>
<p>In order to do that, we just need to save in ref both values - previous and current. And switch them only when the value actually changes. And here again where ref could come in handy:</p>
<pre><code class="language-tsx">export const usePreviousPersistent = (value) =&gt; {
  // initialise the ref with previous and current values
  const ref = useRef({
    value: value,
    prev: null,
  });

  const current = ref.current.value;

  // if the value passed into hook doesn&#x27;t match what we store as &quot;current&quot;
  // move the &quot;current&quot; to the &quot;previous&quot;
  // and store the passed value as &quot;current&quot;
  if (value !== current) {
    ref.current = {
      value: value,
      prev: current,
    };
  }

  // return the previous value only
  return ref.current.prev;
};
</code></pre>
<p>Implementation even became slightly simpler: we got rid of the mind-boggling magic of relying on <code>useEffect</code> and just accept a value, do an if statement, and return a value. And no glitches in the UI anymore! Check it out in <a href="https://codesandbox.io/s/use-previous-hook-persistent-fgdd0o?file=/src/App.tsx">the codesandbox</a>.</p>
<p>Now, the big question: do we <em>really</em> need refs here? Can‚Äôt we just implement exactly the same thing with the state and not resort to escape hatches (which ref actually is)? Well, technically yes, we can, the code will be pretty much the same:</p>
<pre><code class="language-tsx">export const usePreviousPersistent = (value) =&gt; {
  const [state, setState] = useState({
    value: value,
    prev: null,
  });

  const current = state.value;

  if (value !== current) {
    setState({
      value: value,
      prev: current,
    });
  }

  return state.prev;
};
</code></pre>
<p>There is one problem with this: every time the value changes it will trigger state update, which in turn will trigger re-render of the ‚Äúhost‚Äù component. This will result in the <code>Price</code> component being re-rendered <strong>twice</strong> every time the price prop changes - the first time because of the actual prop change, and the second - because of the state update in the hook. Doesn‚Äôt really matter for our small form, but as a generic solution that is meant to be used anywhere - not a good idea. See <a href="https://codesandbox.io/s/use-previous-hook-persistent-with-state-6i3vi3?file=/src/hooks.tsx">the code here</a>, change the price value to see the double re-render.</p>
<h2>usePrevious hook: deal with objects properly</h2>
<p>Last polish to the hook left: what will happen if I try to pass an object there? For example all the props?</p>
<pre><code class="language-tsx">export const Price = (props) =&gt; {
  // with the current implementation only primitive values are supported
  const prevProps = usePreviousPersistent(props);
  ...
};
</code></pre>
<p>The glitch, unfortunately, <a href="https://codesandbox.io/s/use-previous-hook-persistent-with-props-5xvixj">will return</a>: we‚Äôre doing the shallow comparison here: <code>(value !== current)</code>, so the <code>if</code> check will always return <code>true</code>. To fix this, we can just introduce the <a href="https://lodash.com/docs/4.17.15#isEqual">deep equality</a> comparison instead.</p>
<pre><code class="language-tsx">import isEqual from &#x27;lodash/isEqual&#x27;;

export const usePreviousPersistent = (value) =&gt; {
  ...
  if (!isEqual(value, current)) {
    ...
  }

  return state.prev;
};
</code></pre>
<p>Personally, I‚Äôm not a huge fan of this solution: on big data sets it can become slow, plus depending on an external library (or implementing deep equality by myself) in a hook like that seems less than optimal.</p>
<p>Another way, since hooks are just functions and can accept any arguments, is to introduce a ‚Äúmatcher‚Äù function. Something like this:</p>
<pre><code class="language-tsx">export const usePreviousPersistent = (value, isEqualFunc) =&gt; {
  ...
  if (isEqualFunc ? !isEqualFunc(value, current) : value !== current) {
    ...
  }

  return state.prev;
};
</code></pre>
<p>That way we still can use the hook without the function - it will fallback to the shallow comparison. And also now have the ability to provide a way for the hook to compare the values:</p>
<pre><code class="language-tsx">export const Price = (props) =&gt; {
  const prevPrice = usePrevious(
    price,
    (prev, current) =&gt; prev.price === current.price
  );
  ...
};
</code></pre>
<p>See the <a href="https://codesandbox.io/s/use-previous-hook-persistent-with-matcher-hujqez?file=/src/hooks.tsx">codesandbox</a>.</p>
<p>It might not look that useful for props, but imagine a huge object of some data from external sources there. Typically it will have some sort of id. So instead of the slow deep comparison as in the example before, you can just do this:</p>
<pre><code class="language-tsx">const prevData = usePrevious(price, (prev, current) =&gt; prev.id === current.id);
</code></pre>
<p>That is all for today. Hope you found the article useful, able to use refs more confidently and use both variations of <code>usePrevious</code> hooks with the full understanding of the expected result ‚úåüèº.</p>]]></content:encoded>
      <enclosure
        url="https://www.developerway.com//assets/implementing-advanced-use-previous-hook/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title><![CDATA[Higher-Order Components in React Hooks era]]></title>
      <link>https://www.developerway.com/posts/higher-order-components-in-react-hooks-era</link>
      <guid>higher-order-components-in-react-hooks-era</guid>
      <pubDate>Sun, 27 Feb 2022 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[What is a React higher-order component? How it can be used and why? And do we still need them in modern apps in React hooks era?]]></description>
      <content:encoded><![CDATA[<p>Is it true that React hooks made higher-order components obsolete? And the only use case for those is to be a remnant of the past in some existential legacy corners of our apps? And what is a higher-order component anyway? Why did we need them in the first place?</p>
<p>Answering those questions and building a case that higher-order components are still useful even in modern apps for certain types of tasks.</p>
<p>But let&#x27;s start from the beginning.</p>
<h2>What is a higher-order component?</h2>
<p>According to <a href="https://reactjs.org/docs/higher-order-components.html">React docs</a>, it‚Äôs an advanced technique to re-use components logic that is used for cross-cutting concerns, if that description means anything to you (for me not so much üôÇ).</p>
<p>In English, it‚Äôs just a function, that accepts a component as one of its arguments, messes with it, and then returns back its changed version. The simplest variant of it, that does nothing, is this:</p>
<pre><code class="language-tsx">// accept a Component as an argument
const withSomeLogic = (Component) =&gt; {
  // do something

  // return a component that renders the component from the argument
  return (props) =&gt; &lt;Component {...props} /&gt;;
};
</code></pre>
<p>The key here is the return part of the function - it‚Äôs just a component, like any other component. And similar to the <a href="/posts/react-component-as-prop-the-right-way">render props pattern</a>, we need to pass props to the returned component, otherwise, they will be swallowed.</p>
<p>And then, when it‚Äôs time to use it, it would look like this:</p>
<pre><code class="language-tsx">const Button = ({ onClick }) =&gt; &lt;button onClick={func}&gt;Button&lt;/button&gt;;
const ButtonWithSomeLogic = withSomeLogic(Button);
</code></pre>
<p>You pass your <code>Button</code> component to the function, and it returns the new <code>Button</code>, which includes whatever logic is defined in the higher-order component. And then this button can be used as any other button:</p>
<pre><code class="language-tsx">const SomePage = () =&gt; {
  return (
    &lt;&gt;
      &lt;Button /&gt;
      &lt;ButtonWithSomeLogic /&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>If we want to create a mental map of what goes where it could look something like this:</p>
<p><img src="https://www.developerway.com/assets/higher-order-components/example.png" alt=""/></p>
<p>Play around with those examples <a href="https://codesandbox.io/s/hocs-intro-6jqmju?file=/src/App.tsx">in codesandbox.</a></p>
<p>Before the introduction of hooks, higher-order components were widely used for accessing context and any external data subscriptions. <a href="https://react-redux.js.org/api/connect">Redux connect</a> or <a href="https://v5.reactrouter.com/web/api/withRouter">react-router‚Äôs</a> <code>withRouter</code> functions are higher-order components: they accept a component, inject some props into it, and return it back.</p>
<pre><code class="language-tsx">// location is injected by the withRouter higher-order component
// would you guessed that by the look at this component alone?
const SomeComponent = ({ location }) =&gt; {
  return &lt;&gt;{location}&lt;/&gt;;
};

const ComponentWithRouter = withRouter(SomeComponent);
</code></pre>
<p>As you can see, higher-order components are quite complicated to write and to understand. So when <a href="https://reactjs.org/docs/hooks-intro.html">the hooks</a> were introduced, no wonder everyone switched to them.</p>
<p>Now, instead of creating complicated mental maps of which prop goes where and trying to figure out how <code>location</code> ended up in props, we can just write:</p>
<pre><code class="language-tsx">const SomeComponent = () =&gt; {
  // we see immediately where location is coming from
  const { location } = useRouter();

  return &lt;&gt;{location}&lt;/&gt;;
};
</code></pre>
<p>Everything that is happening in the component can be read from top to bottom and the source of all the data is obvious, which significantly simplifies debugging and development.</p>
<p>And while hooks probably replaced 90% of shared logic concerns and 100% of use-cases for accessing context, there are still at least three types of functionality, where higher-order components could be useful.</p>
<p>Let‚Äôs take a look at those.</p>
<h2>First: enhancing callbacks and React lifecycle events</h2>
<p>Imagine you need to send some sort of advanced logging on some callbacks. When you click a button, for example, you want to send some logging events with some data. How would you do it with hooks? You‚Äôd probably have a <code>Button</code> component with an <code>onClick</code> callback:</p>
<pre><code class="language-tsx">type ButtonProps = {
  onClick: () =&gt; void;
  children: ReactNode;
}

const Button = ({ onClick }: { onClick }: ButtonProps) =&gt; {
  return &lt;button onClick={onClick}&gt;{children}&lt;/button&gt;
}
</code></pre>
<p>And then on the consumer side, you‚Äôd hook into that callback and send logging event there:</p>
<pre><code class="language-tsx">const SomePage = () =&gt; {
  const log = useLoggingSystem();

  const onClick = () =&gt; {
    log(&#x27;Button was clicked&#x27;);
  };

  return &lt;Button onClick={() =&gt; onClick}&gt;Click here&lt;/Button&gt;;
};
</code></pre>
<p>And that is fine if you want to fire an event or two. But what if you want your logging events to be consistently fired across your entire app, whenever the button is clicked? We probably can bake it into the <code>Button</code> component itself.</p>
<pre><code class="language-tsx">const Button = ({ onClick }: { onClick }: ButtonProps) =&gt; {
  const log = useLoggingSystem();

  const onButtonClick = () =&gt; {
    log(&#x27;Button was clicked&#x27;)
    onClick();
  }

  return &lt;button onClick={() =&gt; onClick()}&gt;{children}&lt;/button&gt;
}
</code></pre>
<p>But then what? For proper logs you‚Äôd have to send some sort of data as well. We surely can extend the <code>Button</code> component with some <code>loggingData</code> props and pass it down:</p>
<pre><code class="language-tsx">const Button = ({ onClick, loggingData }: { onClick, loggingData }: ButtonProps) =&gt; {
  const onButtonClick = () =&gt; {
    log(&#x27;Button was clicked&#x27;, loggingData)
    onClick();
  }
  return &lt;button onClick={() =&gt; onButtonClick()}&gt;{children}&lt;/button&gt;
}
</code></pre>
<p>But what if you want to fire the same events when the click has happened on other components? <code>Button</code> is usually not the only thing people can click on in our apps. What if I want to add the same logging to a <code>ListItem</code> component? Copy-paste exactly the same logic there?</p>
<pre><code class="language-tsx">const ListItem = ({ onClick, loggingData }: { onClick, loggingData }: ListItemProps) =&gt; {
  const onListItemClick = () =&gt; {
    log(&#x27;List item was clicked&#x27;, loggingData)
    onClick();
  }
  return &lt;Item onClick={() =&gt; onListItemClick()}&gt;{children}&lt;/Item&gt;
}
</code></pre>
<p>Too much copy-pasta and prone to errors and someone forgetting to change something in my taste.</p>
<p>What I want, essentially, is to encapsulate the logic of ‚Äúsomething triggered <code>onClick</code> callback - send some logging events‚Äù somewhere, and then just re-used it in any component I want, without changing the code of those components in any way.</p>
<p>And this is the first use case where the hooks are no use, but higher-order components could come in handy.</p>
<h3>Higher-order component to enhance onClick callback</h3>
<p>Instead of copy-pasting the ‚Äúclick happened ‚Üí log data‚Äù logic everywhere, I can just create a <code>withLoggingOnClick</code> function, that:</p>
<ul>
<li>accepts a component as an argument</li>
<li>intercepts its onClick callback</li>
<li>sends the data that I need to the whatever external framework is used for logging</li>
<li>returns the component with onClick callback intact for further use</li>
</ul>
<p>It would look something like this:</p>
<pre><code class="language-tsx">type Base = { onClick: () =&gt; void };

// just a function that accepts Component as an argument
export const withLoggingOnClick = &lt;TProps extends Base&gt;(Component: ComponentType&lt;TProps&gt;) =&gt; {
  return (props: TProps) =&gt; {
    const onClick = () =&gt; {
      console.log(&#x27;Log on click something&#x27;);
      // don&#x27;t forget to call onClick that is coming from props!
      // we&#x27;re overriding it below
      props.onClick();
    };

    // return original component with all the props
    // and overriding onClick with our own callback
    return &lt;Component {...props} onClick={onClick} /&gt;;
  };
};
</code></pre>
<p>And now I can just add it to <strong>any</strong> component that I want. I can have a <code>Button</code> with logging baked in:</p>
<pre><code class="language-tsx">export const ButtonWithLoggingOnClick = withLoggingOnClick(SimpleButton);
</code></pre>
<p>Or use it in the list item:</p>
<pre><code class="language-tsx">export const ListItemWithLoggingOnClick = withLoggingOnClick(ListItem);
</code></pre>
<p>Or any other component that has <code>onClick</code> callback that I want to track. Without a single line of code changed in either <code>Button</code> or <code>ListItem</code> components!</p>
<h3>Adding data to the higher-order component</h3>
<p>Now, what‚Äôs left to do, is to add some data from the outside to the logging function. And considering that higher-order component is nothing more than just a function, we can do that easily. Just need to add some other arguments to the function, that‚Äôs it:</p>
<pre><code class="language-tsx">type Base = { onClick: () =&gt; void };
export const withLoggingOnClickWithParams = &lt;TProps extends Base&gt;(
  Component: ComponentType&lt;TProps&gt;,
  // adding some params as a second argument to the function
  params: { text: string },
) =&gt; {
  return (props: TProps) =&gt; {
    const onClick = () =&gt; {
      // accessing params that we passed as an argument here
      // everything else stays the same
      console.log(&#x27;Log on click: &#x27;, params.text);
      props.onClick();
    };

    return &lt;Component {...props} onClick={onClick} /&gt;;
  };
};
</code></pre>
<p>And now, when we wrap our button with higher-order component, we can pass the text that we want to log:</p>
<pre><code class="language-tsx">const ButtonWithLoggingOnClickWithParams = withLoggingOnClickWithParams(SimpleButton, { text: &#x27;button component&#x27; });
</code></pre>
<p>On the consumer side, we‚Äôd just use this button as a normal button component, without worrying about the logging text:</p>
<pre><code class="language-tsx">const Page = () =&gt; {
  return &lt;ButtonWithLoggingOnClickWithParams onClick={onClickCallback}&gt;Click me&lt;/ButtonWithLoggingOnClickWithParams&gt;;
};
</code></pre>
<p>But what if we actually <strong>want</strong> to worry about this text? What if we want to send different texts in different contexts of where the button is used? We wouldn‚Äôt want to create one million wrapped buttons for every use case.</p>
<p>Also very easy to solve: instead of passing that text as function‚Äôs argument, we can inject it as a prop to the resulting button. The code would look like this:</p>
<pre><code class="language-tsx">type Base = { onClick: () =&gt; void };
export const withLoggingOnClickWithProps = &lt;TProps extends Base&gt;(Component: ComponentType&lt;TProps&gt;) =&gt; {
  // our returned component will now have additional logText prop
  return (props: TProps &amp; { logText: string }) =&gt; {
    const onClick = () =&gt; {
      // accessing it here, as any other props
      console.log(&#x27;Log on click: &#x27;, props.logText);
      props.onClick();
    };

    return &lt;Component {...props} onClick={onClick} /&gt;;
  };
};
</code></pre>
<p>And then use it like this:</p>
<pre><code class="language-tsx">const Page = () =&gt; {
  return (
    &lt;ButtonWithLoggingOnClickWithProps onClick={onClickCallback} logText=&quot;this is Page button&quot;&gt;
      Click me
    &lt;/ButtonWithLoggingOnClickWithProps&gt;
  );
};
</code></pre>
<p>See the <a href="https://codesandbox.io/s/hocs-buttons-m45hm4?file=/src/hocs/with-logging-on-click.tsx">codesandbox with all the examples</a>.</p>
<h3>Sending data on mount instead of click</h3>
<p>We are not limited to clicks and callbacks here. Remember, those are just components, we can do whatever we want and need üôÇ We can use everything React has to offer. For example, we can send those logging events when a component is mounted:</p>
<pre><code class="language-tsx">export const withLoggingOnMount = &lt;TProps extends unknown&gt;(Component: ComponentType&lt;TProps&gt;) =&gt; {
  return (props: TProps) =&gt; {
    // no more overriding onClick, just adding normal useEffect
    useEffect(() =&gt; {
      console.log(&#x27;log on mount&#x27;);
    }, []);

    // just passing props intact
    return &lt;Component {...props} /&gt;;
  };
};
</code></pre>
<p>And exactly the same story as with <code>onClick</code> for adding data via arguments or props. Not going to copy-paste it here, see it in <a href="https://codesandbox.io/s/hocs-buttons-m45hm4?file=/src/hocs/with-logging-on-mount.tsx:58-305">the codesandbox</a>.</p>
<p>We can even go wild and combine all of those higher-order components:</p>
<pre><code class="language-tsx">export const SuperButton = withLoggingOnClick(
  withLoggingOnClickWithParams(
    withLoggingOnClickWithProps(
      withLoggingOnMount(withLoggingOnMountWithParams(withLoggingOnMountWithProps(SimpleButton), { text: &#x27;button component&#x27; })),
    ),
    { text: &#x27;button component&#x27; },
  ),
);
</code></pre>
<p>We shouldn‚Äôt do this of course though üòÖ If something is possible, it doesn‚Äôt always mean it‚Äôs a good idea. Imagine trying to trace which props come from where, when debugging time comes. If we really need to combine a few higher-order components into one, we can be at least a bit more specific about it:</p>
<pre><code class="language-tsx">const ButtonWithLoggingOnClick = withLoggingOnClick(SimpleButton);
const ButtonWithLoggingOnClickAndMount = withLoggingOnMount(ButtonWithLoggingOnClick);
// etc
</code></pre>
<h2>Second: intercepting DOM events</h2>
<p>Another very useful application of higher-order components is intercepting various DOM events. Imagine, for example, you implement some sort of keyboard shortcuts functionality on your page. When specific keys are pressed, you want to do various things, like open dialogs, creating issues, etc. You‚Äôd probably add an event listener to window for something like this:</p>
<pre><code class="language-tsx">useEffect(() =&gt; {
  const keyPressListener = (event) =&gt; {
    // do stuff
  };

  window.addEventListener(&#x27;keypress&#x27;, keyPressListener);

  return () =&gt; window.removeEventListener(&#x27;keypress&#x27;, keyPressListener);
}, []);
</code></pre>
<p>And then, you have various parts of your app, like modal dialogs, dropdown menus, drawers, etc, where you want to block that global listener while the dialog is open. If it was just one dialog, you can manually add <code>onKeyPress</code> to the dialog itself and there do <code>event.stopPropagation()</code> for that:</p>
<pre><code class="language-tsx">export const Modal = ({ onClose }: ModalProps) =&gt; {
  const onKeyPress = (event) =&gt; event.stopPropagation();

  return &lt;div onKeyPress={onKeyPress}&gt;...// dialog code&lt;/div&gt;;
};
</code></pre>
<p>But the same story as with <code>onClick</code> logging - what if you have multiple components where you want to see this logic?</p>
<p>What we can do here, is again implement a higher-order component. This time it will accept a component, wrap it in a div with onKeyPress callback attached, and return the component unchanged.</p>
<pre><code class="language-tsx">export const withSupressKeyPress = &lt;TProps extends unknown&gt;(Component: ComponentType&lt;TProps&gt;) =&gt; {
  return (props: TProps) =&gt; {
    const onKeyPress = (event) =&gt; {
      event.stopPropagation();
    };

    return (
      &lt;div onKeyPress={onKeyPress}&gt;
        &lt;Component {...props} /&gt;
      &lt;/div&gt;
    );
  };
};
</code></pre>
<p>That is it! Now we can just use it everywhere:</p>
<pre><code class="language-tsx">const ModalWithSupressedKeyPress = withSupressKeyPress(Modal);
const DropdownWithSupressedKeyPress = withSupressKeyPress(Dropdown);
// etc
</code></pre>
<p>One Important thing to note here: focus management. In order for the above code to actually work, you need to make sure that your dialog-type components move focus to the opened part when they are open. But this is a completely different conversation on focus management, maybe next time.</p>
<p>For the purpose of the example, we can just manually include auto-focus in the modal itself:</p>
<pre><code class="language-tsx">const Modal = () =&gt; {
  const ref = useRef&lt;HTMLDivElement&gt;();

  useEffect(() =&gt; {
    // when modal is mounted, focus the element to which the ref is attached
    if (ref.current) ref.current.focus();
  }, []);

  // adding tabIndex and ref to the div, so now it&#x27;s focusable
  return &lt;div tabIndex={1} ref={ref}&gt;
    &lt;!-- modal code --&gt;
  &lt;/div&gt;
}
</code></pre>
<p>Play around with it in <a href="https://codesandbox.io/s/hocs-modal-mgbq6x?file=/src/hocs/with-supress-key-press.tsx">the codesandbox</a>.</p>
<h2>Third: context selectors</h2>
<p>The final and very interesting use case for higher-order components: selectors-like functionality for React context. As we know, when context value changes, it will cause re-renders of all context consumers, regardless of whether their particular part of the state was changed or not. (And if you didn‚Äôt know about it, here‚Äôs the article for you: <a href="/posts/how-to-write-performant-react-apps-with-context">How to write performant React apps with Context</a>).</p>
<p>Let‚Äôs implement some context and form first, before jumping into higher-order components.</p>
<p>We‚Äôll have Context with <code>id</code> and <code>name</code> and API to change those:</p>
<pre><code class="language-tsx">type Context = {
  id: string;
  name: string;
  setId: (val: string) =&gt; void;
  setName: (val: string) =&gt; void;
};

const defaultValue = {
  id: &#x27;FormId&#x27;,
  name: &#x27;&#x27;,
  setId: () =&gt; undefined,
  setName: () =&gt; undefined,
};

const FormContext = createContext&lt;Context&gt;(defaultValue);

export const useFormContext = () =&gt; useContext(FormContext);

export const FormProvider = ({ children }: { children: ReactNode }) =&gt; {
  const [state, setState] = useState(defaultValue);

  const value = useMemo(() =&gt; {
    return {
      id: state.id,
      name: state.name,
      setId: (id: string) =&gt; setState({ ...state, id }),
      setName: (name: string) =&gt; setState({ ...state, name }),
    };
  }, [state]);

  return &lt;FormContext.Provider value={value}&gt;{children}&lt;/FormContext.Provider&gt;;
};
</code></pre>
<p>And then some form with <code>Name</code> and <code>Countries</code> components</p>
<pre><code class="language-tsx">const Form = () =&gt; {
  return (
    &lt;form css={pageCss}&gt;
      &lt;Name /&gt;
      &lt;Countries /&gt;
    &lt;/form&gt;
  );
};

export const Page = () =&gt; {
  return (
    &lt;FormProvider&gt;
      &lt;Form /&gt;
    &lt;/FormProvider&gt;
  );
};
</code></pre>
<p>Where in <code>Name</code> component we‚Äôll have an input that changes the value of <code>Context</code>, and <code>Countries</code> just use the <code>id</code> of the form to fetch the list of countries (not going to implement the actual fetch, not important for the example:</p>
<pre><code class="language-tsx">const Countries = () =&gt; {
  // using only id from context here
  const { id } = useFormContext();

  console.log(&quot;Countries re-render&quot;);
  return (
    &lt;div&gt;
      &lt;h3&gt;List on countries for form: {id}&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li&gt;Australia&lt;/li&gt;
        &lt;li&gt;USA&lt;/li&gt;
        &lt;!-- etc --&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<pre><code class="language-tsx">const Name = () =&gt; {
  // using name and changing it here
  const { name, setName } = useFormContext();

  return &lt;input onChange={(event) =&gt; setName(event.target.value)} value={name} /&gt;;
};
</code></pre>
<p>Now, every time we type something in the name input field, we‚Äôll update the context value, which will cause re-render of all components that use context, including Countries. And this can‚Äôt be solved by extracting this value into a hook and memoising it: hooks always re-render (<a href="/posts/why-custom-react-hooks-could-destroy-your-app-performance">Why custom react hooks could destroy your app performance</a>).</p>
<p>There are other ways to deal with it of course, if this behaviour causes performance concerns, like memoising parts of render tree or splitting Context into different providers (see those articles that describe those techniques: <a href="/posts/how-to-write-performant-react-apps-with-context">How to write performant React apps with Context</a> and <a href="/posts/how-to-write-performant-react-code">How to write performant React code: rules, patterns, do&#x27;s and don&#x27;ts</a>).</p>
<p>But big disadvantage of all the techniques above, is that they are not shareable and need to be implemented on a case-by-case basis. Wouldn‚Äôt it be nice, if we had some select-like functionality, that we can use to extract this <code>id</code> value safely in any component, without significant refactorings and <code>useMemo</code> all over the app?</p>
<p>Interestingly enough, we can implement something like this with higher-order components. And the reason for this is that components have one thing that hooks don‚Äôt give us: they can memoise things and stop the chain of re-renders going down to children. Basically, this will give us what we want:</p>
<pre><code class="language-tsx">export const withFormIdSelector = &lt;TProps extends unknown&gt;(
  Component: ComponentType&lt;TProps &amp; { formId: string }&gt;
) =&gt; {
  const MemoisedComponent = React.memo(Component) as ComponentType&lt;
    TProps &amp; { formId: string }
  &gt;;

  return (props: TProps) =&gt; {
    const { id } = useFormContext();

    return &lt;MemoisedComponent {...props} formId={id} /&gt;;
  };
};
</code></pre>
<p>and then we can just create <code>CountriesWithFormIdSelector</code> component:</p>
<pre><code class="language-tsx">// formId prop here is injected by the higher-order component below
const CountriesWithFormId = ({ formId }: { formId: string }) =&gt; {
  console.log(&quot;Countries with selector re-render&quot;);
  return (
     &lt;-- code is the same as before --&gt;
  );
};

const CountriesWithFormIdSelector = withFormIdSelector(CountriesWithFormId);
</code></pre>
<p>And use it in our form:</p>
<pre><code class="language-tsx">const Form = () =&gt; {
  return (
    &lt;form css={pageCss}&gt;
      &lt;Name /&gt;
      &lt;CountriesWithFormIdSelector /&gt;
    &lt;/form&gt;
  );
};
</code></pre>
<p><a href="https://codesandbox.io/s/hocs-context-lwudbb?file=/src/page.tsx">Check it out in the codesandbox</a>. Pay special attention of the
console output when typing in the input - CountriesWithFormIdSelector component doesn‚Äôt re-render!</p>
<h3>Generic React context selector</h3>
<p><code>withFormIdSelector</code> is fun and could work for small context-based apps. But wouldn‚Äôt it be nice to have it as something generic? So that we don‚Äôt have to implement a custom selector for every state property.</p>
<p>No problem when some creative hackery is involved! Check it out, selector itself:</p>
<pre><code class="language-tsx">export const withContextSelector = &lt;TProps extends unknown, TValue extends unknown&gt;(
  Component: ComponentType&lt;TProps &amp; Record&lt;string, TValue&gt;&gt;,
  selectors: Record&lt;string, (data: Context) =&gt; TValue&gt;,
): ComponentType&lt;Record&lt;string, TValue&gt;&gt; =&gt; {
  // memoising component generally for every prop
  const MemoisedComponent = React.memo(Component) as ComponentType&lt;Record&lt;string, TValue&gt;&gt;;

  return (props: TProps &amp; Record&lt;string, TValue&gt;) =&gt; {
    // extracting everything from context
    const data = useFormContext();

    // mapping keys that are coming from &quot;selectors&quot; argument
    // to data from context
    const contextProps = Object.keys(selectors).reduce((acc, key) =&gt; {
      acc[key] = selectors[key](data);

      return acc;
    }, {});

    // spreading all props to the memoised component
    return &lt;MemoisedComponent {...props} {...contextProps} /&gt;;
  };
};
</code></pre>
<p>and then use it with components:</p>
<pre><code class="language-tsx">// props are injected by the higher order component below
const CountriesWithFormId = ({ formId, countryName }: { formId: string; countryName: string }) =&gt; {
  console.log(&#x27;Countries with selector re-render&#x27;);
  return (
    &lt;div&gt;
      &lt;h3&gt;List of countries for form: {formId}&lt;/h3&gt;
      Selected country: {countryName}
      &lt;ul&gt;
        &lt;li&gt;Australia&lt;/li&gt;
        &lt;li&gt;USA&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};

// mapping props to selector functions
const CountriesWithFormIdSelector = withContextSelector(CountriesWithFormId, {
  formId: (data) =&gt; data.id,
  countryName: (data) =&gt; data.country,
});
</code></pre>
<p>And that‚Äôs it! we basically implemented mini-Redux on context, even with proper <code>mapStateToProps</code> functionality üôÇ Check it out in <a href="https://codesandbox.io/s/hocs-context-generic-selector-wdijzp?file=/src/page.tsx">the codesandbox</a>.</p>
<p>That is it for today! Hope higher-order components are not some terrifying legacy goblins now, but something you can put to good use even in modern apps. Let‚Äôs re-cap the use cases for those:</p>
<ul>
<li>to enhance callbacks and React lifecycle events with additional functionality, like sending logging or analytics events</li>
<li>to intercept DOM events, like blocking global keyboard shortcuts when a modal dialog is open</li>
<li>to extract a piece of Context without causing unnecessary re-renders in the component</li>
</ul>
<p>May the peace and love be with you ‚úåüèº</p>]]></content:encoded>
      <enclosure url="https://www.developerway.com//assets/higher-order-components/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title><![CDATA[React component as prop: the right way‚Ñ¢Ô∏è]]></title>
      <link>https://www.developerway.com/posts/react-component-as-prop-the-right-way</link>
      <guid>react-component-as-prop-the-right-way</guid>
      <pubDate>Tue, 15 Feb 2022 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Exploring how to pass React components as props, why we would want to do it, and what is the best pattern for the job]]></description>
      <content:encoded><![CDATA[<p>As always in React, there is one million way to do exactly the same thing. If, for example, I need to pass a component as a prop to another component, how should I do this? If I search the popular open-source libraries for an answer, I will find that:</p>
<ul>
<li>I can pass them as Elements like <a href="https://mui.com/components/buttons/#buttons-with-icons-and-label">Material UI library</a> does in Buttons with the <code>startIcon</code> prop</li>
<li>I can pass them as components themselves like for example <a href="https://react-select.com/components">react-select library</a> does for its <code>components</code> prop</li>
<li>I can pass them as functions like <a href="https://mui.com/components/data-grid/columns/#render-cell">Material UI</a> Data Grid component does with its <code>renderCell</code> prop</li>
</ul>
<p>Not confusing at all üòÖ.</p>
<p>So which way is the best way and which one should be avoided? Which one should be included in some ‚ÄúReact best practices‚Äù list and why? Let‚Äôs figure it out together!</p>
<p>Or, if you like spoilers, just scroll to the summary part of the article. There is a definitive answer to those questions üòâ</p>
<h2>Why would we want to pass components as props?</h2>
<p>Before jumping into coding, let‚Äôs first understand why we would want to pass components as props to begin with. Short answer: for flexibility and to simplify sharing data between those components.</p>
<p>Imagine, for example, we‚Äôre implementing a button with an icon. We could, of course, implement it like this:</p>
<pre><code class="language-tsx">const Button = ({ children }: { children: ReactNode }) =&gt; {
  return (
    &lt;button&gt;
      &lt;SomeIcon size=&quot;small&quot; color=&quot;red&quot; /&gt;
      {children}
    &lt;/button&gt;
  );
};
</code></pre>
<p>But what if we need to give people the ability to change that icon? We could introduce <code>iconName</code> prop for that:</p>
<pre><code class="language-tsx">type Icons = &#x27;cross&#x27; | &#x27;warning&#x27; | ... // all the supported icons

const getIconFromName = (iconName: Icons) =&gt; {
  switch (iconName) {
    case &#x27;cross&#x27;:
      return &lt;CrossIcon size=&quot;small&quot; color=&quot;red&quot; /&gt;;
    ...
    // all other supported icons
  }
}
const Button = ({ children, iconName }: { children: ReactNode, iconName: Icons }) =&gt; {
  const icon = getIconFromName(name);

  return &lt;button&gt;
    {icon}
    {children}
  &lt;/button&gt;
}
</code></pre>
<p>What about the ability for people to change the appearance of that icon? Change its size and color for example? We‚Äôd have to introduce some props for that as well:</p>
<pre><code class="language-tsx">type Icons = &#x27;cross&#x27; | &#x27;warning&#x27; | ... // all the supported icons
type IconProps = {
  size: &#x27;small&#x27; | &#x27;medium&#x27; | &#x27;large&#x27;,
  color: string
};
const getIconFromName = (iconName: Icons, iconProps: IconProps) =&gt; {
  switch (iconName) {
    case &#x27;cross&#x27;:
      return &lt;CrossIcon {...iconProps} /&gt;;
    ...
    // all other supported icons
  }
}
const Button = ({ children, iconName, iconProps }: { children: ReactNode, iconName: Icons, iconProps: IconProps }) =&gt; {
  const icon = getIconFromName(name, iconProps);

  return &lt;button&gt;
    {icon}
    {children}
  &lt;/button&gt;
}
</code></pre>
<p>What about giving people the ability to change the icon when something in the button changes? If a button is hovered, for example, and I want to change icon‚Äôs color to something different. I‚Äôm not even going to implement it here, it‚Äôd be way too complicated: we‚Äôd have to expose <code>onHover</code> callback, introduce state management in every single parent component, set state when the button is hovered, etc, etc.</p>
<p>It‚Äôs not only a very limited and complicated API. We also forced our <code>Button</code> component to know about every icon it can render, which means the bundled js of this <code>Button</code> will not only include its own code, but also every single icon on the list. That is going to be one heavy button üôÇ</p>
<p>This is where passing components in props come in handy. Instead of passing to the <code>Button</code> the detailed limited description of the <code>Icon</code> in form of its name and its props, our <code>Button</code> can just say: &quot;gimme an <code>Icon</code>, I don&#x27;t care which one, your choice, and I&#x27;ll render it in the right place&quot;.</p>
<p>Let‚Äôs see how it can be done with the three patterns we identified at the beginning:</p>
<ul>
<li>passing as an Element</li>
<li>passing as a Component</li>
<li>passing as a Function</li>
</ul>
<h2>Building a button with an icon</h2>
<p>Or, to be precise, let‚Äôs build three buttons, with 3 different APIs for passing the icon, and then compare them. Hopefully, it will be obvious which one is better in the end. For the icon we‚Äôre going to use one of the icons from <a href="https://mui.com/components/icons/">material ui components library</a>. Lets start with the basics and just build the API first.</p>
<h3>First: icon as React Element</h3>
<p>We just need to pass an element to the <code>icon</code> prop of the button and then render that icon near the children like any other element.</p>
<pre><code class="language-tsx">type ButtonProps = {
  children: ReactNode;
  icon: ReactElement&lt;IconProps&gt;;
};

export const ButtonWithIconElement = ({ children, icon }: ButtonProps) =&gt; {
  return (
    &lt;button&gt;
      // our icon, same as children, is just React element
      // which we can add directly to the render function
      {icon}
      {children}
    &lt;/button&gt;
  );
};
</code></pre>
<p>And then can use it like this:</p>
<pre><code class="language-tsx">&lt;ButtonWithIconElement icon={&lt;AccessAlarmIconGoogle /&gt;}&gt;button here&lt;/ButtonWithIconElement&gt;
</code></pre>
<h3>Second: icon as a Component</h3>
<p>We need to create a prop that starts with a capital letter to signal it‚Äôs a component, and then render that component from props like any other component.</p>
<pre><code class="language-tsx">type ButtonProps = {
  children: ReactNode;
  Icon: ComponentType&lt;IconProps&gt;;
};

export const ButtonWithIconComponent = ({ children, Icon }: ButtonProps) =&gt; {
  return (
    &lt;button&gt;
      // our button is a component
      // its name starts with a capital letter to signal that
      // so we can just render it here as any other component
      &lt;Icon /&gt;
      {children}
    &lt;/button&gt;
  );
};
</code></pre>
<p>And then can use it like this:</p>
<pre><code class="language-tsx">import AccessAlarmIconGoogle from &#x27;@mui/icons-material/AccessAlarm&#x27;;

&lt;ButtonWithIconComponent Icon={AccessAlarmIconGoogle}&gt;button here&lt;/ButtonWithIconComponent&gt;;
</code></pre>
<h3>Third: icon as a function</h3>
<p>We need to create a prop that starts with <code>render</code> to indicate it‚Äôs a render function, i.e. a function that returns an element, call the function inside the button and add the result to component‚Äôs render function as any other element.</p>
<pre><code class="language-tsx">type ButtonProps = {
  children: ReactNode;
  renderIcon: () =&gt; ReactElement&lt;IconProps&gt;;
};

export const ButtonWithIconRenderFunc = ({ children, renderIcon }: ButtonProps) =&gt; {
  // getting the Element from the function
  const icon = renderIcon();
  return (
    &lt;button&gt;
      // adding element like any other element here
      {icon}
      {children}
    &lt;/button&gt;
  );
};
</code></pre>
<p>And then use it like this:</p>
<pre><code class="language-tsx">&lt;ButtonWithIconRenderFunc renderIcon={() =&gt; &lt;AccessAlarmIconGoogle /&gt;}&gt;button here&lt;/ButtonWithIconRenderFunc&gt;
</code></pre>
<p>That was easy! Now our buttons can render any icon in that special icon slot without even knowing what‚Äôs there. See the working example <a href="https://codesandbox.io/s/buttons-with-icon-24slt?file=/src/App.tsx">in the codesandbox</a>.</p>
<p>Time to put those APIs to a test.</p>
<h2>Modifying the size and color of the icon</h2>
<p>Let‚Äôs first see whether we can adjust our icon according to our needs without disturbing the button. After all, that was the major promise of those patterns, isn‚Äôt it?</p>
<h3>First: icon as React Element</h3>
<p>Couldn‚Äôt have been easier: all we need is just pass some props to the icon. We are using material UI icons, they give us <code>fontSize</code> and <code>color</code> for that.</p>
<pre><code class="language-tsx">&lt;ButtonWithIconElement icon={&lt;AccessAlarmIconGoogle fontSize=&quot;small&quot; color=&quot;warning&quot; /&gt;}&gt;button here&lt;/ButtonWithIconElement&gt;
</code></pre>
<h3>Second: icon as a Component</h3>
<p>Also simple: we need to extract our icon into a component, and pass the props there in the return element.</p>
<pre><code class="language-tsx">const AccessAlarmIcon = () =&gt; &lt;AccessAlarmIconGoogle fontSize=&quot;small&quot; color=&quot;error&quot; /&gt;;

const Page = () =&gt; {
  return &lt;ButtonWithIconComponent Icon={AccessAlarmIcon}&gt;button here&lt;/ButtonWithIconComponent&gt;;
};
</code></pre>
<p><strong>Important</strong>: the <code>AccessAlarmIcon</code> component should always be defined outside of the <code>Page</code> component, otherwise it will re-create this component on every <code>Page</code> re-render, and that is really bad for performance and prone to bugs. If you‚Äôre not familiar with how quickly it can turn ugly, this is the article for you: <a href="/posts/how-to-write-performant-react-code">How to write performant React code: rules, patterns, do&#x27;s and don&#x27;ts</a></p>
<h3>Third: icon as a Function</h3>
<p>Almost the same as the first one: just pass the props to the element.</p>
<pre><code class="language-tsx">&lt;ButtonWithIconRenderFunc
  renderIcon={() =&gt; (
    &lt;AccessAlarmIconGoogle fontSize=&quot;small&quot; color=&quot;success&quot; /&gt;
  )}
&gt;
</code></pre>
<p>Easily done for all three of them, we have infinite flexibility to modify the <code>Icon</code> and didn‚Äôt need to touch the button for a single thing. Compare it with <code>iconName</code> and <code>iconProps</code> from the very first example üôÇ</p>
<h2>Default values for the icon size in the button</h2>
<p>You might have noticed, that I used the same icon size for all three examples. And when implementing a generic button component, more likely than not, you‚Äôll have some prop that control button‚Äôs size as well. Infinity flexibility is good, but for something as design systems, you‚Äôd want some pre-defined types of buttons. And for different buttons sizes, you‚Äôd want the button to control the size of the icon, not leave it to the consumer, so you won‚Äôt end up with tiny icons in huge buttons or vice versa by accident.</p>
<p>Now it‚Äôs getting interesting: is it possible for the button to control one aspect of an icon while leaving the flexibility intact?</p>
<h3>First: icon as React Element</h3>
<p>For this one, it gets a little bit ugly. We receive our icon as a pre-defined element already, so the only thing we can do is to clone that element by using <code>React.cloneElement</code> api and override some of its props:</p>
<pre><code class="language-tsx">// in the button component
const clonedIcon = React.cloneElement(icon, { fontSize: &#x27;small&#x27; });

return (
  &lt;button&gt;
    {clonedIcon}
    {children}
  &lt;/button&gt;
);
</code></pre>
<p>And at the consumer side we can just remove the <code>fontSize</code> property.</p>
<pre><code class="language-tsx">&lt;ButtonWithIconElement icon={&lt;AccessAlarmIconGoogle color=&quot;warning&quot; /&gt;} /&gt;
</code></pre>
<p>But what about default value, not overriding? What if I want consumers to be able to change the size of the icon if they need to?</p>
<p>Still possible, although even uglier, just nee to extract the passed props from the element and put them as default value:</p>
<pre><code class="language-tsx">const clonedIcon = React.cloneElement(icon, {
  fontSize: icon.props.fontSize || &#x27;small&#x27;,
});
</code></pre>
<p>From the consumer side everything stays as it was before</p>
<pre><code class="language-tsx">&lt;ButtonWithIconElement icon={&lt;AccessAlarmIconGoogle color=&quot;warning&quot; fontSize=&quot;large&quot; /&gt;} /&gt;
</code></pre>
<h3>Second: icon as a Component</h3>
<p>Even more interesting here. First, we need to give the icon the default value on button side:</p>
<pre><code class="language-tsx">export const ButtonWithIconComponent = ({ children, Icon }: ButtonProps) =&gt; {
  return (
    &lt;button&gt;
      &lt;Icon fontSize=&quot;small&quot; /&gt;
      {children}
    &lt;/button&gt;
  );
};
</code></pre>
<p>And this is going to work perfectly when we pass the directly imported icon:</p>
<pre><code class="language-tsx">import AccessAlarmIconGoogle from &#x27;@mui/icons-material/AccessAlarm&#x27;;

&lt;ButtonWithIconComponent Icon={AccessAlarmIconGoogle}&gt;button here&lt;/ButtonWithIconComponent&gt;;
</code></pre>
<p><code>Icon</code> prop is nothing more than just a reference to material UI icon component here, and that one knows how to deal with those props. But we extracted this icon to a component when we had to pass to it some color, remember?</p>
<pre><code class="language-tsx">const AccessAlarmIcon = () =&gt; &lt;AccessAlarmIconGoogle fontSize=&quot;small&quot; color=&quot;error&quot; /&gt;;
</code></pre>
<p>Now the props&#x27; <code>Icon</code> is a reference to that wrapper component, and it just assumes that it doesn‚Äôt have any props. So our <code>fontSize</code> value from <code>&lt;Icon fontSize=&quot;small&quot; /&gt;</code> from the button will be just swallowed. This whole pattern, if you‚Äôve never worked with it before, can be confusing, since it creates this a bit weird mental circle that you need to navigate in order to understand what goes where.</p>
<p><img src="https://www.developerway.com/assets/components-in-props/mental-circle-example.png" alt=""/></p>
<p>In order to fix the icon, we just need to pass through the props that <code>AccessAlarmIcon</code> receives to the actual icon. Usually, it‚Äôs done via spread:</p>
<pre><code class="language-tsx">const AccessAlarmIcon = (props) =&gt; &lt;AccessAlarmIconGoogle {...props} color=&quot;error&quot; /&gt;;
</code></pre>
<p>Or can be just hand-picked as well:</p>
<pre><code class="language-tsx">const AccessAlarmIcon = (props) =&gt; &lt;AccessAlarmIconGoogle fontSize={props.fontSize} color=&quot;error&quot; /&gt;;
</code></pre>
<p><img src="https://www.developerway.com/assets/components-in-props/mental-circle-with-props-example.png" alt=""/></p>
<p>While this pattern seems complicated, it actually gives us perfect flexibility: the button can easily set its own props, and the consumer can choose whether they want to follow the direction buttons gives and how much of it they want, or whether they want to do their own thing. If, for example, I want to override button‚Äôs value and set my own icon size, all I need to do is to ignore the prop that comes from the button:</p>
<pre><code class="language-tsx">const AccessAlarmIcon = (props) =&gt; (
  // just ignore all the props coming from the button here
  // and override with our own values
  &lt;AccessAlarmIconGoogle fontSize=&quot;large&quot; color=&quot;error&quot; /&gt;
);
</code></pre>
<h3>Third: icon as a Function</h3>
<p>This is going to be pretty much the same as with icon as a Component, only with the function. First, adjust the button to pass settings to the <code>renderIcon</code> function:</p>
<pre><code class="language-tsx">const icon = renderIcon({
  fontSize: &#x27;small&#x27;,
});
</code></pre>
<p>And then on the consumer side, similar to props in Component step, pass that setting to the rendered component:</p>
<pre><code class="language-tsx">&lt;ButtonWithIconRenderFunc renderIcon={(settings) =&gt; &lt;AccessAlarmIconGoogle fontSize={settings.fontSize} color=&quot;success&quot; /&gt;}&gt;
  button here
&lt;/ButtonWithIconRenderFunc&gt;
</code></pre>
<p>And again, if we want to override the size, all we need to do is to ignore the setting and pass our own value:</p>
<pre><code class="language-tsx">&lt;ButtonWithIconRenderFunc
  // ignore the setting here and write our own fontSize
  renderIcon={(settings) =&gt; &lt;AccessAlarmIconGoogle fontSize=&quot;large&quot; color=&quot;success&quot; /&gt;}
&gt;
  button here
&lt;/ButtonWithIconRenderFunc&gt;
</code></pre>
<p>See <a href="https://codesandbox.io/s/buttons-with-icon-extended-vl6lo?file=/src/App.tsx">the codesandbox</a> with all three examples.</p>
<h2>Changing the icon when the button is hovered</h2>
<p>And now the final test that should decide everything: I want to give the ability for the users to modify the icon when the button is hovered.</p>
<p>First, let‚Äôs teach the button to notice the hover. Just some state and callbacks to set that state should do it:</p>
<pre><code class="language-tsx">export const ButtonWithIcon = (...) =&gt; {
  const [isHovered, setIsHovered] = useState(false);

  return (
    &lt;button
      onMouseOver={() =&gt; setIsHovered(true)}
      onMouseOut={() =&gt; setIsHovered(false)}
    &gt;
      ...
    &lt;/button&gt;
  );
};
</code></pre>
<p>And then the icons.</p>
<h3>First: icon as React Element</h3>
<p>That one is the most interesting of the bunch. First, we need to pass that <code>isHover</code> prop to the icon from the button:</p>
<pre><code class="language-tsx">const clonedIcon = React.cloneElement(icon, {
  fontSize: icon.props.fontSize || &#x27;small&#x27;,
  isHovered: isHovered,
});
</code></pre>
<p>And now, interestingly enough, we created <strong>exactly the same</strong> mental circle that we had when we implemented ‚Äúicon as Component‚Äù. We passed <code>isHover</code> property to the icon component, now we need to go to the consumer, wrap that original icon component into another component, that component will have <code>isHover</code> prop from the button, and it should return the icon we want to render in the button. ü§Ø If you managed to understand that explanation from just words I‚Äôll send you some chocolate üòÖ Here‚Äôs some code to make it easier.</p>
<p>Instead of the original simple direct render of the icon:</p>
<pre><code class="language-tsx">&lt;ButtonWithIconElement icon={&lt;AccessAlarmIconGoogle color=&quot;warning&quot; /&gt;}&gt;button here&lt;/ButtonWithIconElement&gt;
</code></pre>
<p>we should create a wrapper component that has <code>isHovered</code> in its props and renders that icons as a result:</p>
<pre><code class="language-tsx">const AlarmIconWithHoverForElement = (props) =&gt; {
  return (
    &lt;AccessAlarmIconGoogle
      // don&#x27;t forget to spread all the props!
      // otherwise you&#x27;ll lose all the defaults the button is setting
      {...props}
      // and just override the color based on the value of `isHover`
      color={props.isHovered ? &#x27;primary&#x27; : &#x27;warning&#x27;}
    /&gt;
  );
};
</code></pre>
<p>And then render that new component in the button itself:</p>
<pre><code class="language-tsx">&lt;ButtonWithIconElement icon={&lt;AlarmIconWithHoverForElement /&gt;}&gt;button here&lt;/ButtonWithIconElement&gt;
</code></pre>
<p>Looks a little bit weird, but it works perfectly ü§∑üèΩ‚Äç‚ôÄÔ∏è</p>
<h3>Second: icon as a Component</h3>
<p>First, pass the <code>isHover</code> to the icon in the button:</p>
<pre><code class="language-tsx">&lt;Icon fontSize=&quot;small&quot; isHovered={isHovered} /&gt;
</code></pre>
<p>And then back to the consumer. And now the funniest thing ever. In the previous step we created exactly the same mental circle that we need to remember when we‚Äôre dealing with components passed as Components. And it‚Äôs not just the mental picture of data flow, I can literally <strong>re-use exactly the same component</strong> from the previous step here! They are just components with some props after all:</p>
<pre><code class="language-tsx">&lt;ButtonWithIconComponent Icon={AlarmIconWithHoverForElement}&gt;button here&lt;/ButtonWithIconComponent&gt;
</code></pre>
<p>üí• works perfectly.</p>
<h3>Third: icon as a Function</h3>
<p>Same story: just pass the <code>isHovered</code> value to the function as the arguments:</p>
<pre><code class="language-tsx">const icon = renderIcon({
  fontSize: &#x27;small&#x27;,
  isHovered: isHovered,
});
</code></pre>
<p>And then use it on the consumer side:</p>
<pre><code class="language-tsx">&lt;ButtonWithIconRenderFunc
  renderIcon={(settings) =&gt; (
    &lt;AccessAlarmIconGoogle
      fontSize={settings.fontSize}
      color={settings.isHovered ? &quot;primary&quot; : &quot;warning&quot;}
    /&gt;
  )}
&gt;
</code></pre>
<p>üéâ again, works perfectly.</p>
<p>Take a look at <a href="https://codesandbox.io/s/buttons-with-icon-and-hover-y4zgl?file=/src/App.tsx">the sandbox</a> with the working solution.</p>
<h2>Summary and the answer: which way is The Right Way‚Ñ¢Ô∏è?</h2>
<p>If you read the full article, you‚Äôre probably saying right now: Nadia, aren‚Äôt they are basically the same thing? What‚Äôs the difference? You promised a clear answer, but I don‚Äôt see it ‚òπÔ∏è And you‚Äôre right.</p>
<p>And if you just scrolled here right away because you love spoilers: I‚Äôm sorry, I lied a bit for the sake of the story üò≥. There is no right answer here.</p>
<p>All of them are more or less the same and you probably can implement 99% of the needed use cases (if not 100%) with just one pattern everywhere. The only difference here is semantics, which area has the most complexity, and personal preferences and religious beliefs.</p>
<p>If I <em>had to</em> extract some general rules of which pattern should be used where, I‚Äôd probably go with something like this:</p>
<ul>
<li>I‚Äôd use ‚Äúcomponent as an Element‚Äù pattern (<code>&lt;Button icon={&lt;Icon /&gt;} /&gt;</code>) for cases, where I just need to render the component in a pre-defined place, without modifying its props in the ‚Äúreceiving‚Äù component.</li>
<li>I‚Äôd use ‚Äúcomponent as a Component‚Äù pattern (<code>&lt;Button Icon={Icon} /&gt;</code>) when I need to heavily modify and customise this component on the ‚Äúreceiving‚Äù side through its props, while at the same time allowing users full flexibility to override those props themselves (pretty much as <a href="https://react-select.com/components">react-select</a> does for <code>components</code> prop).</li>
<li>I‚Äôd use ‚Äúcomponent as a Function‚Äù pattern (<code>&lt;Button renderIcon={() =&gt; &lt;Icon /&gt;} /&gt;</code>) when I need the consumer to modify the result of this function, depending on some values coming from the ‚Äúhost‚Äù component itself (pretty much what <a href="https://mui.com/components/data-grid/columns/#render-cell">Material UI Data Grid</a> component does with <code>renderCell</code> prop)</li>
</ul>
<p>Hope this article made those patterns easier to understand and now you can use all of them when the use case needs it. Or you can now just totally ban any of them in your repo, just for fun or consistency sake, since now you can implement whatever you want with just one pattern üòä</p>
<p>See ya next time! ‚úåüèº</p>]]></content:encoded>
      <enclosure url="https://www.developerway.com//assets/components-in-props/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title><![CDATA[How to write performant React apps with Context]]></title>
      <link>https://www.developerway.com/posts/how-to-write-performant-react-apps-with-context
      </link>
      <guid>how-to-write-performant-react-apps-with-context</guid>
      <pubDate>Mon, 07 Feb 2022 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[De-mystifying Context and its influence on React apps' performance. Learning a few useful patterns in the process, that could help minimize the re-renders impact and improve code's readability and scalability.]]></description>
      <content:encoded><![CDATA[<p>It‚Äôs impossible to have a conversation on <a href="/posts/how-to-write-performant-react-code">how to write performant React code</a> without having an article or two on Context. And it‚Äôs such a controversial topic! There are so many prejudices and rumours surrounding it. Context is evil! React re-renders everything for no reason when you use Context! Sometimes I have a feeling that developers treat Context like it‚Äôs a magic gremlin, that randomly and spontaneously re-renders the entire app for its own amusement.</p>
<p>In this article I do not intend to convince anyone that we should ditch our beloved state management libraries in favour of Context. They exist for a reason. The main goal here is to de-mystify Context and provide a few interesting coding patterns, that could help minimise Context-related re-renders and improve your React apps performance. And as a nice bonus, the code will look cleaner and more understandable as a result.</p>
<p>Let‚Äôs start the investigation with implementing some real-life app, and see where this will take us.</p>
<h2>Let‚Äôs implement a form in React</h2>
<p>Our form is going to be quite complicated, it would consist, to begin with, from:</p>
<ul>
<li>a ‚ÄúPersonal info‚Äú section, where people can set some personal information, i.e name, email, etc</li>
<li>a ‚ÄúValue calculation‚Äú section where people can set their currency preferences, their preferred discount, add some coupons, etc</li>
<li>the selected discount should be highlighted in the Personal section in a form of an emoji (don‚Äôt ask, the designer has a weird sense of humour)</li>
<li>an ‚ÄúActions‚Äù section with action buttons (i.e. ‚ÄúSave‚Äù, ‚ÄúReset‚Äù, etc)</li>
</ul>
<p>The ‚Äúdesign‚Äù looks like this:</p>
<p><img src="https://www.developerway.com/assets/how-to-write-performant-react-context/design.png" alt=""/></p>
<p>To make things more interesting, we‚Äôre also going to pretend that ‚Äúselect country‚Äù and ‚Äúdragging bar‚Äù components are ‚Äúexternal‚Äù libraries that we installed as a package. So we can only use them through API, but have no influence on what‚Äôs inside. And we‚Äôre going to use the ‚Äúslow‚Äù version of the countries select, that we implemented in the <a href="/posts/how-to-write-performant-react-code">previous performance investigation</a>.</p>
<p>Now it‚Äôs time to write some code. Let‚Äôs start with the components structure of the app. I know this form will quickly become quite complicated, so I want to separate it into smaller, more contained components right away.</p>
<p>At the root I‚Äôll have my main <code>Form</code> component, which will render the three required sections:</p>
<pre><code class="language-tsx">const Form = () =&gt; {
  return (
    &lt;&gt;
      &lt;PersonalInfoSection /&gt;
      &lt;ValueCalculationsSection /&gt;
      &lt;ActionsSection /&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>‚ÄúPersonal info‚Äù section will then render three more components: the discount emoji, input for the name and countries select</p>
<pre><code class="language-tsx">const PersonalInfoSection = () =&gt; {
  return (
    &lt;Section title=&quot;Personal information&quot;&gt;
      &lt;DiscountSituation /&gt;
      &lt;NameFormComponent /&gt;
      &lt;SelectCountryFormComponent /&gt;
    &lt;/Section&gt;
  );
};
</code></pre>
<p>All three of them will contain the actual logic of those components (the code of them will be below), and the <code>Section</code> just encapsulates some styles.</p>
<p>‚ÄúValue calculation‚Äù section will have just one component (for now), the discount bar:</p>
<pre><code class="language-tsx">const ValueCalculationSection = () =&gt; {
  return (
    &lt;Section title=&quot;Value calculation&quot;&gt;
      &lt;DiscountFormComponent /&gt;
    &lt;/Section&gt;
  );
};
</code></pre>
<p>And ‚ÄúActions‚Äù section will have just one button for now as well: the save button with onSave callback.</p>
<pre><code class="language-tsx">const ActionsSection = ({ onSave }: { onSave: () =&gt; void }) =&gt; {
  return (
    &lt;Section title=&quot;Actions&quot;&gt;
      &lt;button onClick={onClick}&gt;Save form&lt;/button&gt;
    &lt;/Section&gt;
  );
};
</code></pre>
<p>Now the interesting part: we need to make this form interactive. Considering that we have a single ‚ÄúSave‚Äù button for the entire form, and different sections would need data from other sections, the natural place for the state management is at the root, in the <code>Form</code> component. We‚Äôll have 3 pieces of data there: Name, Country and Discount, a way to set all three of them, and a way to ‚Äúsave‚Äù it:</p>
<pre><code class="language-tsx">type State = {
  name: string;
  country: Country;
  discount: number;
};

const Form = () =&gt; {
  const [state, setState] = useState&lt;State&gt;(defaultState as State);

  const onSave = () =&gt; {
    // send the request to the backend here
  };

  const onDiscountChange = (discount: number) =&gt; {
    setState({ ...state, discount });
  };

  const onNameChange = (name: string) =&gt; {
    setState({ ...state, name });
  };

  const onCountryChange = (country: Country) =&gt; {
    setState({ ...state, country });
  };

  // the rest as before
};
</code></pre>
<p>And now we need to pass the relevant data and callbacks to the components that need it. In our <code>PersonalInfoSection</code>:</p>
<ul>
<li>the <code>DiscountSituation</code> component should be able to show the emoji based on <code>discount</code> value.</li>
<li>the <code>NameFormComponent</code> should be able to control <code>name</code> value</li>
<li>the <code>SelectCountryFormComponent</code> should be able to set the selected <code>country</code></li>
</ul>
<p>Considering that those components are not rendered in <code>Form</code> directly, but are children of <code>PersonalInfoSection</code>, time to do some prop drilling üòä</p>
<p><code>DiscountSituation</code> will accept <code>discount</code> as a prop:</p>
<pre><code class="language-tsx">export const DiscountSituation = ({ discount }: { discount: number }) =&gt; {
  // some code to calculate the situation based on discount
  const discountSituation = ...;
  return &lt;div&gt;Your discount situation: {discountSituation}&lt;/div&gt;;
};
</code></pre>
<p><code>NameFormComponent</code> will accept <code>name</code> and <code>onChange</code> callback:</p>
<pre><code class="language-tsx">export const NameFormComponent = ({ onChange, name }: { onChange: (val: string) =&gt; void; name: string }) =&gt; {
  return (
    &lt;div&gt;
      Type your name here: &lt;br /&gt;
      &lt;input onChange={() =&gt; onChange(e.target.value)} value={name} /&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p><code>SelectCountryFormComponent</code> will accept <code>onChange</code> callback:</p>
<pre><code class="language-tsx">export const SelectCountryFormComponent = ({ onChange }: { onChange: (country: Country) =&gt; void }) =&gt; {
  return &lt;SelectCountry onChange={onChange} /&gt;;
};
</code></pre>
<p>And our <code>PersonalInfoSection</code> would have to pass all of them from its parent <code>Form</code> component to its children:</p>
<pre><code class="language-tsx">export const PersonalInfoSection = ({
  onNameChange,
  onCountryChange,
  discount,
  name,
}: {
  onNameChange: (name: string) =&gt; void;
  onCountryChange: (name: Country) =&gt; void;
  discount: number;
  name: string;
}) =&gt; {
  return (
    &lt;Section title=&quot;Personal information&quot;&gt;
      &lt;DiscountSituation discount={discount} /&gt;
      &lt;NameFormComponent onChange={onNameChange} name={name} /&gt;
      &lt;SelectCountryFormComponent onChange={onCountryChange} /&gt;
    &lt;/Section&gt;
  );
};
</code></pre>
<p>And the same story with <code>ValueCalculationSection</code>: it needs to pass <code>onDiscountChange</code> and <code>discount</code> value from <code>Form</code> component to its child:</p>
<pre><code class="language-tsx">export const ValueCalculationsSection = ({ onDiscountChange }: { onDiscountChange: (val: number) =&gt; void }) =&gt; {
  console.info(&#x27;ValueCalculationsSection render&#x27;);
  return (
    &lt;Section title=&quot;Value calculation&quot;&gt;
      &lt;DiscountFormComponent onDiscountChange={onDiscountChange} /&gt;
    &lt;/Section&gt;
  );
};
</code></pre>
<p>And the <code>DiscountFormComponent</code> just uses the ‚Äúexternal‚Äù library <code>DraggingBar</code> to render the bar and catch the changes via the callback it gives:</p>
<pre><code class="language-tsx">export const DiscountFormComponent = ({ onDiscountChange }: { onDiscountChange: (value: number) =&gt; void }) =&gt; {
  console.info(&#x27;DiscountFormComponent render&#x27;);
  return (
    &lt;div&gt;
      Please select your discount here: &lt;br /&gt;
      &lt;DraggingBar onChange={(value: number) =&gt; onDiscountChange(value)} /&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>And, the render of our <code>Form</code> component would look like this:</p>
<pre><code class="language-tsx">const Form = () =&gt; {
  return (
    &lt;div&gt;
      &lt;PersonalInfoSection onNameChange={onNameChange} onCountryChange={onCountryChange} discount={state.discount} name={state.name} /&gt;
      &lt;ValueCalculationsSection onDiscountChange={onDiscountChange} /&gt;
      &lt;ActionsSection onSave={onSave} /&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>Quite a bit of code, but finally done üòÖ Want to take a look at the result? <a href="https://codesandbox.io/s/form-initial-implementation-uxw8v?file=/src/App.tsx">See the codesandbox.</a></p>
<p>Unfortunately, the result is much worst than you‚Äôd expect from a composition of a few components and a simple state üòï Try to type your name in the input, or drag the blue bar - both of them are lagging even on a fast laptop. With CPU throttling they are basically unusable. So, what happened?</p>
<h3>The form performance investigation</h3>
<p>First of all, let‚Äôs take a look at the console output there. If I type a single key in the <code>Name</code> input, I‚Äôll see:</p>
<pre><code>Form render
PersonalInfoSection render
Section render
Discount situation render
NameFormComponent render
SelectCountryFormComponent render
ValueCalculationsSection render
Section render
DiscountFormComponent render
ActionsSection render
Section render
</code></pre>
<p>Every single component in our form re-renders on every keystroke! And the same situation is with the dragging - on every mouse move the entire form and all its components re-renders themselves. And we already know, that our <code>SelectCountryFormComponent</code> is very slow, and there is nothing we can do with its performance. So the only thing that we can do here, is to make sure it doesn‚Äôt re-render on every keypress or mouse move.</p>
<p>And, as we know, components will re-render when:</p>
<ul>
<li>state of a component changed</li>
<li>parent component re-renders</li>
</ul>
<p>And this is exactly what is happening here: when the value in an input changes, we propagate this value up to the root <code>Form</code> component through our chain of callbacks, where we change the root state, which triggers re-render of the <code>Form</code> component, which then cascades down to every child and child of a child of this component (i.e. all of them).</p>
<p><img src="https://www.developerway.com/assets/how-to-write-performant-react-context/props-re-renders-flow.png" alt=""/></p>
<p>To fix it, we could, of course, sprinkle some <code>useMemo</code> and <code>useCallback</code> in strategic places and call it a day. But that just brushes the problem under the rug, not actually solving it. When in the future we introduce another slow component, the story will repeat itself. Not to mention that it will make the code much more complicated and harder to maintain. In the ideal world, when I type something in the <code>Name</code> component, I want only the <code>NameFormComponent</code> and components that actually use the <code>name</code> value to re-render, the rest should just sit idle there and wait for their turn to be interactive.</p>
<p>And React actually gives us a perfect tool to do that - <code>Context</code>!</p>
<h2>Adding Context to the form</h2>
<p>As per <a href="https://reactjs.org/docs/context.html">React docs</a>, context provides a way to pass data through the component tree without having to pass props down manually at every level. If, for example, we extract our Form state into Context, we can get rid of all the props we‚Äôve been passing through intermediate sections like <code>PersonalInfoSection</code> and use state directly in the <code>NameFormComponent</code> and <code>DiscountFormComponent</code>. The data flow then would look something like this:</p>
<p><img src="https://www.developerway.com/assets/how-to-write-performant-react-context/context-data-flow.png" alt=""/></p>
<p>To achieve this, first we‚Äôre creating the <code>Context</code> itself, which will have our state and the API to manage this state (i.e. our callbacks):</p>
<pre><code class="language-tsx">type State = {
  name: string;
  country: Country;
  discount: number;
};

type Context = {
  state: State;
  onNameChange: (name: string) =&gt; void;
  onCountryChange: (name: Country) =&gt; void;
  onDiscountChange: (price: number) =&gt; void;
  onSave: () =&gt; void;
};

const FormContext = createContext&lt;Context&gt;({} as Context);
</code></pre>
<p>Then we should move all the state logic, that we had in <code>Form</code>, in the <code>FormDataProvider</code> component, and attach the state and callbacks to the newly created <code>Context</code>:</p>
<pre><code class="language-tsx">export const FormDataProvider = ({ children }: { children: ReactNode }) =&gt; {
  const [state, setState] = useState&lt;State&gt;({} as State);

  const value = useMemo(() =&gt; {
    const onSave = () =&gt; {
      // send the request to the backend here
    };

    const onDiscountChange = (discount: number) =&gt; {
      setState({ ...state, discount });
    };

    const onNameChange = (name: string) =&gt; {
      setState({ ...state, name });
    };

    const onCountryChange = (country: Country) =&gt; {
      setState({ ...state, country });
    };

    return {
      state,
      onSave,
      onDiscountChange,
      onNameChange,
      onCountryChange,
    };
  }, [state]);

  return &lt;FormContext.Provider value={value}&gt;{children}&lt;/FormContext.Provider&gt;;
};
</code></pre>
<p>Then expose the hook for other components to use this Context without accessing it directly:</p>
<pre><code class="language-tsx">export const useFormState = () =&gt; useContext(FormContext);
</code></pre>
<p>And wrap our <code>Form</code> component into the <code>FormDataProvider</code>:</p>
<pre><code class="language-tsx">export default function App() {
  return (
    &lt;FormDataProvider&gt;
      &lt;Form /&gt;
    &lt;/FormDataProvider&gt;
  );
}
</code></pre>
<p>After that, we can get rid of <strong>all the props</strong> throughout the app, and use the required data and callbacks directly in the components where it‚Äôs needed via <code>useFormState</code> hook.</p>
<p>For example, our root <code>Form</code> component will turn into just this:</p>
<pre><code class="language-tsx">const Form = () =&gt; {
  // no more props anywhere!
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;PersonalInfoSection /&gt;
      &lt;ValueCalculationsSection /&gt;
      &lt;ActionsSection /&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>And <code>NameFormComponent</code> will be able to access all the data like this:</p>
<pre><code class="language-tsx">export const NameFormComponent = () =&gt; {
  // accessing the data directly right where it&#x27;s needed!
  const { onNameChange, state } = useFormState();

  const onValueChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    onNameChange(e.target.value);
  };

  return (
    &lt;div&gt;
      Type your name here: &lt;br /&gt;
      &lt;input onChange={onValueChange} value={state.name} /&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>Take a look at the full code in <a href="https://codesandbox.io/s/form-implementation-with-context-2-3wd2i?file=/src/App.tsx">this codesandbox</a>. Don‚Äôt forget to appreciate how clean it looks now when there is no more mess of props everywhere!</p>
<h3>What about the performance of the new form?</h3>
<p>From the performance perspective we‚Äôre still not there yet: typing the name and dragging the bar is still lagging. But if I start typing in the <code>NameFormComponent</code>, in the console I will now see this:</p>
<pre><code>Discount situation render
NameFormComponent render
SelectCountryFormComponent render
DiscountFormComponent render
ActionsSection render
Section render
</code></pre>
<p>Half of the components now don‚Äôt re-render, including our parent <code>Form</code> component. This is happening because of how Context works: when a Context value changes, <strong>every consumer of this context will re-render</strong>, regardless of whether they use the changed value or not. But also, those components that are bypassed by Context won‚Äôt be re-rendering at all. Our re-renders flow now looks like this:</p>
<p><img src="https://www.developerway.com/assets/how-to-write-performant-react-context/context-re-renders-flow.png" alt=""/></p>
<p>And now, if we look closely at our components implementation, in particular <code>SelectCountryComponent</code>, which is the wrapper around the slow ‚Äúexternal‚Äù component, we‚Äôll see that it doesn‚Äôt actually use the <code>state</code> itself. All it needs is the <code>onCountryChange</code> callback:</p>
<pre><code class="language-tsx">export const SelectCountryFormComponent = () =&gt; {
  const { onCountryChange } = useFormState();
  console.info(&#x27;SelectCountryFormComponent render&#x27;);

  return &lt;SelectCountry onChange={onCountryChange} /&gt;;
};
</code></pre>
<p>And this gives us an opportunity to try out a really cool trick: we can split the <code>state</code> part and the <code>API</code> part under our <code>FormDataProvider</code>.</p>
<h2>Splitting the state and the API</h2>
<p>Basically, what we want to do here is to decompose our ‚Äúmonolith‚Äù state into two ‚Äúmicrostates‚Äù üòÖ.</p>
<p>Instead of one context that has everything we‚Äôd need 2 contexts, one for data, one for API:</p>
<pre><code class="language-tsx">type State = {
  name: string;
  country: Country;
  discount: number;
};

type API = {
  onNameChange: (name: string) =&gt; void;
  onCountryChange: (name: Country) =&gt; void;
  onDiscountChange: (price: number) =&gt; void;
  onSave: () =&gt; void;
};

const FormDataContext = createContext&lt;State&gt;({} as State);
const FormAPIContext = createContext&lt;API&gt;({} as API);
</code></pre>
<p>Instead of one context provider in our <code>FormDataProvider</code> component, we‚Äôd again have two, where we‚Äôd pass our state directly to the <code>FormDataContext.Provider</code>:</p>
<pre><code class="language-tsx">const FormDataProvider = () =&gt; {
  // state logic

  return (
    &lt;FormAPIContext.Provider value={api}&gt;
      &lt;FormDataContext.Provider value={state}&gt;{children}&lt;/FormDataContext.Provider&gt;
    &lt;/FormAPIContext.Provider&gt;
  );
};
</code></pre>
<p>And now the most interesting part, the <code>api</code> value.</p>
<p>If we just leave it as it was before, the whole ‚Äúdecomposition‚Äù idea is not going to work because we still would have to rely on the <code>state</code> as a dependency in the <code>useMemo</code> hook:</p>
<pre><code class="language-tsx">const api = useMemo(() =&gt; {
  const onDiscountChange = (discount: number) =&gt; {
    // this is why we still need state here - in order to update it
    setState({ ...state, discount });
  };

  // all other callbacks

  return { onSave, onDiscountChange, onNameChange, onCountryChange };
  // still have state as a dependency
}, [state]);
</code></pre>
<p>This will result in the <code>api</code> value changing with every state update, which would lead to the <code>FormAPIContext</code> triggering re-renders on every state update, which would make our split useless. We want our <code>api</code> to stay constant regardless of the <code>state</code>, so that consumers of this provider don&#x27;t re-render.</p>
<p>Fortunately, there is another neat trick that we can apply here: we can extract our state into a reducer and instead of calling <code>setState</code> in the callback we would just trigger a reducer action.</p>
<p>First, create actions and reducer itself:</p>
<pre><code class="language-tsx">type Actions =
  | { type: &#x27;updateName&#x27;; name: string }
  | { type: &#x27;updateCountry&#x27;; country: Country }
  | { type: &#x27;updateDiscount&#x27;; discount: number };

const reducer = (state: State, action: Actions): State =&gt; {
  switch (action.type) {
    case &#x27;updateName&#x27;:
      return { ...state, name: action.name };
    case &#x27;updateDiscount&#x27;:
      return { ...state, discount: action.discount };
    case &#x27;updateCountry&#x27;:
      return { ...state, country: action.country };
  }
};
</code></pre>
<p>Use reducer instead of <code>useState</code>:</p>
<pre><code class="language-tsx">export const FormProvider = ({ children }: { children: ReactNode }) =&gt; {
  const [state, dispatch] = useReducer(reducer, {} as State);
  // ...
};
</code></pre>
<p>And migrate our <code>api</code> to <code>dispatch</code> instead of <code>setState</code>:</p>
<pre><code class="language-tsx">const api = useMemo(() =&gt; {
  const onSave = () =&gt; {
    // send the request to the backend here
  };

  const onDiscountChange = (discount: number) =&gt; {
    dispatch({ type: &#x27;updateDiscount&#x27;, discount });
  };

  const onNameChange = (name: string) =&gt; {
    dispatch({ type: &#x27;updateName&#x27;, name });
  };

  const onCountryChange = (country: Country) =&gt; {
    dispatch({ type: &#x27;updateCountry&#x27;, country });
  };

  return { onSave, onDiscountChange, onNameChange, onCountryChange };
  // no more dependency on state! The api value will stay the same
}, []);
</code></pre>
<p>And the final step: don‚Äôt forget to migrate all the components that used <code>useFormState</code> to <code>useFormData</code> and <code>useFormAPI</code>. For example, our <code>SelectCountryFormComponent</code> will use <code>onCountryChange</code> from the <code>useFormAPI</code> hook, and will never re-render on the state change.</p>
<pre><code class="language-tsx">export const SelectCountryFormComponent = () =&gt; {
  const { onCountryChange } = useFormAPI();

  return &lt;SelectCountry onChange={onCountryChange} /&gt;;
};
</code></pre>
<p>Take a look at the full implementation in <a href="https://codesandbox.io/s/form-implementation-split-api-2-g9q3e?file=/src/App.tsx">this codesandbox.</a> The typing and dragging bar are blazing fast now, and the only console output we‚Äôd see when we type something is this:</p>
<pre><code>Discount situation render
NameFormComponent render
</code></pre>
<p>Only two components, since only those two use the actual state data. üéâ</p>
<h2>Splitting state even further</h2>
<p>Now, people with good design eyes or just careful readers might notice that I cheated a little bit. We don‚Äôt pass the selected country to our ‚Äúexternal‚Äù <code>SelectCountry</code> component, and it&#x27;s stuck on the very first item in the list. In reality, the selected ‚Äúlilac‚Äù color should move to the country you click on. And the component actually allows us to pass it via <code>activeCountry</code>. Technically, I can do it as simple as that:</p>
<pre><code class="language-tsx">export const SelectCountryFormComponent = () =&gt; {
  const { onCountryChange } = useFormAPI();
  const { country } = useFormData();

  return &lt;SelectCountry onChange={onCountryChange} activeCountry={country} /&gt;;
};
</code></pre>
<p>There is one problem with it though - as soon as I use <code>useFormData</code> hook in a component, it will start re-rendering with the state changes, same as <code>NameFormComponent</code>. Which in our case means we‚Äôll be back to the laggy experience on typing and dragging.</p>
<p>But now, since we already know how to split the data between different providers, nothing stops us from taking this to the next level and just splitting the rest of the state as well. Moar providers! üòÖ</p>
<p>Instead of one unified context for <code>State</code> we‚Äôll have three now:</p>
<pre><code class="language-tsx">const FormNameContext = createContext&lt;State[&#x27;name&#x27;]&gt;({} as State[&#x27;name&#x27;]);
const FormCountryContext = createContext&lt;State[&#x27;country&#x27;]&gt;({} as State[&#x27;country&#x27;]);
const FormDiscountContext = createContext&lt;State[&#x27;discount&#x27;]&gt;({} as State[&#x27;discount&#x27;]);
</code></pre>
<p>Three state providers:</p>
<pre><code class="language-tsx">&lt;FormAPIContext.Provider value={api}&gt;
  &lt;FormNameContext.Provider value={state.name}&gt;
    &lt;FormCountryContext.Provider value={state.country}&gt;
      &lt;FormDiscountContext.Provider value={state.discount}&gt;{children}&lt;/FormDiscountContext.Provider&gt;
    &lt;/FormCountryContext.Provider&gt;
  &lt;/FormNameContext.Provider&gt;
&lt;/FormAPIContext.Provider&gt;
</code></pre>
<p>And three hooks to use the state:</p>
<pre><code class="language-tsx">export const useFormName = () =&gt; useContext(FormNameContext);
export const useFormCountry = () =&gt; useContext(FormCountryContext);
export const useFormDiscount = () =&gt; useContext(FormDiscountContext);
</code></pre>
<p>And now in our <code>SelectCountryFormComponent</code> we can use <code>useFormCountry</code> hook, and it will not be re-rendering on any changes other than country itself:</p>
<pre><code class="language-tsx">export const SelectCountryFormComponent = () =&gt; {
  const { onCountryChange } = useFormAPI();
  const country = useFormCountry();

  return &lt;SelectCountry onChange={onCountryChange} activeCountry={country} /&gt;;
};
</code></pre>
<p>Check this out <a href="https://codesandbox.io/s/form-implementation-split-api-and-state-0tvq0?file=/src/App.tsx">in codesandbox</a>: it‚Äôs still fast, and country is selectable. And the only thing we‚Äôll see in console output when we type something in the name input is:</p>
<pre><code>NameFormComponent render
</code></pre>
<h2>Bonus: external state management</h2>
<p>Now, the question of whether this form‚Äôs state should‚Äôve been implemented with some state management library right away might cross some of your minds. And you‚Äôre maybe right. After all, if we look closely at the code, we just re-invented the wheel and implemented a rudimentary state management library, with selectors-like functionality for the state and separate actions to change that state.</p>
<p>But now you have <em>a choice</em>. Context is not a mystery anymore, with those techniques you can easily write performant apps with just pure Context if there is a need, and if you want to transition to any other framework, you can do it with minimal changes to the code. State management framework <strong>doesn‚Äôt really matter</strong> when you design your apps with Context in mind.</p>
<p>We might as well move it to the good old Redux right now. The only things we‚Äôd need to do are: get rid of Context and Providers, convert React reducer to Redux store, and convert our hooks to use Redux selectors and dispatch.</p>
<pre><code class="language-tsx">const store = createStore((state = {}, action) =&gt; {
  switch (action.type) {
    case &#x27;updateName&#x27;:
      return { ...state, name: action.payload };
    case &#x27;updateCountry&#x27;:
      return { ...state, country: action.payload };
    case &#x27;updateDiscount&#x27;:
      return { ...state, discount: action.payload };
    default:
      return state;
  }
});

export const FormDataProvider = ({ children }: { children: ReactNode }) =&gt; {
  return &lt;Provider store={store}&gt;{children}&lt;/Provider&gt;;
};

export const useFormDiscount = () =&gt; useSelector((state) =&gt; state.discount);
export const useFormCountry = () =&gt; useSelector((state) =&gt; state.country);
export const useFormName = () =&gt; useSelector((state) =&gt; state.name);

export const useFormAPI = () =&gt; {
  const dispatch = useDispatch();

  return {
    onCountryChange: (value) =&gt; {
      dispatch({ type: &#x27;updateCountry&#x27;, payload: value });
    },
    onDiscountChange: (value) =&gt; dispatch({ type: &#x27;updateDiscount&#x27;, payload: value }),
    onNameChange: (value) =&gt; dispatch({ type: &#x27;updateName&#x27;, payload: value }),
    onSave: () =&gt; {},
  };
};
</code></pre>
<p>Everything else stays the same and works exactly as we designed. <a href="https://codesandbox.io/s/form-implementation-redux-2-t5w30?file=/src/form-api.tsx">See the codesandbox.</a></p>
<p>That is all for today, hope now <code>Context</code> is not the source of mysterious spontaneous re-renders in your app, but a solid tool in your arsenal of writing performant React code ‚úåüèº</p>]]></content:encoded>
      <enclosure
        url="https://www.developerway.com//assets/how-to-write-performant-react-context/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title><![CDATA[Why custom react hooks could destroy your app performance]]></title>
      <link>
        https://www.developerway.com/posts/why-custom-react-hooks-could-destroy-your-app-performance
      </link>
      <guid>why-custom-react-hooks-could-destroy-your-app-performance</guid>
      <pubDate>Mon, 24 Jan 2022 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Exploring performance implications of custom React hooks and how not to shoot yourself in the foot when writing or using them.]]></description>
      <content:encoded><![CDATA[<p>Scary title, isn‚Äôt it? The sad part is that it‚Äôs true: for performance-sensitive apps custom React hooks can very easily turn into the biggest performance killer, if not written and used very carefully.</p>
<p>I‚Äôm not going to explain how to build and use hooks here, if you never built a hook before, the React docs have a <a href="https://reactjs.org/docs/hooks-custom.html">pretty good introduction</a> into it. What I want to focus on today is their performance implication for complicated apps.</p>
<h2>Let‚Äôs build a modal dialog on custom hooks</h2>
<p>Essentially, hooks are just advanced functions that allow developers to use things like state and context without creating new components. They are super useful when you need to share the same piece of logic that needs state between different parts of the app. With hooks came a new era in React development: never before our components were as slim and neat as with hooks, and separation of different concerns was as easy to achieve as with hooks.</p>
<p>Let‚Äôs for example, implement a modal dialog. With custom hooks, we can create a piece of beauty here.</p>
<p>First, let‚Äôs implement a ‚Äúbase‚Äù component, that doesn‚Äôt have any state, but just renders the dialog when <code>isOpen</code> prop is provided and triggers <code>onClose</code> callback when a click on a blanket underneath the dialog happens.</p>
<pre><code class="language-tsx">type ModalProps = {
  isOpen: boolean;
  onClosed: () =&gt; void;
};

export const ModalBase = ({ isOpen, onClosed }: ModalProps) =&gt; {
  return isOpen ? (
    &lt;&gt;
      &lt;div css={modalBlanketCss} onClick={onClosed} /&gt;
      &lt;div css={modalBodyCss}&gt;Modal dialog content&lt;/div&gt;
    &lt;/&gt;
  ) : null;
};
</code></pre>
<p>Now to the state management, i.e. the ‚Äúopen dialog/close dialog‚Äù logic. In the ‚Äúold‚Äù way we would usually implement a ‚Äúsmart‚Äù version of it, which handles the state management and accepts a component that is supposed to trigger the opening of the dialog as a prop. Something like this:</p>
<pre><code class="language-tsx">export const ModalDialog = ({ trigger }) =&gt; {
  const [isOpen, setIsOpen] = useState(false);

  return (
    &lt;&gt;
      &lt;div onClick={() =&gt; setIsOpen(true)}&gt;{trigger}&lt;/div&gt;
      &lt;ModalBase isOpen={isOpen} onClosed={() =&gt; setIsOpen(false)} /&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>Which then will be used like this:</p>
<pre><code class="language-tsx">&lt;ModalDialog trigger={&lt;button&gt;Click me&lt;/button&gt;} /&gt;
</code></pre>
<p>This is not a particularly pretty solution, we‚Äôre messing with the position and accessibility of the trigger component inside our modal dialog by wrapping it in a div. Not to mention that this unnecessary div will result in a slightly larger and messier DOM.</p>
<p>And now watch the magic. If we extract the ‚Äúopen/close‚Äù logic into a custom hook, render this component <strong>inside</strong> the hook, and expose API to control it as a return value from the hook, we can have the best of both worlds. In the hook we‚Äôll have the ‚Äúsmart‚Äù dialog that handles its own state, but doesn‚Äôt mess with the trigger nor does it need one:</p>
<pre><code class="language-tsx">export const useModal = () =&gt; {
  const [isOpen, setIsOpen] = useState(false);

  const open = () =&gt; setIsOpen(true);
  const close = () =&gt; setIsOpen(false);
  const Dialog = () =&gt; &lt;ModalBase onClosed={close} isOpen={isOpen} /&gt;;

  return { isOpen, Dialog, open, close };
};
</code></pre>
<p>And on the consumer side we‚Äôll have a minimal amount of code while having the full control over what triggers the dialog:</p>
<pre><code class="language-tsx">const ConsumerComponent = () =&gt; {
  const { Dialog, open } = useModal();

  return (
    &lt;&gt;
      &lt;button onClick={open}&gt;Click me&lt;/button&gt;
      &lt;Dialog /&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>If this isn‚Äôt perfection, I don‚Äôt know what is! üòç <a href="https://codesandbox.io/s/modal-dialog-example1-9ds2c?file=/src/App.tsx">See this beauty in codesandbox</a>. Only don‚Äôt rush to use it in your apps right away, not until you read about its dark side üòÖ</p>
<h2>Performance implications</h2>
<p>In the <a href="/posts/how-to-write-performant-react-code">previous article</a>, where I covered in detail various patterns that lead to poor performance, I implemented a ‚Äúslow‚Äù app: just a simple not optimized list of ~250 countries rendered on the page. But every interaction there causes the entire page to re-render, which makes it probably the slowest simple list ever existed.  <a href="https://codesandbox.io/s/re-renders-final-bad-4znwe">Here is the codesandbox</a>, click on different countries in the list to see what I mean (if you‚Äôre on the latest Mac throttle your CPU a bit to get a better impression).</p>
<p><b>How to throttle CPU</b>: in Chrome developer tools open ‚ÄúPerformance‚Äù tab, and click on the ‚Äúcog wheel‚Äù icon in the top right corner - it
will open a small additional panel with throttling options.</p>
<p>I‚Äôm going to use our new perfect modal dialog there and see what happens. The code of the main <code>Page</code> component is relatively simple and looks like this:</p>
<pre><code class="language-tsx">export const Page = ({ countries }: { countries: Country[] }) =&gt; {
  const [selectedCountry, setSelectedCountry] = useState&lt;Country&gt;(countries[0]);
  const [savedCountry, setSavedCountry] = useState&lt;Country&gt;(countries[0]);
  const [mode, setMode] = useState&lt;Mode&gt;(&#x27;light&#x27;);

  return (
    &lt;ThemeProvider value={{ mode }}&gt;
      &lt;h1&gt;Country settings&lt;/h1&gt;
      &lt;button onClick={() =&gt; setMode(mode === &#x27;light&#x27; ? &#x27;dark&#x27; : &#x27;light&#x27;)}&gt;Toggle theme&lt;/button&gt;
      &lt;div className=&quot;content&quot;&gt;
        &lt;CountriesList countries={countries} onCountryChanged={(c) =&gt; setSelectedCountry(c)} savedCountry={savedCountry} /&gt;
        &lt;SelectedCountry country={selectedCountry} onCountrySaved={() =&gt; setSavedCountry(selectedCountry)} /&gt;
      &lt;/div&gt;
    &lt;/ThemeProvider&gt;
  );
};
</code></pre>
<p>And now I need a button near the ‚ÄúToggle theme‚Äù button that would open a modal dialog with some future additional settings for this page. Luckily, now it can‚Äôt be simpler: add <code>useModal</code> hook at the top, add the button where it needs to be, and pass <code>open</code> callback to the button. The <code>Page</code> component barely changes and is still quite simple:</p>
<p><img src="https://www.developerway.com/assets/react-custom-hooks-performance/example-dialog-code.png" alt=""/></p>
<p>You probably already guessed the result üôÇ The slowest appearance of 2 empty divs ever existed üò±. <a href="https://codesandbox.io/s/re-renders-bad-with-dialog-6egnq?file=/src/country-settings/page.tsx">See the codesandbox.</a></p>
<p>You see, what is happening here, is our <code>useModal</code> hook uses state. And as we know, state changes are one of the reasons why a component would re-render itself. This also applies to hooks - if the hook&#x27;s state changes, the &quot;host&quot; component will re-render. And it makes total sense. If we look closely inside <code>useModal</code> hook, we‚Äôll see that it‚Äôs just a nice abstraction around <code>setState</code>, it exists <strong>outside</strong> of the <code>Dialog</code> component. Essentially it‚Äôs no different than calling <code>setState</code> in the <code>Page</code> component directly.</p>
<p>And this is where the big danger of hooks is: yes, they help us make the API really nice. But what we did as a result, and the way of hooks is pretty much encouraging it, is essentially <strong>lifted state up</strong> from where it was supposed to be. And it‚Äôs entirely not noticeable unless you go inside the <code>useModal</code> implementation or have lots of experience with hooks and re-renders. I‚Äôm not even using the state directly in <code>Page</code> component, all I&#x27;m doing from its perspective is rendering a <code>Dialog</code> component and calling an imperative API to open it.</p>
<p>In the ‚Äúold world‚Äù, the state would‚Äôve been encapsulated in the slightly ugly <code>Modal</code> dialog with the <code>trigger</code> prop, and the <code>Page</code> component would‚Äôve stayed intact when the button is clicked. Now the click on the button changes the state of <strong>the entire Page component</strong>, which causes it to re-render (which is super slow for this app). And the dialog can only appear when React is done with all the re-renders it caused, hence the big delay.</p>
<p><img src="https://www.developerway.com/assets/react-custom-hooks-performance/state-of-state-diagram.png" alt=""/></p>
<p>So, what can we do about it? We probably won‚Äôt have time and resources to fix the underlying performance of the <code>Page</code> component, as it would usually happen with the ‚Äúreal‚Äù apps. But at least we can make sure that the new feature doesn‚Äôt add to the performance problems and is fast by itself. All that we need to do here is just move the modal state ‚Äúdown‚Äù, away from the slow <code>Page</code> component:</p>
<pre><code class="language-tsx">const SettingsButton = () =&gt; {
  const { Dialog, open } = useModal();

  return (
    &lt;&gt;
      &lt;button onClick={open}&gt;Open settings&lt;/button&gt;
      &lt;Dialog /&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>And in <code>Page</code> just render the <code>SettingsButton</code>:</p>
<pre><code class="language-tsx">export const Page = ({ countries }: { countries: Country[] }) =&gt; {
  // same as original page state
  return (
    &lt;ThemeProvider value={{ mode }}&gt;
      // stays the same
      &lt;SettingsButton /&gt;
      // stays the same
    &lt;/ThemeProvider&gt;
  );
};
</code></pre>
<p>Now, when the button is clicked, only <code>SettingsButton</code> component will re-render, the slow <code>Page</code> component is unaffected. Essentially, we‚Äôre imitating the state model as it would‚Äôve been in the ‚Äúold‚Äù world while preserving the nice hooks-based API. See the <a href="https://codesandbox.io/s/re-renders-bad-with-dialog-fixed-rrfey?file=/src/country-settings/page.tsx">codesandbox</a> with the solution.</p>
<p><img src="https://www.developerway.com/assets/react-custom-hooks-performance/state-of-state-diagram-fixed.png" alt=""/></p>
<h2>Adding more functionality to the <code>useModal</code> hook</h2>
<p>Let‚Äôs make our hooks performance conversation slightly darker üôÇ. Imagine, for example, you need to track the scroll event in the modal content. Maybe you want to send some analytics events when the users scroll through the text, to track reads. What will happen if I don‚Äôt want to introduce ‚Äúsmart‚Äù functionality to the <code>BaseModal</code> and do it in the <code>useModal</code> hook?</p>
<p>Relatively easy to achieve. We can just introduce a new state there to track scroll position, add event listeners in <code>useEffect</code> hook and pass ref to the <code>BaseModal</code> to get the content element to attach the listeners to. Something like this:</p>
<pre><code class="language-tsx">export const ModalBase = React.forwardRef(({ isOpen, onClosed }: ModalProps, ref: RefObject&lt;any&gt;) =&gt; {
  return isOpen ? (
    &lt;&gt;
      &lt;div css={modalBlanketCss} onClick={onClosed} /&gt;
      &lt;div css={modalBodyCss} ref={ref}&gt;
        // add a lot of content here
      &lt;/div&gt;
    &lt;/&gt;
  ) : null;
});

export const useModal = () =&gt; {
  const [isOpen, setIsOpen] = useState(false);
  const ref = useRef&lt;HTMLElement&gt;(null);
  const [scroll, setScroll] = useState(0);

  // same as before

  useEffect(() =&gt; {
    const element = ref.current;
    if (!element) return;

    const handleScroll = () =&gt; {
      setScroll(element?.scrollTop || 0);
    };

    element.addEventListener(&#x27;scroll&#x27;, handleScroll);
    return () =&gt; {
      element.removeEventListener(&#x27;scroll&#x27;, handleScroll);
    };
  });

  const Dialog = () =&gt; &lt;ModalBase onClosed={close} isOpen={isOpen} ref={ref} /&gt;;

  return {
    isOpen,
    Dialog,
    open,
    close,
  };
};
</code></pre>
<p>And now we can do whatever with this state. Now let‚Äôs pretend that the previous performance problems are not that big of a deal, and use again this hook directly in the slow Page component. <a href="https://codesandbox.io/s/re-renders-bad-with-dialog-with-scroll-p9wi8?file=/src/country-settings/page.tsx">See codesandbox</a>.</p>
<p>The scrolling doesn‚Äôt even work properly! üò± Every time I try to scroll the dialog content it resets to the top!</p>
<p>Okay, let‚Äôs think logically. <a href="/posts/how-to-write-performant-react-code">We know already</a>, that creating components inside render functions is evil, since React will re-create and re-mount them on every re-render. And we know that hooks change with every state change. That means now, when we introduced scroll state, on every scroll change we‚Äôre changing state, which causes the hook to re-render, which causes <code>Dialog</code> component to re-create itself. Exactly the same problem, as with creating components inside render functions, with exactly the same fix: we need to extract this component outside of the hook or just memoise it.</p>
<pre><code class="language-tsx">const Dialog = useMemo(() =&gt; {
  return () =&gt; &lt;ModalBase onClosed={close} isOpen={isOpen} ref={ref} /&gt;;
}, [isOpen]);
</code></pre>
<p>The focus behaviour is fixed, but there is another problem here: the slow <code>Page</code> component re-renders on every scroll! That one is a bit hard to notice since the dialog content is just text. Try, for example, to reduce the CPU by 6x, scroll, and then just highlight the text in the dialog right away. The browser won‚Äôt even allow that, since it‚Äôs too busy with re-renders of the underneath <code>Page</code> component! <a href="https://codesandbox.io/s/re-renders-bad-with-dialog-with-scroll-fixed-scroll-0s5g3?file=/src/country-settings/page.tsx">See the codesandbox.</a> And after a few scrolls, your laptop will probably try to take off to the Moon due to 100% CPU load üòÖ</p>
<p>Yeah, we definitely need to fix that before releasing it to production. Let‚Äôs take another look at our component, especially at this part:</p>
<pre><code class="language-tsx">return {
  isOpen,
  Dialog,
  open,
  close,
};
</code></pre>
<p>We‚Äôre returning a new object on every re-render, and since we re-render our hook on every scroll now, that means that object changes on every scroll as well. But we‚Äôre not using the scroll state here, it‚Äôs entirely internal for the <code>useModal</code> hook. Surely just memoising that object will solve the problem?</p>
<pre><code class="language-tsx">return useMemo(
  () =&gt; ({
    isOpen,
    Dialog,
    open,
    close,
  }),
  [isOpen, Dialog],
);
</code></pre>
<p>You know the best (or the scariest) part of this? IT DIDN‚ÄôT! üò± <a href="https://codesandbox.io/s/re-renders-bad-with-dialog-with-scroll-fixed-scroll-and-memo-35lqx?file=/src/country-settings/modal-dialog.tsx">See the codesandbox</a>.</p>
<p>And this is another huge performance-related bummer with hooks. Turns out, it doesn‚Äôt really matter, whether the state change in hooks is ‚Äúinternal‚Äù or not. <strong>Every state change in a hook, whether it affects its return value or not, will cause the ‚Äúhost‚Äù component to re-render.</strong></p>
<p>And of course exactly the same story with chaining hooks: if a hook‚Äôs state changes, it will cause its ‚Äúhost‚Äù hook change as well, which will propagate up through the whole chain of hooks until it reaches the ‚Äúhost‚Äù component and re-renders it (which will cause another chain reaction of re-renders, only downstream now), <strong>regardless of any memoisation</strong> applied in between.</p>
<p>Extracting the ‚Äúscrolling‚Äù functionality into a hook will make absolutely no difference, the slow Page component will re-render üòî.</p>
<pre><code class="language-tsx">const useScroll = (ref: RefObject) =&gt; {
  const [scroll, setScroll] = useState(0);

  useEffect(() =&gt; {
    const element = ref.current;
    if (!element) return;

    const handleScroll = () =&gt; {
      setScroll(element?.scrollTop || 0);
    };

    element.addEventListener(&#x27;scroll&#x27;, handleScroll);
    return () =&gt; {
      element.removeEventListener(&#x27;scroll&#x27;, handleScroll);
    };
  });

  return scroll;
};

export const useModal = () =&gt; {
  const [isOpen, setIsOpen] = useState(false);
  const ref = useRef&lt;HTMLElement&gt;(null);
  const scroll = useScroll(ref);

  const open = useCallback(() =&gt; {
    setIsOpen(true);
  }, []);

  const close = useCallback(() =&gt; {
    setIsOpen(false);
  }, []);

  const Dialog = useMemo(() =&gt; {
    return () =&gt; &lt;ModalBase onClosed={close} isOpen={isOpen} ref={ref} /&gt;;
  }, [isOpen, close]);

  return useMemo(
    () =&gt; ({
      isOpen,
      Dialog,
      open,
      close,
    }),
    [isOpen, Dialog, open, close],
  );
};
</code></pre>
<p><a href="https://codesandbox.io/s/re-renders-bad-with-dialog-with-scroll-extracted-woeer?file=/src/country-settings/modal-dialog.tsx">See the codesandbox</a>.</p>
<p>How to fix it? Well, the only thing to do here is to move the scroll tracking hook outside of the <code>useModal</code> hook and use it somewhere where it won‚Äôt cause the chain of re-renders. Can introduce <code>ModalBaseWithAnalytics</code> component for example:</p>
<pre><code class="language-tsx">const ModalBaseWithAnalytics = (props: ModalProps) =&gt; {
  const ref = useRef&lt;HTMLElement&gt;(null);
  const scroll = useScroll(ref);

  console.log(scroll);

  return &lt;ModalBase {...props} ref={ref} /&gt;;
};
</code></pre>
<p>And then use it in the <code>useModal</code> hook instead of the <code>ModalBase</code>:</p>
<pre><code class="language-tsx">export const useModal = () =&gt; {
  // the rest is the same as in the original useModal hook

  const Dialog = useMemo(() =&gt; {
    return () =&gt; &lt;ModalBaseWithAnalytics onClosed={close} isOpen={isOpen} ref={ref} /&gt;;
  }, [isOpen, close]);

  return useMemo(
    () =&gt; ({
      isOpen,
      Dialog,
      open,
      close,
    }),
    [isOpen, Dialog, open, close],
  );
};
</code></pre>
<p>Now the state changes due to the scrolling will be scoped to the <code>ModalBaseWithAnalytics</code> component and won‚Äôt affect the slow <code>Page</code> component. <a href="https://codesandbox.io/s/re-renders-bad-with-dialog-scroll-fixed-for-good-v6ohp?file=/src/country-settings/modal-dialog.tsx">See the codesandbox.</a></p>
<p>That is all for today! Hope this article <s>scared you enough</s> helped you to feel more comfortable with custom hooks and how to write and use them without compromising the performance of your apps. Let‚Äôs recap the rules of performant hooks before leaving:</p>
<ul>
<li>every state change in a hook will cause its ‚Äúhost‚Äù component to re-render, regardless of whether this state is returned in the hook value and memoised or not</li>
<li>the same with chained hooks, every state change in a hook will cause all ‚Äúparent‚Äù hooks to change until it reaches the ‚Äúhost‚Äù component, which again will trigger the re-render</li>
</ul>
<p>And the things to watch out for, when writing or using custom hooks:</p>
<ul>
<li>when using a custom hook, make sure that the state that this hook encapsulates is not used on the level it wouldn‚Äôt have been used with the components approach. Move it ‚Äúdown‚Äù to a smaller component if necessary</li>
<li>never implement ‚Äúindependent‚Äù state in a hook or use hooks with the independent state</li>
<li>when using a custom hook, make sure it doesn‚Äôt perform some independent state operations, that are not exposed in its return value</li>
<li>when using a custom hook, make sure that all hooks that it uses also follow the rules from the above</li>
</ul>
<p>Stay safe and may your apps be blazing fast from now on! ‚úåüèº</p>]]></content:encoded>
      <enclosure
        url="https://www.developerway.com//assets/react-custom-hooks-performance/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title>
        <![CDATA[How to write performant React code: rules, patterns, do's and don'ts]]></title>
      <link>https://www.developerway.com/posts/how-to-write-performant-react-code</link>
      <guid>how-to-write-performant-react-code</guid>
      <pubDate>Sun, 09 Jan 2022 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Looking into patterns that lead to poor performance of React apps, why they are bad, and how to recognise and avoid them.]]></description>
      <content:encoded><![CDATA[<p>Performance and React! Such a fun topic with so many controversial opinions and so many best practices flipping to be the opposite in just 6 months. Is it even possible to say anything definitive here or to make any generalized recommendations?</p>
<p>Usually, performance experts are the proponents of ‚Äúpremature optimisation is the root of all evil‚Äù and ‚Äúmeasure first‚Äù rules. Which loosely translates into ‚Äúdon‚Äôt fix that is not broken‚Äù and is quite hard to argue with. But I‚Äôm going to anyway üòâ</p>
<p>What I like about React, is that it makes implementing complicated UI interactions incredibly easy. What I don‚Äôt like about React, is that it also makes it incredibly easy to make mistakes with huge consequences that are not visible right away. The good news is, it‚Äôs also incredibly easy to prevent those mistakes and write code that is performant most of the time right away, thus significantly reducing the time and effort it takes to investigate performance problems since there will be much fewer of those. Basically, ‚Äúpremature optimisation‚Äù, when it comes to React and performance, can actually be a good thing and something that everyone should do üòâ. You just need to know a few patterns to watch out for in order to do that meaningfully.</p>
<p>So this is exactly what I want to prove in this article üòä. I‚Äôm going to do that by implementing a ‚Äúreal-life‚Äù app step by step, first in a ‚Äúnormal‚Äù way, using the patterns that you‚Äôll see practically everywhere and surely used multiple times by yourself. And then refactor each step with performance in mind, and extract a generalized rule from every step that can be applied to most apps most of the time. And then compare the result in the end.</p>
<p>Let‚Äôs begin!</p>
<p>We are going to write one of the ‚Äúsettings‚Äù page for an online shop (that we introduced into the previous ‚ÄúAdvanced typescript for React developers‚Äù articles). On this page, users will be able to select a country from the list, see all the information available for this country (like currency, delivery methods, etc), and then save this country as their country of choice. The page would look something like this:</p>
<p><img src="https://www.developerway.com/assets/how-to-write-performant-react-code/app-design.png" alt=""/></p>
<p>On the left we‚Äôll have a list of countries, with ‚Äúsaved‚Äù and ‚Äúselected‚Äù states, when an item in the list is clicked, in the column on the right the detailed information is shown. When the ‚Äúsave‚Äù button is pressed, the ‚Äúselected‚Äù country becomes ‚Äúsaved‚Äù, with the different item colour.</p>
<p>Oh, and we‚Äôd want the dark mode there of course, it‚Äôs 2022 after all!</p>
<p>Also, considering that in 90% of the cases performance problems in React can be summarised as ‚Äútoo many re-renders‚Äù, we are going to focus mostly on reducing those in the article. (Another 10% are: ‚Äúrenders are too heavy‚Äù and ‚Äúreally weird stuff that need further investigation‚Äù.)</p>
<h2>Let&#x27;s structure our app first</h2>
<p>First of all, let&#x27;s take a look at the design, draw imaginary boundaries, and draft the structure of our future app and which components we‚Äôd need to implement there:</p>
<ul>
<li>a root ‚ÄúPage‚Äù component, where we‚Äôd handle the ‚Äúsubmit‚Äù logic and country selection logic</li>
<li>a ‚ÄúList of countries‚Äù component, that would render all the countries in a list, and in the future handle things like filtering and sorting</li>
<li>‚ÄúItem‚Äù component, that renders the country in the ‚ÄúList of countries‚Äù</li>
<li>a ‚ÄúSelected country‚Äù component, that renders detailed information about the selected country and has the ‚ÄúSave‚Äù button</li>
</ul>
<p><img src="https://www.developerway.com/assets/how-to-write-performant-react-code/app-design-with-components.png" alt=""/></p>
<p>This is, of course, not the only possible way to implement this page, that‚Äôs the beauty and the curse of React: everything can be implemented in a million ways and there is no right or wrong answer for anything. But there are some patterns that in the long run in fast-growing or large already apps can definitely be called <strong>‚Äúnever do this‚Äù</strong> or <strong>‚Äúthis is a must-have‚Äù</strong>.</p>
<p>Let‚Äôs see whether we can figure them out together üôÇ</p>
<h2>Implementing Page component</h2>
<p>Now, finally, the time to get our hands dirty and do some coding. Let‚Äôs start from the ‚Äúroot‚Äù and implement the Page component.</p>
<p>First: we need a wrapper with some styles that renders page title, ‚ÄúList of countries‚Äù and ‚ÄúSelected country‚Äù components.</p>
<p>Second: our page should receive the list of countries from somewhere, and then pass it to the <code>CountriesList</code> component so that it could render those.</p>
<p>Third: our page should have an idea of a ‚Äúselected‚Äù country, that will be received from the <code>CountriesList</code> component and passed to the <code>SelectedCountry</code> component.</p>
<p>And finally: our page should have an idea of a ‚Äúsaved‚Äù country, that will be received from the <code>SelectedCountry</code> component and passed to the <code>CountriesList</code> component (and be sent to the backend in the future).</p>
<pre><code>export const Page = ({ countries }: { countries: Country[] }) =&gt; {
  const [selectedCountry, setSelectedCountry] = useState&lt;Country&gt;(countries[0]);
  const [savedCountry, setSavedCountry] = useState&lt;Country&gt;(countries[0]);

  return (
    &lt;&gt;
      &lt;h1&gt;Country settings&lt;/h1&gt;
      &lt;div css={contentCss}&gt;
        &lt;CountriesList
          countries={countries}
          onCountryChanged={(c) =&gt; setSelectedCountry(c)}
          savedCountry={savedCountry}
        /&gt;
        &lt;SelectedCountry
          country={selectedCountry}
          onCountrySaved={() =&gt; setSavedCountry(selectedCountry)}
        /&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>That is the entire implementation of the ‚ÄúPage‚Äù component, it‚Äôs the most basic React that you can see everywhere, and there is absolutely nothing criminal in this implementation. Except for one thing. Curious, can you see it?</p>
<h3>Refactoring Page component - with performance in mind</h3>
<p>I think it is common knowledge by now, that react re-renders components when there is a state or props change. In our Page component when <code>setSelectedCountry</code> or <code>setSavedCountry</code> is called, it will re-render. If the countries array (props) in our Page component changes, it will re-render. And the same goes for <code>CountriesList</code> and <code>SelectedCountry</code> components - when any of their props change, they will re-render.</p>
<p>Also, anyone, who spent some time with React, knows about javascript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness">equality comparison</a>, the fact that React does strict equality comparison for props, and the fact that inline functions create new value every time. This leads to the very common (and absolutely wrong btw) belief, that in order to reduce re-renders of <code>CountriesList</code> and <code>SelectedCountry</code> components we need to get rid of re-creating inline functions on every render by wrapping inline functions in <code>useCallback</code>. Even <a href="https://reactjs.org/docs/hooks-reference.html#usecallback">React docs</a> mention <code>useCallback</code> in the same sentence with ‚Äúprevent unnecessary renders‚Äù! See whether this pattern looks familiar:</p>
<pre><code>export const Page = ({ countries }: { countries: Country[] }) =&gt; {
  // ... same as before

  const onCountryChanged = useCallback((c) =&gt; setSelectedCountry(c), []);
  const onCountrySaved = useCallback(() =&gt; setSavedCountry(selectedCountry), []);

  return (
    &lt;&gt;
      ...
        &lt;CountriesList
          onCountryChanged={onCountryChange}
        /&gt;
        &lt;SelectedCountry
          onCountrySaved={onCountrySaved}
        /&gt;
      ...
    &lt;/&gt;
  );
};
</code></pre>
<p>Do you know the funniest part about it? It actually <strong>doesn‚Äôt work</strong>. Because it doesn‚Äôt take into account the third reason why React components are re-rendered: <strong>when the parent component is re-rendered</strong>. Regardless of the props, <code>CountriesList</code> will always re-render if Page is re-rendered, even if it doesn‚Äôt have any props at all.</p>
<p>We can simplify the Page example into just this:</p>
<pre><code>const CountriesList = () =&gt; {
  console.log(&quot;Re-render!!!!!&quot;);
  return &lt;div&gt;countries list, always re-renders&lt;/div&gt;;
};

export const Page = ({ countries }: { countries: Country[] }) =&gt; {
  const [counter, setCounter] = useState&lt;number&gt;(1);

  return (
    &lt;&gt;
      &lt;h1&gt;Country settings&lt;/h1&gt;
      &lt;button onClick={() =&gt; setCounter(counter + 1)}&gt;
        Click here to re-render Countries list (open the console) {counter}
      &lt;/button&gt;
      &lt;CountriesList /&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>And every time we click the button, we‚Äôll see that <code>CountriesList</code> is re-rendered, <strong>even if it doesn‚Äôt have any props at all</strong>. <a href="https://codesandbox.io/s/re-renders-simplified-bad-1giei?file=/src/country-settings/page.tsx">Codesandbox code is here</a>.</p>
<p>And this, finally, allows us to solidify the very first rule of this article:</p>
<p><b>Rule #1.</b> If the only reason you want to extract your inline functions in props into useCallback is to avoid re-renders of children components:
don‚Äôt. It doesn‚Äôt work.</p>
<p>Now, there are <a href="https://overreacted.io/before-you-memo/">a few ways</a> to deal with situations like the above, I am going to use the simplest one for this particular occasion: <a href="https://reactjs.org/docs/hooks-reference.html#usememo">useMemo</a> hook. What it does is it‚Äôs essentially ‚Äúcaches‚Äù the results of whatever function you pass into it, and only refreshes them when a <em>dependency</em> of <code>useMemo</code> is changed. If I just extract the rendered <code>CountriesList</code> into a variable <code>const list = &lt;ComponentList /&gt;;</code> and then apply <code>useMemo</code> on it, the <code>ComponentList</code> component now will be re-rendered <strong>only when useMemo dependencies will change</strong>.</p>
<pre><code>export const Page = ({ countries }: { countries: Country[] }) =&gt; {
  const [counter, setCounter] = useState&lt;number&gt;(1);

  const list = useMemo(() =&gt; {
    return &lt;CountriesList /&gt;;
  }, []);

  return (
    &lt;&gt;
      &lt;h1&gt;Country settings&lt;/h1&gt;
      &lt;button onClick={() =&gt; setCounter(counter + 1)}&gt;
        Click here to re-render Countries list (open the console) {counter}
      &lt;/button&gt;
      {list}
    &lt;/&gt;
  );
};
</code></pre>
<p>Which in this case is never, since it doesn‚Äôt have any dependencies. This pattern basically allows me to break out of this ‚Äúparent re-renders - re-render all the children regardless‚Äù loop and take control over it. Check out the <a href="https://codesandbox.io/s/re-renders-simplified-memo-xcv5f?file=/src/country-settings/page.tsx">full example in codesandbox</a>.</p>
<p>The most important thing there to be mindful of is the list of dependencies of <code>useMemo</code>. If it depends on exactly the same thing that causes the parent component to re-render, then it‚Äôs going to refresh its cache with every re-render, and essentially becomes useless. For example, if in this simplified example I pass the <code>counter</code> value as a dependency to the <code>list</code> variable (notice: not even a prop to the memoised component!), that will cause <code>useMemo</code> to refresh itself with every state change and will make <code>CountriesList</code> re-render again.</p>
<pre><code>const list = useMemo(() =&gt; {
  return (
    &lt;&gt;
      {counter}
      &lt;CountriesList /&gt;
    &lt;/&gt;
  );
}, [counter]);
</code></pre>
<p><a href="https://codesandbox.io/s/re-renders-simplified-memo-with-dep-9h433?file=/src/country-settings/page.tsx:363-491">See the codesandbox example.</a></p>
<p>Okay, so all of this is great, but how exactly it can be applied to our non-simplified Page component? Well, if we look closely to its implementation again</p>
<pre><code>export const Page = ({ countries }: { countries: Country[] }) =&gt; {
  const [selectedCountry, setSelectedCountry] = useState&lt;Country&gt;(countries[0]);
  const [savedCountry, setSavedCountry] = useState&lt;Country&gt;(countries[0]);

  return (
    &lt;&gt;
      &lt;h1&gt;Country settings&lt;/h1&gt;
      &lt;div css={contentCss}&gt;
        &lt;CountriesList
          countries={countries}
          onCountryChanged={(c) =&gt; setSelectedCountry(c)}
          savedCountry={savedCountry}
        /&gt;
        &lt;SelectedCountry
          country={selectedCountry}
          onCountrySaved={() =&gt; setSavedCountry(selectedCountry)}
        /&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>we‚Äôll see that:</p>
<ul>
<li><code>selectedCountry</code> state is never used in <code>CountriesList</code> component</li>
<li><code>savedCountry</code> state is never used in <code>SelectedCountry</code> component</li>
</ul>
<p><img src="https://www.developerway.com/assets/how-to-write-performant-react-code/page-component-improvement.png" alt=""/></p>
<p>Which means that when <code>selectedCountry</code> state changes, <code>CountriesList</code> component doesn‚Äôt need to re-render at all! And the same story with <code>savedCountry</code> state and <code>SelectedCountry</code> component. And I can just extract both of them to variables and memoise them to prevent their unnecessary re-renders:</p>
<pre><code>export const Page = ({ countries }: { countries: Country[] }) =&gt; {
  const [selectedCountry, setSelectedCountry] = useState&lt;Country&gt;(countries[0]);
  const [savedCountry, setSavedCountry] = useState&lt;Country&gt;(countries[0]);

  const list = useMemo(() =&gt; {
    return (
      &lt;CountriesList
        countries={countries}
        onCountryChanged={(c) =&gt; setSelectedCountry(c)}
        savedCountry={savedCountry}
      /&gt;
    );
  }, [savedCountry, countries]);

  const selected = useMemo(() =&gt; {
    return (
      &lt;SelectedCountry
        country={selectedCountry}
        onCountrySaved={() =&gt; setSavedCountry(selectedCountry)}
      /&gt;
    );
  }, [selectedCountry]);

  return (
    &lt;&gt;
      &lt;h1&gt;Country settings&lt;/h1&gt;
      &lt;div css={contentCss}&gt;
        {list}
        {selected}
      &lt;/div&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>And this, finally, lets us formalize the second rule of this article:</p>
<p><b>Rule #2</b>. If your component manages state, find parts of the render tree that don‚Äôt depend on the changed state and memoise them to
minimize their re-renders.</p>
<h2>Implementing the list of countries</h2>
<p>Now, that our Page component is ready and perfect, time to flesh out its children. First, let‚Äôs implement the complicated component: <code>CountriesList</code>. We already know, that this component should accept the list of countries, should trigger <code>onCountryChanged</code> callback when a country is selected in the list, and should highlight the <code>savedCountry</code> into a different color, according to design. So let‚Äôs start with the simplest approach:</p>
<pre><code>type CountriesListProps = {
  countries: Country[];
  onCountryChanged: (country: Country) =&gt; void;
  savedCountry: Country;
};

export const CountriesList = ({
  countries,
  onCountryChanged,
  savedCountry
}: CountriesListProps) =&gt; {
  const Item = ({ country }: { country: Country }) =&gt; {
    // different className based on whether this item is &quot;saved&quot; or not
    const className = savedCountry.id === country.id ? &quot;country-item saved&quot; : &quot;country-item&quot;;

    // when the item is clicked - trigger the callback from props with the correct country in the arguments
    const onItemClick = () =&gt; onCountryChanged(country);
    return (
      &lt;button className={className} onClick={onItemClick}&gt;
        &lt;img src={country.flagUrl} /&gt;
        &lt;span&gt;{country.name}&lt;/span&gt;
      &lt;/button&gt;
    );
  };

  return (
    &lt;div&gt;
      {countries.map((country) =&gt; (
        &lt;Item country={country} key={country.id} /&gt;
      ))}
    &lt;/div&gt;
  );
};
</code></pre>
<p>Again, the simplest component ever, only 2 things are happening there, really:</p>
<ul>
<li>we generate the <code>Item</code> based on the props we receive (it depends on both <code>onCountryChanged</code> and <code>savedCountry</code>)</li>
<li>we render that <code>Item</code> for all countries in a loop</li>
</ul>
<p>And again, there is nothing criminal about any of this <em>per se</em>, I have seen this pattern used pretty much everywhere.</p>
<h3>Refactoring List of countries component - with performance in mind</h3>
<p>Time again to refresh a bit our knowledge of how React renders things, this time - what will happen if a component, like <code>Item</code> component from above, is created <em>during another component render</em>? Short answer - nothing good, really. From React‚Äôs perspective, this <code>Item</code> is just a function that is new on every render, and that returns a new result on every render. So what it will do, is on <strong>every render</strong> it will re-create results of this function from scratch, i.e. it will just compare the previous component state with the current one, like it happens during normal re-render. It will drop the previously generated component, including its DOM tree, remove it from the page, and will generate and mount a completely new component, with a completely new DOM tree every single time the parent component is re-rendered.</p>
<p>If we simplify the countries example to demonstrate this effect, it will be something like this:</p>
<pre><code>const CountriesList = ({ countries }: { countries: Country[] }) =&gt; {
  const Item = ({ country }: { country: Country }) =&gt; {
    useEffect(() =&gt; {
      console.log(&quot;Mounted!&quot;);
    }, []);
    console.log(&quot;Render&quot;);
    return &lt;div&gt;{country.name}&lt;/div&gt;;
  };

  return (
    &lt;&gt;
      {countries.map((country) =&gt; (
        &lt;Item country={country} /&gt;
      ))}
    &lt;/&gt;
  );
};
</code></pre>
<p>This is the heaviest operation from them all in React. 10 ‚Äúnormal‚Äù re-renders is nothing compared to the full re-mounting of a freshly created component from a performance perspective. In normal circumstances, <code>useEffect</code> with an empty dependencies array would be triggered only once - after the component finished its mounting and very first rendering. After that the light-weight re-rendering process in React kicks in, and component is not created from scratch, but only updated when needed (that‚Äôs what makes React so fast btw). Not in this scenario though - take a look at <a href="https://codesandbox.io/s/creating-components-in-render-bad-8otem?file=/src/country-settings/page.tsx">this codesandbox</a>, click on the ‚Äúre-render‚Äù button with open console, and enjoy 250 renders AND mountings happening on every click.</p>
<p>The fix for this is obvious and easy: we just need to move the <code>Item</code> component outside of the render function.</p>
<pre><code>const Item = ({ country }: { country: Country }) =&gt; {
  useEffect(() =&gt; {
    console.log(&quot;Mounted!&quot;);
  }, []);
  console.log(&quot;Render&quot;);
  return &lt;div&gt;{country.name}&lt;/div&gt;;
};

const CountriesList = ({ countries }: { countries: Country[] }) =&gt; {
  return (
    &lt;&gt;
      {countries.map((country) =&gt; (
        &lt;Item country={country} /&gt;
      ))}
    &lt;/&gt;
  );
};
</code></pre>
<p>Now in our <a href="https://codesandbox.io/s/creating-components-in-render-fixed-cs7pe?file=/src/country-settings/page.tsx">simplified codesandbox</a> mounting doesn‚Äôt happen on every re-render of the parent component.</p>
<p>As a bonus, refactoring like this helps maintain healthy boundaries between different components and keep the code cleaner and more concise. This is going to be especially visible when we apply this improvement to our ‚Äúreal‚Äù app. Before:</p>
<pre><code>export const CountriesList = ({
  countries,
  onCountryChanged,
  savedCountry
}: CountriesListProps) =&gt; {

  // only &quot;country&quot; in props
  const Item = ({ country }: { country: Country }) =&gt; {
    // ... same code
  };

  return (
    &lt;div&gt;
      {countries.map((country) =&gt; (
        &lt;Item country={country} key={country.id} /&gt;
      ))}
    &lt;/div&gt;
  );
};
</code></pre>
<p>After:</p>
<pre><code>type ItemProps = {
  country: Country;
  savedCountry: Country;
  onItemClick: () =&gt; void;
};

// turned out savedCountry and onItemClick were also used
// but it was not obvious at all in the previous implementation
const Item = ({ country, savedCountry, onItemClick }: ItemProps) =&gt; {
  // ... same code
};

export const CountriesList = ({
  countries,
  onCountryChanged,
  savedCountry
}: CountriesListProps) =&gt; {
  return (
    &lt;div&gt;
      {countries.map((country) =&gt; (
        &lt;Item
          country={country}
          key={country.id}
          savedCountry={savedCountry}
          onItemClick={() =&gt; onCountryChanged(country)}
        /&gt;
      ))}
    &lt;/div&gt;
  );
};
</code></pre>
<p>Now, that we got rid of the re-mounting of <code>Item</code> component every time the parent component is re-rendered, we can extract the third rule of the article:</p>
<p><b>Rule #3</b>. Never create new components inside the render function of another component.</p>
<h2>Implementing selected country</h2>
<p>Next step: the ‚Äúselected country‚Äù component, which is going to be the shortest and the most boring part of the article, since there is nothing to show there really: it‚Äôs just a component that accepts a property and a callback, and renders a few strings:</p>
<pre><code>const SelectedCountry = ({ country, onSaveCountry }: { country: Country; onSaveCountry: () =&gt; void }) =&gt; {
  return (
    &lt;&gt;
      &lt;ul&gt;
        &lt;li&gt;Country: {country.name}&lt;/li&gt;
        ... // whatever country&#x27;s information we&#x27;re going to render
      &lt;/ul&gt;
      &lt;button onClick={onSaveCountry} type=&quot;button&quot;&gt;Save&lt;/button&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>ü§∑üèΩ‚Äç‚ôÄÔ∏è That‚Äôs it! It‚Äôs only here just to make the demo codesandbox more interesting üôÇ</p>
<h2>Final polish: theming</h2>
<p>And now the final step: dark mode! Who doesn‚Äôt love those? Considering that the current theme should be available in most components, passing it through props everywhere would be a nightmare, so React Context is the natural solution here.</p>
<p>Creating theme context first:</p>
<pre><code>type Mode = &#x27;light&#x27; | &#x27;dark&#x27;;
type Theme = { mode: Mode };
const ThemeContext = React.createContext&lt;Theme&gt;({ mode: &#x27;light&#x27; });

const useTheme = () =&gt; {
  return useContext(ThemeContext);
};
</code></pre>
<p>Adding context provider and the button to switch it to the Page component:</p>
<pre><code>export const Page = ({ countries }: { countries: Country[] }) =&gt; {
  // same as before
  const [mode, setMode] = useState&lt;Mode&gt;(&quot;light&quot;);

  return (
    &lt;ThemeContext.Provider value={{ mode }}&gt;
      &lt;button onClick={() =&gt; setMode(mode === &#x27;light&#x27; ? &#x27;dark&#x27; : &#x27;light&#x27;)}&gt;Toggle theme&lt;/button&gt;
      // the rest is the same as before
    &lt;/ThemeContext.Provider&gt;
  )
}
</code></pre>
<p>And then using the context hook to color our buttons in the appropriate theme:</p>
<pre><code>const Item = ({ country }: { country: Country }) =&gt; {
    const { mode } = useTheme();
    const className = `country-item ${mode === &quot;dark&quot; ? &quot;dark&quot; : &quot;&quot;}`;
    // the rest is the same
}
</code></pre>
<p>Again, nothing criminal in this implementation, a very common pattern, especially for theming.</p>
<h3>Refactoring theming - with performance in mind.</h3>
<p>Before we‚Äôll be able to catch what‚Äôs wrong with the implementation above, time to look into a fourth reason why a React component can be re-rendered, that often is forgotten: <b>if a component uses context consumer, it will be re-rendered every time the context provider‚Äôs value is changed.</b></p>
<p>Remember our simplified example, where we memoised the render results to avoid their re-renders?</p>
<pre><code>const Item = ({ country }: { country: Country }) =&gt; {
  console.log(&quot;render&quot;);
  return &lt;div&gt;{country.name}&lt;/div&gt;;
};

const CountriesList = ({ countries }: { countries: Country[] }) =&gt; {
  return (
    &lt;&gt;
      {countries.map((country) =&gt; (
        &lt;Item country={country} /&gt;
      ))}
    &lt;/&gt;
  );
};

export const Page = ({ countries }: { countries: Country[] }) =&gt; {
  const [counter, setCounter] = useState&lt;number&gt;(1);

  const list = useMemo(() =&gt; &lt;CountriesList countries={countries} /&gt;, [
    countries
  ]);

  return (
    &lt;&gt;
      &lt;h1&gt;Country settings&lt;/h1&gt;
      &lt;button onClick={() =&gt; setCounter(counter + 1)}&gt;
        Click here to re-render Countries list (open the console) {counter}
      &lt;/button&gt;
      {list}
    &lt;/&gt;
  );
};
</code></pre>
<p><code>Page</code> component will re-render every time we click the button since it updates the state on every click. But <code>CountriesList</code> is memoised and is independent of that state, so it won‚Äôt re-render, and as a result <code>Item</code> component won‚Äôt re-render as well. See the <a href="https://codesandbox.io/s/context-before-good-duhgf?file=/src/country-settings/page.tsx">codesandbox here</a>.</p>
<p>Now, what will happen if I add the Theme context here? Provider in the <code>Page</code> component:</p>
<pre><code>export const Page = ({ countries }: { countries: Country[] }) =&gt; {
  // everything else stays the same

  // memoised list is still memoised
  const list = useMemo(() =&gt; &lt;CountriesList countries={countries} /&gt;, [
    countries
  ]);

  return (
    &lt;ThemeContext.Provider value={{ mode }}&gt;
      // same
    &lt;/ThemeContext.Provider&gt;
  );
};
</code></pre>
<p>And context in the Item component:</p>
<pre><code>const Item = ({ country }: { country: Country }) =&gt; {
  const theme = useTheme();
  console.log(&quot;render&quot;);
  return &lt;div&gt;{country.name}&lt;/div&gt;;
};
</code></pre>
<p>If they were just normal components and hooks, nothing would‚Äôve happened - <code>Item</code> is not a child of <code>Page</code> component, <code>CountriesList</code> won‚Äôt re-render because of memoisation, so <code>Item</code> wouldn‚Äôt either. Except, in this case, it‚Äôs a Provider-consumer combination, so every time the value on the provider changes, <strong>all</strong> of the consumers will re-render. And since we‚Äôre passing new object to the value all the time, <em><code>Items</code> will unnecessary re-render on every counter</em>. Context basically bypasses the memorisation we did and makes it pretty much useless. <a href="https://codesandbox.io/s/context-bad-4zou7?file=/src/country-settings/page.tsx">See the codesandbox.</a></p>
<p>The fix to it, as you might have already guessed, is just to make sure that the <code>value</code> in the provider doesn‚Äôt change more than it needs to. In our case, we just need to memoise it as well:</p>
<pre><code>export const Page = ({ countries }: { countries: Country[] }) =&gt; {
  // everything else stays the same

  // memoising the object!
  const theme = useMemo(() =&gt; ({ mode }), [mode]);

  return (
    &lt;ThemeContext.Provider value={theme}&gt;
      // same
    &lt;/ThemeContext.Provider&gt;
  );
};
</code></pre>
<p>And now the counter will work without causing all the Items to re-render!</p>
<p>And absolutely the same solution for preventing unnecessary re-renders we can apply to our non-simplified <code>Page</code> component:</p>
<pre><code>export const Page = ({ countries }: { countries: Country[] }) =&gt; {
  // same as before
  const [mode, setMode] = useState&lt;Mode&gt;(&quot;light&quot;);

  // memoising the object!
  const theme = useMemo(() =&gt; ({ mode }), [mode]);

  return (
    &lt;ThemeContext.Provider value={theme}&gt;
      &lt;button onClick={() =&gt; setMode(mode === &#x27;light&#x27; ? &#x27;dark&#x27; : &#x27;light&#x27;)}&gt;Toggle theme&lt;/button&gt;
      // the rest is the same as before
    &lt;/ThemeContext.Provider&gt;
  )
}
</code></pre>
<p>And extract the new knowledge into the final rule of this article:</p>
<p><b>Rule #4</b>: When using context, make sure that value property is always memoised if it‚Äôs not a number, string or boolean.</p>
<h2>Bringing it all together</h2>
<p>And finally, our app is complete! The entire implementation is <a href="https://codesandbox.io/s/re-renders-final-good-luz8s?file=/src/country-settings/page.tsx">available in this codesandbox</a>. Throttle your CPU if you‚Äôre on the latest MacBook, to experience the world as the usual customers are, and try to select between different countries on the list. Even with 6x CPU reduction, it‚Äôs still blazing fast! üéâ</p>
<p>And now, the big question that I suspect many people have the urge to ask: ‚ÄúBut Nadia, React is blazing fast by itself anyway. Surely those ‚Äòoptimisations‚Äô that you did won‚Äôt make much of a difference on a simple list of just 250 items? Aren‚Äôt you exaggerating the importance here?‚Äú.</p>
<p>Yeah, when I just started this article, I also thought so. But then I implemented that app in the ‚Äúnon-performant‚Äù way. <a href="https://codesandbox.io/s/re-renders-final-bad-4znwe?file=/src/country-settings/page.tsx">Check it out in the codesandbox</a>. I don‚Äôt even need to reduce the CPU to see the delay between selecting the items üò±. Reduce it by 6x, and it‚Äôs probably the slowest simple list on the planet that doesn‚Äôt even work properly (it has a focus bug that the ‚Äúperformant‚Äù app doesn‚Äôt have). And I haven‚Äôt even done anything outrageously and obviously evil there! üòÖ</p>
<p>So let‚Äôs refresh <strong>when React components re-render</strong>:</p>
<ul>
<li>when component&#x27;s state changed</li>
<li>when parent component re-renders</li>
<li>when a component uses context and the value of its provider changes</li>
</ul>
<p>And the rules we extracted:</p>
<p><strong>Rule #1</strong>: If the only reason why you want to extract your inline functions in props into <code>useCallback</code> is to avoid re-renders of children components: don‚Äôt. It doesn‚Äôt work.</p>
<p><strong>Rule #2</strong>: If your component manages state, find parts of the render tree that don‚Äôt depend on the changed state and memoise them to minimize their re-renders.</p>
<p><strong>Rule #3</strong>. <em>Never</em> create new components inside the render function of another component.</p>
<p><strong>Rule #4</strong>. When using context, make sure that <code>value</code> property is <em>always</em> memoised if it‚Äôs not a number, string or boolean.</p>
<p>That is it! Hope those rules will help to write more performant apps from the get-go and lead to happier customers who never had to experience slow products anymore.</p>
<h2>Bonus: the <code>useCallback</code> conundrum</h2>
<p>I feel I need to resolve one mystery before I actually end this article: how can it be possible that <code>useCallback</code> is useless for reducing re-renders, and why then React docs literally say that ‚Äú[useCallback] is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders‚Äù? ü§Ø</p>
<p>The answer is in this phrase: <em>‚Äúoptimized child components that rely on reference equality‚Äù</em>.</p>
<p>There are 2 scenarios applicable here.</p>
<p><strong>First</strong>: the component that received the callback is wrapped in <code>React.memo</code> and has that callback as a dependency. Basically this:</p>
<pre><code>const MemoisedItem = React.memo(Item);

const List = () =&gt; {
  // this HAS TO be memoised, otherwise `React.memo` for the Item is useless
  const onClick = () =&gt; {console.log(&#x27;click!&#x27;)};

  return &lt;MemoisedItem onClick={onClick} country=&quot;Austria&quot; /&gt;
}
</code></pre>
<p>or this:</p>
<pre><code>const MemoisedItem = React.memo(Item, (prev, next) =&gt; prev.onClick !== next.onClick);

const List = () =&gt; {
  // this HAS TO be memoised, otherwise `React.memo` for the Item is useless
  const onClick = () =&gt; {console.log(&#x27;click!&#x27;)};

  return &lt;MemoisedItem onClick={onClick} country=&quot;Austria&quot; /&gt;
}
</code></pre>
<p><strong>Second</strong>: if the component that received the callback has this callback as a dependency in hooks like <code>useMemo</code>, <code>useCallback</code> or <code>useEffect</code>.</p>
<pre><code>const Item = ({ onClick }) =&gt; {
  useEffect(() =&gt; {
    // some heavy calculation here
    const data = ...
    onClick(data);

  // if onClick is not memoised, this will be triggered on every single render
  }, [onClick])
  return &lt;div&gt;something&lt;/div&gt;
}
const List = () =&gt; {
  // this HAS TO be memoised, otherwise `useEffect` in Item above
  // will be triggered on every single re-render
  const onClick = () =&gt; {console.log(&#x27;click!&#x27;)};

  return &lt;Item onClick={onClick} country=&quot;Austria&quot; /&gt;
}
</code></pre>
<p>None of this can be generalised into a simple ‚Äúdo‚Äù or ‚Äúdon‚Äôt do‚Äù, it can only be used for solving the exact performance problem of the exact component, and not before.</p>
<p>And now the article is finally done, thank you for reading it so far and hope you found it useful! Bleib gesund and see ya next time ‚úåüèº</p>]]></content:encoded>
      <enclosure
        url="https://www.developerway.com//assets/how-to-write-performant-react-code/welcome.jpg"
        length="0" type="image/jpg"/>
    </item>
    <item>
      <title><![CDATA[Advanced typescript for React developers - discriminated unions]]></title>
      <link>
        https://www.developerway.com/posts/advanced-typescript-for-react-developers-discriminated-unions
      </link>
      <guid>advanced-typescript-for-react-developers-discriminated-unions</guid>
      <pubDate>Thu, 30 Dec 2021 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Exploring how to discriminate unions properly and how this pattern can be useful for React developers' everyday professional life.]]></description>
      <content:encoded><![CDATA[<p>Hello, my fellow React developers who are in the process of learning advanced typescript patterns! Did you know that typescript has something that is called ‚Äúdiscriminated unions‚Äù? That name triggers all sorts of saviour reflexes against discrimination in me, but it actually is a pretty cool and useful feature that doesn‚Äôt need to be saved. Even better, it is super useful for something that we already perfected in the previous advanced typescript article: <a href="https://www.developerway.comhttps://www.developerway.com/posts/advanced-typescript-for-react-developers-part-3">exhaustiveness checking and narrowing of types.</a></p>
<p>Let‚Äôs jump right in, shall we? And to make it easier, we again will start from the <a href="https://codesandbox.io/s/distracted-noether-lxere?file=/src/tabs.tsx">previous code examples</a> and improve them along the way. This time we‚Äôre going to build multi-select capabilities into our generic select component and implement a data provider to fetch the products from a REST endpoint.</p>
<p>But first, let‚Äôs improve some completely unrelated code, just to get a sense of what discriminated union actually is.</p>
<h2>Discriminated unions - beginning</h2>
<p>Remember our function that was generating text labels for different data types?</p>
<pre><code>export type DataTypes = Book | Movie | Laptop | Phone | string;

const formatLabel = (value: DataTypes) =&gt; {
  if (isBook(value)) return `${value.title}: ${value.author}`;
  if (isMovie(value)) return `${value.title}: ${value.releaseDate}`;
  if (isLaptop(value)) return value.model;
  if (isPhone(value)) return `${value.model}: ${value.manufacture}`;

  return valueShouldBeString(value);
};
</code></pre>
<p>It looks pretty enough, although in functions <code>isBook</code> or <code>isMovie</code> we have to do quite a lot of calculation to determine which type is where. <code>isMovie</code>, for example, looks like this:</p>
<pre><code>export const isMovie = (value: DataTypes): value is Movie =&gt; {
  return (
    typeof value !== &quot;string&quot; &amp;&amp;
    &quot;id&quot; in value &amp;&amp;
    &quot;releaseDate&quot; in value &amp;&amp;
    &quot;title&quot; in value
  );
};
</code></pre>
<p>We had to do it because for our example we wrote types in a way that there is no reliable way to easily identify which is which: all the properties are strings, all of them have <code>id</code>, two of them have <code>releaseDate</code>.</p>
<pre><code>export type Book = {
  id: string;
  title: string;
  author: string;
};

export type Movie = {
  id: string;
  title: string;
  releaseDate: string;
};

... // all the other data types
</code></pre>
<p>That makes those functions quite prone to error and hard to read and extend. It doesn‚Äôt have to be that way though, this is one of the rarest things in life where we have absolute control. What we can do to improve the situation drastically is to introduce a new unique common property for every data type. Something like this:</p>
<p><img src="https://www.developerway.com/assets/discriminated-unions/example1.png" alt=""/></p>
<p>This would be what is called a <em>discriminant</em> property. Those who are privileged enough to get their data from a graphql endpoint will likely have <code>__typename</code> already in their data. The rest would have to have some sort of normalization function that adds the correct value manually when the data is received from the external source.</p>
<pre><code>export const books: Book[] = [
  {
    __typename: &quot;book&quot;, // add this to our json data here!
    id: &quot;1&quot;,
    title: &quot;Good omens&quot;,
    author: &quot;Terry Pratchett &amp; Neil Gaiman&quot;
  },
  ///...
];
// all the rest of the data with
</code></pre>
<p>And now, if we move <code>string</code> type away from <code>DataTypes</code>, it will turn into what is called <strong>‚Äúdiscriminated union‚Äù</strong> - a union of types, all of which have a common property with some unique value.</p>
<pre><code>type DataTypes = Book | Movie | Laptop | Phone;
</code></pre>
<p>The best part is that typescript can do narrowing of types easily when it deals with discriminated unions. And our <code>isSomething</code>-based implementation can be simplified into this:</p>
<pre><code>export type DataTypes = Book | Movie | Laptop | Phone;

const formatLabel = (value: DataTypes | string) =&gt; {
  if (typeof value === &quot;string&quot;) return value;
  if (value.__typename === &quot;book&quot;) return `${value.title}: ${value.author}`;
  if (value.__typename === &quot;movie&quot;) return `${value.title}: ${value.releaseDate}`;
  if (value.__typename === &quot;laptop&quot;) return value.model;
  if (value.__typename === &quot;phone&quot;) return `${value.model}: ${value.manufacture}`;

  return &quot;&quot;;
};
</code></pre>
<p>All the isSomething functions are gone, which not only simplifies the implementation but also makes it slightly more performant since we reduced the number of checks we‚Äôre doing in every <code>formatLabel</code> function call.</p>
<p><a href="https://codesandbox.io/s/discriminated-unions-example-1-nlcyr?file=/src/tabs.tsx">See the full example here</a></p>
<h2>Discriminated unions when fetching data</h2>
<p>One of the most useful applications of those types of unions is various mutually exclusive states and conditions. And the most typical one is the ‚Äúloading/error/data‚Äù pattern that can be seen in its various forms everywhere where data from an external source needs to be fetched.</p>
<p>First, let&#x27;s start with implementing a ‚Äúdata provider‚Äù for our books: a simple fetch that gets data from a REST endpoint, handlers ‚Äúloading‚Äù and ‚Äúerror‚Äù states, and puts the data into React context for all other components to use. We can pretty much just copy the example from <a href="https://reactjs.org/docs/faq-ajax.html">React documentation</a>, with a few modifications.</p>
<pre><code>type State = {
  loading?: boolean;
  error?: any;
  data?: Book[];
};

const Context = React.createContext&lt;State | undefined&gt;(undefined);

export const BooksProvider = ({ children }: { children: ReactNode }) =&gt; {
  const [loading, setLoading] = useState&lt;boolean&gt;(false);
  const [error, setError] = useState&lt;any&gt;(undefined);
  const [data, setData] = useState&lt;Book[]&gt;();

  useEffect(() =&gt; {
    setLoading(true);

    // just some random rest endpoint
    fetch(&#x27;https://raw.githubusercontent.com/mledoze/countries/master/countries.json&#x27;)
      .then((response) =&gt; {
        if (response.status === 200) {
          // in real life of course it would be the json data from the response
          // hardcoding books just to simplify the example since books are already typed
          setData(books);
          setLoading(false);
        } else {
          setLoading(false);
          setError(response.statusText);
        }
      })
      .catch((e) =&gt; {
        setLoading(false);
        setError(e);
      });
  }, []);

  return (
    &lt;Context.Provider
      value={{
        error,
        data,
        loading,
      }}
    &gt;
      {children}
    &lt;/Context.Provider&gt;
  );
};
</code></pre>
<p>And now, after adding the provider somewhere at the top of the app, we can use the fetched data everywhere in the app without triggering additional re-fetching, and do something like this:</p>
<pre><code>const SomeComponent = () =&gt; {
  const data = useBooks();

  if (!data?.data) return &lt;&gt;No data fetched&lt;/&gt;;
  if (data.loading) return &lt;&gt;Spinner&lt;/&gt;;
  if (data.error !== undefined) return &lt;&gt;Something bad happened!&lt;/&gt;;

  return &lt;GenericSelect&lt;Book&gt; values={data.data} ... /&gt;
}

export default () =&gt; {
  return (
    &lt;BooksProvider&gt;
      &lt;SomeComponent /&gt;
    &lt;/BooksProvider&gt;
  );
};
</code></pre>
<p>Although technically this example would work, it‚Äôs far from optimal, especially from the types perspective. Everything is optional and available to everything else even if it doesn‚Äôt make sense: you can access <code>error</code> or <code>data</code> property when loading is set to true for example, and the type system will not prevent it. On top of that, the state is split into three independent <code>useState</code>, which makes it very easy to make a mistake and forget one of the states or set it to a wrong value in the flow of the function. Imagine if I forget to do <code>setLoading(false)</code> or mistakenly do <code>setLoading(true)</code> when I receive the data: the overall state of the provider will be <code>loading</code> and <code>data received</code> at the same time , the type system will not stop it, and the customer-facing UI will be a total mess.</p>
<p>Luckily, both of those problems can be easily solved if we apply the knowledge of how discriminated unions and type narrowing works. First of all, we have four distinct mutually exclusive states in which our data provider can be:</p>
<ul>
<li>initial state, when nothing has happened yet. Neither <code>data</code> or <code>error</code> or <code>loading</code> exist here</li>
<li>loading state, where the provider started the data fetching, but haven‚Äôt received anything yet. Neither <code>data</code> or <code>error</code> exist here</li>
<li>success state, when data is successfully received. <code>Error</code> doesn‚Äôt exist here</li>
<li>error state, when the fetch resulted in error. <code>Data</code> doesn‚Äôt exist here.</li>
</ul>
<p>If we describe this in a form of types, it will be this:</p>
<pre><code>type PendingState = {
  status: &#x27;pending&#x27;;
};

type LoadingState = {
  status: &#x27;loading&#x27;;
};

type SuccessState = {
  status: &#x27;success&#x27;;
  data: Book[];
};

type ErrorState = {
  status: &#x27;error&#x27;;
  error: any;
};

type State = PendingState | LoadingState | SuccessState | ErrorState;
</code></pre>
<p><code>type State</code> is our classic discriminated union, with <code>status</code> being the discriminant property: it exists in every type and always has a unique value.</p>
<p>And now we can initialize our context provider with the default state value</p>
<pre><code>const defaultValue: PendingState = { status: &#x27;pending&#x27; };
const Context = React.createContext&lt;State&gt;(defaultValue);
</code></pre>
<p>use only one <code>setState</code> instead of three independent ones</p>
<pre><code>const [state, setState] = useState&lt;State&gt;(defaultValue);
</code></pre>
<p>and refactor <code>useEffect</code> function to the new system</p>
<p><img src="https://www.developerway.com/assets/discriminated-unions/example2.png" alt=""/></p>
<p>Now possibilities of mistakes are minimised:</p>
<ul>
<li>when I do <code>setState({ status: &#x27;loading&#x27; });</code>, typescript will not allow to set neither <code>data</code> nor <code>error</code> there</li>
<li>if I try to do just <code>setState({ status: &#x27;success&#x27; });</code>, typescript will fail, since it expects to find Books in the mandatory <code>data</code> field for the success state</li>
<li>same story with <code>setState({ status: &#x27;error&#x27; });</code> - typescript will fail here since it expects the mandatory <code>error</code> field in the error state</li>
</ul>
<p>And it gets even better, since on the consumer side typescript will also be able to distinguish between those states and prevent unintentional use of properties in the wrong places:</p>
<pre><code>const SomeComponent = () =&gt; {
  const data = useBooks();

  if (data.status === &#x27;pending&#x27;) {
    // if I try to access data.error or data.data typescript will fail
    // since pending state only has &quot;status&quot; property
    return &lt;&gt;Waiting for the data to fetch&lt;/&gt;;
  }

  if (data.status === &#x27;loading&#x27;) {
    // if I try to access data.error or data.data typescript will fail
    // since loading state only has &quot;status&quot; property
    return &lt;&gt;Spinner&lt;/&gt;;
  }

  if (data.status === &#x27;error&#x27;) {
    // data.error will be available here since error state has it as mandatory property
    return &lt;&gt;Something bad happened!&lt;/&gt;;
  }

  // we eliminated all other statuses other than &quot;success&quot; at this point
  // so here data will always be type of &quot;success&quot; and we&#x27;ll be able to access data.data freely
  return &lt;GenericSelect&lt;Book&gt; values={data.data} ... /&gt;
}

export default () =&gt; {
  return (
    &lt;BooksProvider&gt;
      &lt;SomeComponent /&gt;
    &lt;/BooksProvider&gt;
  );
};
</code></pre>
<p><a href="https://codesandbox.io/s/discriminated-unions-example-2-4bfqj?file=/src/books.tsx">See the full example here</a></p>
<h2>Discriminated unions in components props</h2>
<p>And last but not least, example of the usefulness of discriminated unions is components props. Those are especially useful when your component has some boolean props that control some of its behaviour or appearance, although the pattern would work with any literal type. Imagine, for example, that we want to extend our <code>GenericSelect</code> component to support also multi-select functionality.</p>
<pre><code>type GenericSelectProps&lt;TValue&gt; = {
  formatLabel: (value: TValue) =&gt; string;
  onChange: (value: TValue) =&gt; void;
  values: Readonly&lt;TValue[]&gt;;
};

export const GenericSelect = &lt;TValue extends Base&gt;(
  props: GenericSelectProps&lt;TValue&gt;
) =&gt; {
  const { values, onChange, formatLabel } = props;

  const onSelectChange = (e) =&gt; {
    const val = values.find(
      (value) =&gt; getStringFromValue(value) === e.target.value
    );

    if (val) onChange(val);
  };

  return (
    &lt;select onChange={onSelectChange}&gt;
      {values.map((value) =&gt; (
        &lt;option
          key={getStringFromValue(value)}
          value={getStringFromValue(value)}
        &gt;
          {formatLabel(value)}
        &lt;/option&gt;
      ))}
    &lt;/select&gt;
  );
};
</code></pre>
<p>Typically what people do in this situation is they introduce <code>isMulti: boolean</code> property and then adjust implementation accordingly. In our case, we‚Äôd need to: add <code>isMulti</code> to the component props, adjust <code>onChange</code> callback types to accept multiple values, pass <code>multiple</code> prop to the select itself, introduce internal state to hold selected values for the multi-select variation, adjust the <code>onSelectChange</code> handler to support multi-select variation, filter out selected values from the rendered options and render them on top of the select instead with <code>onDelete</code> handler attached.</p>
<p>After all those manipulations, our <code>GenericSelect</code> props would looks like this:</p>
<pre><code>type GenericSelectProps&lt;TValue&gt; = {
  isMulti: boolean;
  onChange: (value: TValue | TValue[]) =&gt; void;
  ..// the rest are the same
};
</code></pre>
<p>And the full working code is <a href="https://codesandbox.io/s/discriminated-unions-example-3-2wrkd?file=/src/select.tsx">available in this codesandbox.</a></p>
<p>And again the same story: although from the first glance this looks like a good solution, there is one big flaw in it: when consumers of the select would want to use <code>onChange</code> callback, typescript would not know what <em>exactly</em> is in the value. There is no connection from its perspective between <code>isMulti</code> prop and <code>onChange</code> value, and value‚Äôs type will always be <code>TValue | TValue[]</code> regardless of <code>isMulti</code> property.</p>
<pre><code>const select = (
  &lt;GenericSelect&lt;Book&gt;
    // I can&#x27;t log &quot;value.title&quot; here, typescript will fail
    // property &quot;title&quot; doesn&#x27;t exist on type &quot;Book[]&quot;&quot;
    // even if I know for sure that this is a single select
    // and the type will always be just &quot;Book&quot;
    onChange={(value) =&gt; console.info(value.title)}
    isMulti={false}
    ...
  /&gt;
);

const multiSelect = (
  &lt;GenericSelect&lt;Book&gt;
    // I can&#x27;t iterate on the value here, typescript will fail
    // property &quot;map&quot; doesn&#x27;t exist on type &quot;Book&quot;
    // even if I know for sure that this is a multi select
    // and the type will always be &quot;Book[]&quot;
    onChange={(value) =&gt; value.map(v =&gt; console.info(v))}
    isMulti={true}
    ...
  /&gt;
);
</code></pre>
<p>Luckily, this is easily fixable by turning <code>GenericSelectProps</code> into discriminated union with <code>isMulti</code> as the discriminant:</p>
<pre><code>type GenericSelectProps&lt;TValue&gt; = {
  formatLabel: (value: TValue) =&gt; string;
  values: Readonly&lt;TValue[]&gt;;
};

interface SingleSelectProps&lt;TValue&gt; extends GenericSelectProps&lt;TValue&gt; {
  isMulti: false; // false, not boolean. For single select component this is always false
  onChange: (value: TValue) =&gt; void;
}

interface MultiSelectProps&lt;TValue&gt; extends GenericSelectProps&lt;TValue&gt; {
  isMulti: true; // true, not boolean. For multi select component this is always true
  onChange: (value: TValue[]) =&gt; void;
}
</code></pre>
<p>and passing those properties to the select component as a union:</p>
<pre><code>export const GenericSelect = &lt;TValue extends Base&gt;(
  props: SingleSelectProps&lt;TValue&gt; | MultiSelectProps&lt;TValue&gt;
) =&gt; {
</code></pre>
<p>In the perfect world that would be enough for everything to work. Unfortunately, in our reality there is another small adjustment needed: when we spread props, typescript loses that types link for some reason. In order for the code to actually work we basically need to get rid of this:</p>
<pre><code>const { isMulti, onChange } = props;
</code></pre>
<p>and always use <code>props.isMulti</code> and <code>props.onChange</code> in the code instead. I.e. it should be something like this:</p>
<pre><code>if (props.isMulti) {
    props.onChange([...selectedValues, val]);
  if (val) props.onChange(val);
}
</code></pre>
<p>And with those modifications generic select will be perfectly usable in both of its variations and types will be perfect</p>
<pre><code>const select = (
  &lt;GenericSelect&lt;Book&gt;
    // now it will work perfectly!
    onChange={(value) =&gt; console.info(value.title)}
    isMulti={false}
    ...
  /&gt;
);

const multiSelect = (
  &lt;GenericSelect&lt;Book&gt;
    // now it will work perfectly!
    onChange={(value) =&gt; value.map(v =&gt; console.info(v))}
    isMulti={true}
    ...
  /&gt;
);
</code></pre>
<p><a href="https://codesandbox.io/s/discriminated-unions-example-4-hkk1e?file=/src/select.tsx">See the fully working example here</a></p>
<p>That is all for today, hope you‚Äôre now able to discriminate unions like a pro and have the big urge to refactor all your code asap. I know I do üòä üòÖ.</p>
<p>Happy New year and see y‚Äôall in 2022 üéâ</p>]]></content:encoded>
      <enclosure url="https://www.developerway.com//assets/discriminated-unions/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title><![CDATA[Advanced typescript for React developers - part 3]]></title>
      <link>https://www.developerway.com/posts/advanced-typescript-for-react-developers-part-3
      </link>
      <guid>advanced-typescript-for-react-developers-part-3</guid>
      <pubDate>Mon, 20 Dec 2021 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Learning while coding what is the purpose of exhaustiveness checking, how the narrowing of types works and when typescript enums could be useful.]]></description>
      <content:encoded><![CDATA[<p>This is a third article in the series of ‚ÄúAdvanced typescript for React developers‚Äù. In the previous chapters we together with ambitious developer Judi figured out how and why <a href="/posts/typescript-generics-for-react-developers">Typescript generics</a> are useful for creating reusable React components, and understood such typescript concepts as <a href="/posts/advanced-typescript-for-react-developers">type guards, keyof, typeof, is, as const and indexed types</a>. We did it while implementing with Judi a competitor to Amazon: an online website that has different categories of goods and the ability to select them via a select component. Now it‚Äôs time to improve the system once again, and to learn in the process what is the purpose of <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-never-type">exhaustiveness checking</a>, how the narrowing of types works and when <a href="https://www.typescriptlang.org/docs/handbook/enums.html">typescript enums</a> could be useful.</p>
<p>You can see the code of the example we‚Äôre starting with in <a href="https://codesandbox.io/s/immutable-wildflower-n4r8z?file=/src/tabs.tsx">this codesandbox</a>.</p>
<h2>Exhaustiveness checking with never</h2>
<p>Let‚Äôs remember how we implemented our Tabs with categories. We have an array of strings, a <code>switch</code> case that for every tab returns a select component, and a select component for categories themselves.</p>
<pre><code>const tabs = [&quot;Books&quot;, &quot;Movies&quot;, &quot;Laptops&quot;] as const;
type Tabs = typeof tabs;
type Tab = Tabs[number];

const getSelect = (tab: Tab) =&gt; {
  switch (tab) {
    case &quot;Books&quot;:
      return (
        &lt;GenericSelect&lt;Book&gt; ... /&gt;
      );
    case &quot;Movies&quot;:
      return (
        &lt;GenericSelect&lt;Movie&gt; ... /&gt;
      );
    case &quot;Laptops&quot;:
      return (
        &lt;GenericSelect&lt;Laptop&gt; ... /&gt;
      );
  }
};

export const TabsComponent = () =&gt; {
  const [tab, setTab] = useState&lt;Tab&gt;(tabs[0]);

  const select = getSelect(tab);

  return (
    &lt;&gt;
      Select category:
      &lt;GenericSelect&lt;Tab&gt;
        onChange={(value) =&gt; setTab(value)}
        values={tabs}
        formatLabel={formatLabel}
      /&gt;
      {select}
    &lt;/&gt;
  );
};
</code></pre>
<p>Everything is perfectly typed, so if a typo happens anywhere it will be picked up by Typescript. But is it <em>perfectly</em> typed though? What will happen if I want to add a new category to the list: <code>Phones</code>? Seems easy enough: I just add it to the array and to the switch statement.</p>
<pre><code>const tabs = [&quot;Books&quot;, &quot;Movies&quot;, &quot;Laptops&quot;, &quot;Phones&quot;] as const;

const getSelect = (tab: Tab) =&gt; {
  switch (tab) {
    // ...
    case &quot;Phones&quot;:
      return (
        &lt;GenericSelect&lt;Phone&gt; ... /&gt;
      );
  }
};
</code></pre>
<p>And in a simple implementation like this, it wouldn‚Äôt bring much trouble. But in real life more likely than not this code will be separated, abstracted away, and hidden behind layers of implementation. What will happen then if I just add Phones to the array, but forget about the switch case?</p>
<pre><code>const tabs = [&quot;Books&quot;, &quot;Movies&quot;, &quot;Laptops&quot;, &quot;Phones&quot;] as const;

const getSelect = (tab: Tab) =&gt; {
  switch (tab) {
    case &quot;Books&quot;:
      // ...
    case &quot;Movies&quot;:
      // ...
    case &quot;Laptops&quot;:
      // ...
  }
};
</code></pre>
<p>With this implementation - nothing good, unfortunately. Typescript will be totally fine with it, the bug might be missed during manual testing, it will go to production, and when customers select ‚ÄúPhones‚Äù in the menu, they won‚Äôt see anything on the screen.</p>
<p>It doesn‚Äôt have to be like this though. When we use operators like <code>if</code> or <code>switch</code> typescript performs what is known as <strong>‚Äúnarrowing‚Äù</strong>, i.e. it reduces the available options for the union types with every statement. If, for example, we have a switch case with only ‚ÄúBooks‚Äù, the ‚ÄúBooks‚Äù type will be eliminated at the first <code>case</code> statement, but the rest of them will be available later on:</p>
<pre><code>const tabs = [&quot;Books&quot;, &quot;Movies&quot;, &quot;Laptops&quot;] as const;

// Just &quot;Books&quot; in the switch statement
const getSelect = (tab: Tab) =&gt; {
  switch (tab) {
    case &quot;Books&quot;:
      // tab&#x27;s type is Books here, it will not be available in the next cases
      return &lt;GenericSelect&lt;Book&gt; ... /&gt;
    default:
      // at this point tab can be only &quot;Movies&quot; or &quot;Laptops&quot;
      // Books have been eliminated at the previous step
  }
};
</code></pre>
<p>If we use all the possible values, typescript will represent the state that will never exist as <code>never</code> type.</p>
<pre><code>const tabs = [&quot;Books&quot;, &quot;Movies&quot;, &quot;Laptops&quot;] as const;

const getSelect = (tab: Tab) =&gt; {
  switch (tab) {
    case &quot;Books&quot;:
      // &quot;Books&quot; have been eliminated here
    case &quot;Movies&quot;:
      // &quot;Movies&quot; have been eliminated here
    case &quot;Laptops&quot;:
      // &quot;Laptops&quot; have been eliminated here
    default:
      // all the values have been eliminated in the previous steps
      // this state can never happen
      // tab will be `never` type here
  }
};
</code></pre>
<p>And watch the hands very carefully for this trick: in this ‚Äúimpossible‚Äù state you can explicitly state that tab should be <code>never</code> type. And if for some reason it‚Äôs not <em>actually</em> impossible (i.e. we added ‚ÄúPhones‚Äù to the array, but not the <code>switch</code> - typescript will fail!</p>
<pre><code>// Added &quot;Phones&quot; here, but not in the switch
const tabs = [&quot;Books&quot;, &quot;Movies&quot;, &quot;Laptops&quot;, &quot;Phones&quot;] as const;

// Telling typescript explicitly that we want tab to be &quot;never&quot; type
// When this function is called, it should be &quot;never&quot; and only &quot;never&quot;
const confirmImpossibleState = (tab: never) =&gt; {
  throw new Error(`Reacing an impossible state because of ${tab}`);
};

const getSelect = (tab: Tab) =&gt; {
  switch (tab) {
    case &quot;Books&quot;:
      // &quot;Books&quot; have been eliminated
    case &quot;Movies&quot;:
      // &quot;Movies&quot; have been eliminated
    case &quot;Laptops&quot;:
      // &quot;Laptops&quot; have been eliminated
    default:
      // This should be &quot;impossible&quot; state,
      // but we forgot to add &quot;Phones&quot; as one of the cases
      // and &quot;tab&quot; can still be the type &quot;Phones&quot; at this stage.

      // Fortunately, in this function we assuming tab is always &quot;never&quot; type
      // But since we forgot to eliminate Phones, typescript now will fail!
      confirmImpossibleState(tab);
  }
};
</code></pre>
<p>Now the implementation is perfect! Any typos will be picked up by typescript, non-existing categories will be picked up, and missed categories will be picked up as well! This trick is called <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#exhaustiveness-checking">Exhaustiveness checking</a> by the way.</p>
<h2>Exhaustiveness checking without never</h2>
<p>Interestingly enough, for the exhaustiveness trick to work, you don‚Äôt actually <em>need</em> <code>never</code> type and the ‚Äúimpossible‚Äù state. All you need is just to understand this process of narrowing and elimination, and how to ‚Äúlock‚Äù the desired type at the last step.</p>
<p>Remember, we had our <code>formatLabel</code> function that we pass to the select component, that returns the desired string for the select options based on the value type?</p>
<pre><code>export type DataTypes = Book | Movie | Laptop | string;

export const formatLabel = (value: DataTypes) =&gt; {
  if (isBook(value)) return `${value.title}: ${value.author}`;
  if (isMovie(value)) return `${value.title}: ${value.releaseDate}`;
  if (isLaptop(value)) return value.model;

  return value;
};
</code></pre>
<p>Another perfect candidate for exactly the same bug - what will happen when we add <code>Phone</code> as one of the data types, but forget the actual check? With the current implementation - nothing good again, the Phone select options will be broken. But, if we apply the exhaustiveness knowledge to the function, we can do this:</p>
<pre><code>export type DataTypes = Book | Movie | Laptop | Phone | string;

 // When this function is called the value should be only string
 const valueShouldBeString = (value: string) =&gt; value;

 const formatLabel = (value: DataTypes) =&gt; {
  // we&#x27;re eliminating Book type from the union here
  if (isBook(value)) return `${value.title}: ${value.author}`;

  // here value can only be Movie, Laptop, Phone or string

  // we&#x27;re eliminating Movie type from the union here
  if (isMovie(value)) return `${value.title}: ${value.releaseDate}`;

  // here value can only be Laptop, Phone or string

  // we&#x27;re eliminating Laptop type from the union here
  if (isLaptop(value)) return value.model;

  // here value can only be Phone or string

  // But we actually want it to be only string
  // And make typescript fail if it is not
  // So we just call this function, that explicitly assigns &quot;string&quot; to value

  return valueShouldBeString(value);

  // Now, if at this step not all possibilities are eliminated
  // and value can be something else other than string (like Phone in our case)
  // typescript will pick it up and fail!
};
</code></pre>
<p>We have eliminated all the possible union types except <code>string</code>, and ‚Äúlocked‚Äù string in the final step. Pretty neat, huh?</p>
<p><a href="https://codesandbox.io/s/jolly-kowalevski-rx7db?file=/src/tabs.tsx">See fully working example in this codesandbox.</a></p>
<h2>Improving code readability with Enums</h2>
<p>Now it‚Äôs the time for the final polish of this beautiful piece of typescript art that is our categories implementation. I don‚Äôt know about you, but this part worries me a bit:</p>
<pre><code>const tabs = [&quot;Books&quot;, &quot;Movies&quot;, &quot;Laptops&quot;] as const;
type Tabs = typeof tabs;
type Tab = Tabs[number];
</code></pre>
<p>There is nothing wrong with it <em>per se</em>, it just slightly breaks my brain every time I‚Äôm looking at the constructs like that. It always takes one-two additional seconds to understand what <em>exactly</em> is going on here. Fortunately, there is a way to improve it for those who suffer from the same issue. Did you know that Typescript supports <a href="https://www.typescriptlang.org/docs/handbook/enums.html">enums</a>? They allow defining a set of named constants. And the best part of it - those are strongly typed from the get-go, and you can literally use the same enum as type and as value <strong>at the same time</strong>. ü§Ø</p>
<p>Basically this:</p>
<pre><code>const tabs = [&quot;Books&quot;, &quot;Movies&quot;, &quot;Laptops&quot;] as const;
type Tabs = typeof tabs;
type Tab = Tabs[number];
</code></pre>
<p>Could be replaced with this, which is arguably much easier and more intuitive to read:</p>
<pre><code>enum Tabs {
  &#x27;MOVIES&#x27; = &#x27;Movies&#x27;,
  &#x27;BOOKS&#x27; = &#x27;Books&#x27;,
  &#x27;LAPTOPS&#x27; = &#x27;Laptops&#x27;,
}
</code></pre>
<p>And then, when you need to access a specific value, you‚Äôd use dot notation, just like an object:</p>
<pre><code>const movieTab = Tabs.MOVIES; // movieTab will be `Movies`
const bookTab = Tabs.BOOKS; // bookTab will be `Books`
</code></pre>
<p>And just use <code>Tabs</code> when you want to reference the enum as a type!</p>
<p>If we look at our tabs code, we can just replace all the Tab types with enum Tabs and all the tabs strings with enum‚Äôs values:</p>
<p><img src="https://www.developerway.com/assets/advanced-typescript-for-react-developers-part-3/before-after-1.png" alt=""/></p>
<p>And, in the actual implementation of the Tabs component the same: replace the type, replace values, and pass to select component enum‚Äôs values in the form of an array:</p>
<p><img src="https://www.developerway.com/assets/advanced-typescript-for-react-developers-part-3/before-after-2.png" alt=""/></p>
<p><a href="https://codesandbox.io/s/distracted-noether-lxere?file=/src/tabs.tsx">See the full code example in this codesandbox.</a></p>
<p>Perfection! üòç üòé</p>
<p>That is all for today, hope you enjoyed the reading and now feel a little bit more confident with typescript‚Äôs narrowing, exhaustiveness checking and enums. See ya next time üòâ</p>]]></content:encoded>
      <enclosure
        url="https://www.developerway.com//assets/advanced-typescript-for-react-developers-part-3/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title><![CDATA[Advanced typescript for React developers]]></title>
      <link>https://www.developerway.com/posts/advanced-typescript-for-react-developers</link>
      <guid>advanced-typescript-for-react-developers</guid>
      <pubDate>Wed, 08 Dec 2021 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Diving into advanced typescript concepts and understanding how and why we need things like type guards, keyof, typeof, is, as const and indexed types.]]></description>
      <content:encoded><![CDATA[<p>This is the second article in the series ‚Äútypescript for React developers‚Äù. In the first one, we figured out what Typescript generics are and how to use them to write re-usable react components: <a href="/posts/typescript-generics-for-react-developers">Typescript Generics for React developers</a>. Now it‚Äôs time to dive into other advanced typescript concepts and understand how and why we need things like <strong>type guards</strong>, <strong>keyof</strong>, <strong>typeof</strong>, <strong>is</strong>, <strong>as const</strong> and <strong>indexed types</strong>.</p>
<h2>Introduction</h2>
<p>As we found out from the article above, Judi is an ambitious developer and wants to implement her own online shop, a competitor to Amazon: she‚Äôs going to sell everything there! We left her when she implemented a re-usable select component with typescript generics. The component is pretty basic: it allows to pass an array of <code>values</code>, assumes that those values have <code>id</code> and <code>title</code> for rendering select options, and have an <code>onChange</code> handler to listen to the selected values.</p>
<pre><code>type Base = {
  id: string;
  title: string;
};

type GenericSelectProps&lt;TValue&gt; = {
  values: TValue[];
  onChange: (value: TValue) =&gt; void;
};

export const GenericSelect = &lt;TValue extends Base&gt;({ values, onChange }: GenericSelectProps&lt;TValue&gt;) =&gt; {
  const onSelectChange = (e) =&gt; {
    const val = values.find((value) =&gt; value.id === e.target.value);

    if (val) onChange(val);
  };

  return (
    &lt;select onChange={onSelectChange}&gt;
      {values.map((value) =&gt; (
        &lt;option key={value.id} value={value.id}&gt;
          {value.title}
        &lt;/option&gt;
      ))}
    &lt;/select&gt;
  );
};
</code></pre>
<p>and then this component can be used with any data types Judi has in her application</p>
<pre><code>&lt;GenericSelect&lt;Book&gt; onChange={(value) =&gt; console.log(value.author)} values={books} /&gt;
&lt;GenericSelect&lt;Movie&gt; onChange={(value) =&gt; console.log(value.releaseDate)} values={movies} /&gt;
</code></pre>
<p>Although, as the shop grew, she quickly found out that <em>any</em> data type is an exaggeration: we are still limited since we assume that our data will always have <code>id</code> and <code>title</code> there. But now Judi wants to sell laptops, and laptops have <code>model</code> instead of <code>title</code> in their data.</p>
<pre><code>type Laptop = {
  id: string;
  model: string;
  releaseDate: string;
}

// This will fail, since there is no &quot;title&quot; in the Laptop type
&lt;GenericSelect&lt;Laptop&gt; onChange={(value) =&gt; console.log(value.model)} values={laptops} /&gt;
</code></pre>
<p>Ideally, Judi wants to avoid data normalization just for select purposes and make the select component more generic instead. What can she do?</p>
<h2>Rendering not only titles in options</h2>
<p>Judi decides, that just passing the desired attribute as a prop to the select component would be enough to fulfil her needs for the time being. Basically, she‚Äôd have something like this in its API:</p>
<pre><code>&lt;GenericSelect&lt;Laptop&gt; titleKey=&quot;model&quot; {...} /&gt;
</code></pre>
<p>and the select component would then render Laptop models instead of titles in the options.</p>
<p><img src="https://www.developerway.com/assets/advanced-typescript-for-react-developers/example-1.png" alt=""/></p>
<p>It would work, but there is one problem with this: not type-safe üôÇ. Ideally, we would want typescript to fail if this attribute doesn‚Äôt exist in the data model that is used in the select component. This is where typescript‚Äôs <a href="https://www.typescriptlang.org/docs/handbook/2/keyof-types.html"><strong>keyof</strong></a> operator comes in handy.</p>
<p><code>keyof</code> basically generates a type from an object‚Äôs keys. If I use <code>keyof</code> on <code>Laptop</code> type:</p>
<pre><code>type Laptop = {
  id: string;
  model: string;
  releaseDate: string;
}

type LaptopKeys = keyof Laptop;
</code></pre>
<p>in <code>LaptopKeys</code> I‚Äôll find a union of its keys: <code>&quot;id&quot; | &quot;model&quot; | &quot;releaseDate&quot;</code>.</p>
<p>And, most amazingly, typescript is smart enough to generate those types for generics as well! This will work perfectly:</p>
<p><img src="https://www.developerway.com/assets/advanced-typescript-for-react-developers/example-2.png" alt=""/></p>
<p>And now I can use it with all selects and typescript will catch any typos or copy-paste errors:</p>
<pre><code>&lt;GenericSelect&lt;Laptop&gt; titleKey=&quot;model&quot; {...} /&gt;
// inside GenericSelect &quot;titleKey&quot; will be typed to &quot;id&quot; | &quot;model&quot; | &quot;releaseDate&quot;

&lt;GenericSelect&lt;Book&gt; titleKey=&quot;author&quot; {...} /&gt;
// inside GenericSelect &quot;titleKey&quot; will be typed to &quot;id&quot; | &quot;title&quot; | &quot;author&quot;
</code></pre>
<p>and we can make the type <code>Base</code> a little bit more inclusive and make the <code>title</code> optional</p>
<pre><code>type Base = {
  id: string;
  title?: string;
}

export const GenericSelect = &lt;TValue extends Base&gt;(props: GenericSelectProps&lt;TValue&gt;) =&gt; {
</code></pre>
<p><a href="https://codesandbox.io/s/vigorous-neumann-0w1ti?file=/src/select.tsx">See full working example in codesandbox</a>.</p>
<p><em>Important</em>: Although this example works perfectly, I would not recommend using it in actual apps. It lacks a bit of elegance and is not generic enough <em>yet</em>. Read until the end of the article for a better example of a select component with customizable labels.</p>
<h2>The list of categories - refactor select</h2>
<p>Now, that we have lists of goods covered with our generic select, it‚Äôs time to solve other problems on Judi‚Äôs website. One of them is that she has her catalog page clattered with all the selects and additional information that she shows when a value is selected. What she needs, she decides, is to split it into categories, and only show one category at a time. She again wants to use the generic select for it (well, who‚Äôs not lazy in this industry, right?).</p>
<p><img src="https://www.developerway.com/assets/advanced-typescript-for-react-developers/category-example1.png" alt=""/></p>
<p>The categories is just a simple array of strings: <code>const categories = [&#x27;Books&#x27;, &#x27;Movies&#x27;, &#x27;Laptops&#x27;].</code></p>
<p>Now, our current generic select unfortunately doesn‚Äôt work with string values. Let‚Äôs fix it! And interestingly enough, this seems-to-be-simple implementation will allow us to get familiar with five new advanced typescript technics: operators <strong>as const</strong>, <strong>typeof</strong>, <strong>is</strong>, <strong>type guards</strong> idea and <strong>indexed types</strong>. But let‚Äôs start with the existing code and take a closer look at where exactly we depend on the <code>TValue</code> type to be an object.</p>
<p><img src="https://www.developerway.com/assets/advanced-typescript-for-react-developers/need-to-refactor-example.png" alt=""/></p>
<p>After careful examination of this picture, we can extract three major changes that we need to do:</p>
<ol>
<li>Convert <code>Base</code> type into something that understands strings as well as objects</li>
<li>Get rid of reliance on <code>value.id</code> as the unique identificator of the value in the list of options</li>
<li>Convert <code>value[titleKey]</code> into something that understands strings as well</li>
</ol>
<p>With this step-by-step approach to refactoring, the next moves are more or less obvious.</p>
<p><strong>Step 1</strong>. Convert <code>Base</code> into a union type (i.e. just a fancy ‚Äúor‚Äù operator for types) and get rid of <code>title</code> there completely:</p>
<pre><code>type Base = { id: string } | string;

// Now &quot;TValue&quot; can be either a string, or an object that has an &quot;id&quot; in it
export const GenericSelect = &lt;TValue extends Base&gt;(props: GenericSelectProps&lt;TValue&gt;) =&gt; {
</code></pre>
<p><strong>Step 2</strong>. Get rid of direct access of <code>value.id</code> . We can do that by converting all those calls to a function <code>getStringFromValue</code>:</p>
<p><img src="https://www.developerway.com/assets/advanced-typescript-for-react-developers/refactoring-example1.png" alt=""/></p>
<p>where the very basic implementation from the before-typescript era would look like this:</p>
<pre><code>const getStringFromValue = (value) =&gt; value.id || value;
</code></pre>
<p>This is not going to fly with typescript though: remember, our <code>value</code> is Generic and can be a string as well as an object, so we need to help typescript here to understand what exactly it is before accessing anything specific.</p>
<pre><code>type Base = { id: string } | string;

const getStringFromValue = &lt;TValue extends Base&gt;(value: TValue) =&gt; {
  if (typeof value === &#x27;string&#x27;) {
    // here &quot;value&quot; will be the type of &quot;string&quot;
    return value;
  }

  // here &quot;value&quot; will be the type of &quot;NOT string&quot;, in our case { id: string }
  return value.id;
};
</code></pre>
<p>The code in the function is known as <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html"><strong>type guard</strong></a> in typescript: an expression that narrows down type within some scope. See what is happening? First, we check whether the <code>value</code> is a string by using the standard javascript <code>typeof</code> operator. Now, within the ‚Äútruthy‚Äù branch of <code>if</code> expression, typescript will know for sure that value is a string, and we can do anything that we‚Äôd usually do with a string there. Outside of it, typescript will know for sure, that the value is <strong>not</strong> a string, and in our case, it means it‚Äôs an object with an <code>id</code> in it. Which allows us to return <code>value.id</code> safely.</p>
<p><strong>Step 3</strong>. Refactor the <code>value[titleKey]</code> access. Considering that a lot of our data types would want to customise their labels, and more likely than not in the future we‚Äôd want to convert it to be even more custom, with icons or special formatting, the easiest option here is just to move the responsibility of extracting required information to the consumer. This can be done by passing a function to select that converts value on the consumer side to a string (or ReactNode in the future). No typescript mysteries here, just normal React:</p>
<pre><code>type GenericSelectProps&lt;TValue&gt; = {
  formatLabel: (value: TValue) =&gt; string;
  ...
};

export const GenericSelect = &lt;TValue extends Base&gt;(props: GenericSelectProps&lt;TValue&gt;) =&gt; {
  ...
  return (
    &lt;select onChange={onSelectChange}&gt;
      {values.map((value) =&gt; (
        &lt;option key={getStringFromValue(value)} value={getStringFromValue(value)}&gt;
          {formatLabel(value)}
        &lt;/option&gt;
      ))}
    &lt;/select&gt;
  );
}

// Show movie title and release date in select label
&lt;GenericSelect&lt;Movie&gt; ... formatLabel={(value) =&gt; `${value.title} (${value.releaseDate})`} /&gt;

// Show laptop model and release date in select label
&lt;GenericSelect&lt;Laptop&gt; ... formatLabel={(value) =&gt; `${value.model, released in ${value.releaseDate}`} /&gt;
</code></pre>
<p>And now we have it! A perfect generic select, that supports all data formats that we need and allows us to fully customise labels as a nice bonus. The full code looks like this:</p>
<pre><code>type Base = { id: string } | string;

type GenericSelectProps&lt;TValue&gt; = {
  formatLabel: (value: TValue) =&gt; string;
  onChange: (value: TValue) =&gt; void;
  values: TValue[];
};

const getStringFromValue = &lt;TValue extends Base&gt;(value: TValue) =&gt; {
  if (typeof value === &#x27;string&#x27;) return value;

  return value.id;
};

export const GenericSelect = &lt;TValue extends Base&gt;(props: GenericSelectProps&lt;TValue&gt;) =&gt; {
  const { values, onChange, formatLabel } = props;

  const onSelectChange = (e) =&gt; {
    const val = values.find((value) =&gt; getStringFromValue(value) === e.target.value);

    if (val) onChange(val);
  };

  return (
    &lt;select onChange={onSelectChange}&gt;
      {values.map((value) =&gt; (
        &lt;option key={getStringFromValue(value)} value={getStringFromValue(value)}&gt;
          {formatLabel(value)}
        &lt;/option&gt;
      ))}
    &lt;/select&gt;
  );
};
</code></pre>
<h2>The list of categories - implementation</h2>
<p>And now, finally, time to implement what we refactored the select component for in the first place: categories for the website. As always, let‚Äôs start simple, and improve things in the process.</p>
<pre><code>const tabs = [&#x27;Books&#x27;, &#x27;Movies&#x27;, &#x27;Laptops&#x27;];

const getSelect = (tab: string) =&gt; {
  switch (tab) {
    case &#x27;Books&#x27;:
      return &lt;GenericSelect&lt;Book&gt; onChange={(value) =&gt; console.info(value)} values={books} /&gt;;
    case &#x27;Movies&#x27;:
      return &lt;GenericSelect&lt;Movie&gt; onChange={(value) =&gt; console.info(value)} values={movies} /&gt;;
    case &#x27;Laptops&#x27;:
      return &lt;GenericSelect&lt;Laptop&gt; onChange={(value) =&gt; console.info(value)} values={laptops} /&gt;;
  }
}

const Tabs = () =&gt; {
  const [tab, setTab] = useState&lt;string&gt;(tabs[0]);

  const select = getSelect(tab);


  return (
    &lt;&gt;
      &lt;GenericSelect&lt;string&gt; onChange={(value) =&gt; setTab(value)} values={tabs} /&gt;
      {select}
    &lt;/&gt;
  );
};
</code></pre>
<p>Dead simple - one select component for choosing a category, based on the chosen value - render another select component.</p>
<p>But again, not exactly typesafe, this time for the tabs: we typed them as just simple <code>string</code>. So a simple typo in the <code>switch</code> statement will go unnoticed or a wrong value in <code>setTab</code> will result in a non-existent category to be chosen. Not good.</p>
<p>And again, typescript has a handy mechanism to improve that:</p>
<pre><code>const tabs = [&#x27;Books&#x27;, &#x27;Movies&#x27;, &#x27;Laptops&#x27;] as const;
</code></pre>
<p>This trick is known as <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions"><strong>const assertion</strong></a>. With this, our <code>tabs</code> array, instead of an array of any random string will turn into a read-only array of those specific values and nothing else.</p>
<pre><code>// an array of values type &quot;string&quot;
const tabs = [&#x27;Books&#x27;, &#x27;Movies&#x27;, &#x27;Laptops&#x27;];

tabs.forEach(tab =&gt; {
  // typescript is fine with that, although there is no &quot;Cats&quot; value in the tabs
  if (tab === &#x27;Cats&#x27;) console.log(tab)
})

// an array of values &#x27;Books&#x27;, &#x27;Movies&#x27; or &#x27;Laptops&#x27;, and nothing else
const tabs = [&#x27;Books&#x27;, &#x27;Movies&#x27;, &#x27;Laptops&#x27;] as const;

tabs.forEach(tab =&gt; {
  // typescript will fail here since there are no Cats in tabs
  if (tab === &#x27;Cats&#x27;) console.log(tab)
})
</code></pre>
<p>Now, all we need to do is to extract type <code>Tab</code> that we can pass to our generic select. First, we can extract the <code>Tabs</code> type by using the <a href="https://www.typescriptlang.org/docs/handbook/2/typeof-types.html"><strong>typeof</strong></a> operator, which is pretty much the same as normal javascript <code>typeof</code>, only it operates on types, not values. This is where the value of <code>as const</code> will be more visible:</p>
<pre><code>const tabs = [&#x27;Books&#x27;, &#x27;Movies&#x27;, &#x27;Laptops&#x27;];
type Tabs = typeof tabs; // Tabs will be string[];

const tabs = [&#x27;Books&#x27;, &#x27;Movies&#x27;, &#x27;Laptops&#x27;] as const;
type Tabs = typeof tabs; // Tabs will be [&#x27;Books&#x27; | &#x27;Movies&#x27; | &#x27;Laptops&#x27;];
</code></pre>
<p>Second, we need to extract <code>Tab</code> type from the Tabs array. This trick is called <a href="https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html"><strong>‚Äúindexed access‚Äù</strong></a>, it‚Äôs a way to access types of properties or individual elements (if array) of another type.</p>
<pre><code>type Tab = Tabs[number]; // Tab will be &#x27;Books&#x27; | &#x27;Movies&#x27; | &#x27;Laptops&#x27;
</code></pre>
<p>Same trick will work with object types, for example we can extract Laptop‚Äôs id into its own type:</p>
<pre><code>type LaptopId = Laptop[&#x27;id&#x27;]; // LaptopId will be string
</code></pre>
<p>Now, that we have a type for individual Tabs, we can use it to type our categories logic:</p>
<p><img src="https://www.developerway.com/assets/advanced-typescript-for-react-developers/final-example.png" alt=""/></p>
<p>And now all the typos or wrong values will be caught by typescript! üí•</p>
<p><a href="https://codesandbox.io/s/eager-brook-vuj8d?file=/src/tabs.tsx">See full working example in the codesandbox</a></p>
<h2>Bonus: type guards and ‚Äúis‚Äù operator</h2>
<p>There is another very interesting thing you can do with type guards. Remember our <code>getStringFromValue</code> function?</p>
<pre><code>type Base = { id: string } | string;

const getStringFromValue = &lt;TValue extends Base&gt;(value: TValue) =&gt; {
  if (typeof value === &#x27;string&#x27;) {
    // here &quot;value&quot; will be the type of &quot;string&quot;
    return value;
  }

  // here &quot;value&quot; will be the type of &quot;NOT string&quot;, in our case { id: string }
  return value.id;
};
</code></pre>
<p>While <code>if (typeof value === ‚Äòstring&#x27;)</code> check is okay for this simple example, in a real-world application you&#x27;d probably want to abstract it away into <code>isStringValue</code>, and refactor the code to be something like this:</p>
<pre><code>type Base = { id: string } | string;

const isStringValue = &lt;TValue&gt;(value: TValue) =&gt; return typeof value === &#x27;string&#x27;;

const getStringFromValue = &lt;TValue extends Base&gt;(value: TValue) =&gt; {
  if (isStringValue(value)) {
    // do something with the string
  }

  // do something with the object
};
</code></pre>
<p>And again the same story as before, there is one problem with the most obvious solution: it‚Äôs not going to work. As soon as type guard condition is extracted into a function like that, it loses its type guarding capabilities. From typescript perspective, it‚Äôs now just a random function that returns a regular boolean value, it doesn‚Äôt know what‚Äôs inside. We‚Äôll have this situation now:</p>
<pre><code>const getStringFromValue = &lt;TValue extends Base&gt;(value: TValue) =&gt; {
  if (isStringValue(value)) { // it&#x27;s just a random function that returns boolean
    // type here will be unrestricted, either string or object
  }

  // type here will be unrestricted, either string or object
  // can&#x27;t return &quot;value.id&quot; anymore, typescript will fail
};
</code></pre>
<p>And again, there is a way to fix it by using yet another typescript concept known as <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates"><strong>‚Äútype predicates‚Äù</strong></a>. Basically, it‚Äôs a way to manually do for the function what typescript was able to do by itself before refactoring. Looks like this:</p>
<pre><code>type T = { id: string };
// can&#x27;t extend Base here, typescript doesn&#x27;t handle generics here well
export const isStringValue = &lt;TValue extends T&gt;(value: TValue | string): value is string =&gt; {
  return typeof value === &#x27;string&#x27;;
};
</code></pre>
<p>See the <code>value is string</code> there? This is the predicate. The pattern is <code>argName is Type</code>, it can be attached <strong>only</strong> to a function with a single argument that returns a boolean value. This expression can be roughly translated into &quot;when this function returns true, assume the value within your execution scope as <code>string</code> type&quot;. So with the predicate, the refactoring will be complete and fully functioning:</p>
<pre><code>type T = { id: string };
type Base = T | string;

export const isStringValue = &lt;TValue extends T&gt;(value: TValue | string): value is string =&gt; {
  return typeof value === &#x27;string&#x27;;
};

const getStringFromValue = &lt;TValue extends Base&gt;(value: TValue) =&gt; {
  if (isStringValue(value)) {
    // do something with the string
  }

  // do something with the object
};
</code></pre>
<p>A pattern like this is especially useful when you have a possibility of different types of data in the same function and you need to do distinguish between them during runtime. In our case, we could define <code>isSomething</code> function for every one of our data types:</p>
<pre><code>export type DataTypes = Book | Movie | Laptop | string;

export const isBook = (value: DataTypes): value is Book =&gt; {
  return typeof value !== &#x27;string&#x27; &amp;&amp; &#x27;id&#x27; in value &amp;&amp; &#x27;author&#x27; in value;
};
export const isMovie = (value: DataTypes): value is Movie =&gt; {
  return typeof value !== &#x27;string&#x27; &amp;&amp; &#x27;id&#x27; in value &amp;&amp; &#x27;releaseDate&#x27; in value &amp;&amp; &#x27;title&#x27; in value;
};
export const isLaptop = (value: DataTypes): value is Laptop =&gt; {
  return typeof value !== &#x27;string&#x27; &amp;&amp; &#x27;id&#x27; in value &amp;&amp; &#x27;model&#x27; in value;
};
</code></pre>
<p>And then implement a function that returns option labels for our selects:</p>
<pre><code>const formatLabel = (value: DataTypes) =&gt; {
  // value will be always Book here since isBook has predicate attached
  if (isBook(value)) return value.author;

  // value will be always Movie here since isMovie has predicate attached
  if (isMovie(value)) return value.releaseDate;

  // value will be always Laptop here since isLaptop has predicate attached
  if (isLaptop(value)) return value.model;

  return value;
};

// somewhere in the render
&lt;GenericSelect&lt;Book&gt; ... formatLabel={formatLabel} /&gt;
&lt;GenericSelect&lt;Movie&gt; ... formatLabel={formatLabel} /&gt;
&lt;GenericSelect&lt;Laptop&gt; ... formatLabel={formatLabel} /&gt;
</code></pre>
<p><a href="https://codesandbox.io/s/immutable-wildflower-n4r8z?file=/src/tabs.tsx">see fully working example in the codesandbox</a></p>
<h2>Time for goodbye</h2>
<p>It‚Äôs amazing, how many advanced typescript concepts we had to use to implement something as simple as a few selects! But it‚Äôs for the better typing world, so I think it‚Äôs worth it. Let‚Äôs recap:</p>
<ul>
<li><strong>‚Äúkeyof‚Äù</strong> - use it to generate types from keys of another type</li>
<li><strong>‚Äúas const‚Äù</strong> - use it to signal to typescript to treat an array or an object as a constant. Use it with combination with <strong>‚Äútype of‚Äù</strong> to generate actual type from it.</li>
<li><strong>‚Äútypeof‚Äù</strong> - same as normal javascript <code>‚Äútypeof‚Äù</code>, but operates on types rather than values</li>
<li><code>Type[&#x27;attr&#x27;]</code> or <code>Type[number]</code> - those are <strong>indexed types</strong>, use them to access subtypes in an Object or an Array respectively</li>
<li><code>argName is Type</code> - <strong>type predicate</strong>, use it to turn a function into a safeguard</li>
</ul>
<p>And now it‚Äôs time to build a better, typesafe future, and we‚Äôre ready for it!</p>]]></content:encoded>
      <enclosure
        url="https://www.developerway.com//assets/advanced-typescript-for-react-developers/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title><![CDATA[Typescript generics for React developers]]></title>
      <link>https://www.developerway.com/posts/typescript-generics-for-react-developers</link>
      <guid>typescript-generics-for-react-developers</guid>
      <pubDate>Thu, 25 Nov 2021 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Looking into why we need generics in Typescript, and how to use them to develop re-usable React components. And as a bonus: the secret of React hooks üòâ]]></description>
      <content:encoded><![CDATA[<p>I don‚Äôt know about you, but I fall asleep every time I‚Äôm trying to read typescript documentation. There is something in the way it is written that signals to my brain that I should not even attempt to comprehend it until I had a good night‚Äôs sleep, three coffees, and ideally some chocolate to stimulate the brain cells. I think I now found my purpose for the next few months: I want to re-write typescript documentation in a way that is actually understandable by a casual reader üòä</p>
<p>Let&#x27;s start with one of the pain points many developers are struggling with: generics! And we‚Äôre going to start with a bottom-up approach: let‚Äôs implement a component without generics, and introduce them only when we need them.</p>
<h2>Intro</h2>
<p>Introducing: Judi üë©üèΩ‚Äçüíª. Judi is a very ambitious developer and wants to implement her own online shop, a competitor to Amazon. She will sell everything there: books, movies, more than a thousand types of various categories of goods. And now she‚Äôs at the stage she needs to implement a page with a bunch of identical-looking selects for multiple categories of goods on the page.</p>
<p><img src="https://www.developerway.com/assets/typescript-generics-for-react-developers/selects.png" alt=""/></p>
<p>She starts very simple: a select component, that accepts an array of options with <code>value</code> and <code>title</code> to render those, and an <code>onChange</code> handler so that she can do something when a value in a select is changed (every select will do different things!).</p>
<pre><code>import React from &#x27;react&#x27;;

type SelectOption = {
  value: string;
  label: string;
};

type SelectProps = {
  options: SelectOption[];
  onChange: (value: string) =&gt; void;
};

export const Select = ({ options, onChange }: SelectProps) =&gt; {
  return (
    &lt;select onChange={(e) =&gt; onChange(e.target.value)}&gt;
      {options.map((option) =&gt; (
        &lt;option key={option.value} value={option.value}&gt;
          {option.label}
        &lt;/option&gt;
      ))}
    &lt;/select&gt;
  );
};
</code></pre>
<p>This seems like an okay solution for the purpose: she can re-use those selects for all her products and take over the online shopping world.</p>
<pre><code>&lt;&gt;
  &lt;Select option={bookOptions} onChange={(bookId) =&gt; doSomethingWithBooks(bookId)} /&gt;
  &lt;Select option={movieOptions} onChange={(movieId) =&gt; doSomethingWithMovies(movieId)} /&gt;
&lt;/&gt;
</code></pre>
<p>Unfortunately, as the shop grew, she found a few problems with this solution:</p>
<ol>
<li>
<p>the select component accepts options in a very specific format, everything needs to be converted to it by the consumer component. And as the shop grows, more and more pages begin to use it, so that conversion code started to bleed all over the place and became hard to maintain.</p>
</li>
<li>
<p><code>onChange</code> handler returns only the <code>id</code> of the changed value, so she needed to manually filter through arrays of data every time she needed to find the actual value that has changed</p>
</li>
<li>
<p>it&#x27;s completely not typesafe, and very easy to make a mistake. Once she used <code>doSomethingWithBooks</code> handler on a select with <code>moviesOptions</code> by mistake, and that blew up the entire page and caused an incident. Customers were not happy üòû</p>
</li>
</ol>
<h2>üí™ Time to refactor</h2>
<p>Judi wanted to significantly improve her application and:</p>
<ul>
<li>get rid of all the code that filters through the arrays of raw data here and there</li>
<li>remove all the code that was generating the select options everywhere</li>
<li>make the select component type-safe, so that next time she uses the wrong handler with a set of options, the type system could catch it</li>
</ul>
<p>She decided, that what she needs is a select component that:</p>
<ul>
<li>accepts an array of typed values and transforms it into select options by itself</li>
<li><code>onChange</code> handler returns the ‚Äúraw‚Äù typed value, not just its id, hence removing the need to manually search for it on the consumer side</li>
<li><code>options</code> and <code>onChange</code> values should be connected; so that if she uses <code>doSomethingWithBooks</code> on a select that accepted movies as value, it would‚Äôve been caught by the type system.</li>
</ul>
<p><img src="https://www.developerway.com/assets/typescript-generics-for-react-developers/example-implementation.png" alt=""/></p>
<p>She already had all her data typed, so only the select component needed some work.</p>
<pre><code>export type Book = {
  id: string;
  title: string;
  author: string; // only books have it
};

export type Movie = {
  id: string;
  title: string;
  releaseDate: string; // only movies have it
};
... // all other types for the shop goods
</code></pre>
<h2>Strongly typed select - first attempt</h2>
<p>Judi, again, started simple: she decided that she‚Äôll implement a select that accepts only books for now, and then just modify it to accept the rest of the types afterwards.</p>
<pre><code>type BookSelectProps = {
  values: Book[];
  onChange: (value: Book) =&gt; void;
};

export const BookSelect = ({ values, onChange }: BookSelectProps) =&gt; {
  const onSelectChange = (e) =&gt; {
    const val = values.find((value) =&gt; value.id === e.target.value);

    if (val) onChange(val);
  };
  return (
    &lt;select onChange={onSelectChange}&gt;
      {values.map((value) =&gt; (
        &lt;option key={value.id} value={value.id}&gt;
          {value.title}
        &lt;/option&gt;
      ))}
    &lt;/select&gt;
  );
};
</code></pre>
<p>This looked great already: now she doesn‚Äôt need to worry about mixing handlers or values up, this select accepts only Books are properties and always returns a Book when a value is changed.</p>
<p><img src="https://www.developerway.com/assets/typescript-generics-for-react-developers/book-select.png" alt=""/></p>
<p>Now, all she needs to do is turn <code>BookSelect</code> into <code>GenericSelect</code> and teach it how to deal with the rest of the data in the app. First, she just tried to do a <a href="https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html">union type</a> on the values (if you‚Äôre not familiar with those - it‚Äôs just a fancy word for <code>or</code> operator for types)</p>
<p><img src="https://www.developerway.com/assets/typescript-generics-for-react-developers/generic-select-props.png" alt=""/></p>
<p>But it was almost instantly obvious to her, that this is not a very good idea. Not only because she‚Äôd have to manually list <em><strong>all</strong></em> supported data types in the select and change it every single time a new data type is added. But it actually made things worst from the code complexity perspective: typescript <em>doesn‚Äôt actually know</em> what exactly is passed in the <code>onChange</code> callback with this approach, regardless of what goes into the <code>values</code>. So even the most obvious and simple use case of logging the author of the selected book will make typescript super confused:</p>
<p><img src="https://www.developerway.com/assets/typescript-generics-for-react-developers/generic-select-error.png" alt=""/></p>
<p>It knows, that in value there can be either <code>Book</code> or <code>Movie</code>, but it doesn‚Äôt know what <em>exactly</em> is there. And since <code>Movie</code> doesn‚Äôt have an author field, typescript will consider the code above an error.</p>
<p>See <a href="https://codesandbox.io/s/bold-germain-ohux0?file=/src/App.tsx">example of this error in codesandbox.</a></p>
<h2>Strongly typed select - actual solution with typescript generics</h2>
<p>And this is finally where typescript <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">generic types</a> could come in handy. Generics, in a nutshell, are nothing more than a placeholder for a type. It‚Äôs a way to tell typescript: I know I will have a type here, but I have no idea what it should be <em><strong>yet</strong></em>, I‚Äôll tell you later. The simplest example of a generic, used in the documentation, is this:</p>
<pre><code>function identity&lt;Type&gt;(a: Type): Type {
  return a;
}
</code></pre>
<p>which translates roughly into: ‚ÄúI want to define a function that accepts an argument of <em><strong>some</strong></em> type and returns a value of exactly the same type. And I will tell you later which type it is.‚Äù</p>
<p>And then later in the code, you can just tell this function what <em>exactly</em> you meant by this placeholder type:</p>
<pre><code>const a = identity&lt;string&gt;(&quot;I&#x27;m a string&quot;) // &quot;a&quot; will be a &quot;string&quot; type
const b = identity&lt;boolean&gt;(false) // &quot;b&quot; will be a &quot;boolean&quot; type
</code></pre>
<p>And then any attempt to mistype it will fail:</p>
<pre><code>const a = identity&lt;string&gt;(false) // typescript will error here, &quot;a&quot; can&#x27;t be boolean
const b = identity&lt;boolean&gt;(&quot;I&#x27;m a string&quot;) // typescript will error here, &quot;b&quot; can&#x27;t be string
</code></pre>
<p>So the way to apply this to the select component is this:</p>
<p><img src="https://www.developerway.com/assets/typescript-generics-for-react-developers/generic-select-proper.png" alt=""/></p>
<p>Now, I intentionally don‚Äôt include code in a copy-pasteable form here, because this example is actually not going to work üòÖ. The first reason is very <em>React in Typescript</em> specific: since this is a React component, typescript will assume that the very first <code>&lt;Tvalue&gt;</code> is a <code>jsx</code> element and will fail. The second reason is exclusively generics problem: when we try to access <code>value.title</code> or <code>value.id</code> in our select, typescript at this point <em><strong>still doesn‚Äôt know</strong></em> which type we have in mind for this value. It has no idea which properties our value can have and rightfully so. Why would it?</p>
<p>This leads us to the last piece of this puzzle: generic <strong>constraints</strong>.</p>
<p><img src="https://www.developerway.com/assets/typescript-generics-for-react-developers/generics-extends.png" alt=""/></p>
<p>Constraints are used to narrow down the generic type so that typescript can make at least some assumptions about <code>TValue</code>. Basically, it‚Äôs a way to tell typescript: I have no idea what <code>TValue</code> should be yet, but I know for a fact that it will always have <em><strong>at least</strong></em> <code>id</code> and <code>title</code>, so you‚Äôre free to assume they will be there.</p>
<p>And now the select component is complete and fully functional! üí• üéâ Check it out:</p>
<pre><code>type Base = {
  id: string;
  title: string;
};

type GenericSelectProps&lt;TValue&gt; = {
  values: TValue[];
  onChange: (value: TValue) =&gt; void;
};

export const GenericSelect = &lt;TValue extends Base&gt;({ values, onChange }: GenericSelectProps&lt;TValue&gt;) =&gt; {
  const onSelectChange = (e) =&gt; {
    const val = values.find((value) =&gt; value.id === e.target.value);

    if (val) onChange(val);
  };

  return (
    &lt;select onChange={onSelectChange}&gt;
      {values.map((value) =&gt; (
        &lt;option key={value.id} value={value.id}&gt;
          {value.title}
        &lt;/option&gt;
      ))}
    &lt;/select&gt;
  );
};
</code></pre>
<p>And Judi finally can use it to implement all the selects that she wants for her Amazon competitor:</p>
<pre><code>// This select is a &quot;Book&quot; type, so the value will be &quot;Book&quot; and only &quot;Book&quot;
&lt;GenericSelect&lt;Book&gt; onChange={(value) =&gt; console.log(value.author)} values={books} /&gt;

// This select is a &quot;Movie&quot; type, so the value will be &quot;Movie&quot; and only &quot;Movie&quot;
&lt;GenericSelect&lt;Movie&gt; onChange={(value) =&gt; console.log(value.releaseDate)} values={movies} /&gt;
</code></pre>
<p>Check out the <a href="https://codesandbox.io/s/relaxed-yalow-p10ee?file=/src/App.tsx">fully working example in codesandbox.</a></p>
<h2>Typescript generics in React hooks bonus</h2>
<p>Did you know that most React hooks are generics as well? You can explicitly type things like <code>useState</code> or <code>useReducer</code> and avoid unfortunate copy-paste driven development mistakes, where you define <code>const [book, setBook] = useState();</code> and then pass a <code>movie</code> value there by accident. Things like that could cause a little crash of reality for the next person who reads the code and sees <code>setBook(movie)</code> during the next refactoring.</p>
<p>This will work fine, although will cause a lot of rage and despair for anyone who‚Äôs trying to fix a bug with this setup:</p>
<pre><code>export const AmazonCloneWithState = () =&gt; {
  const [book, setBook] = useState();
  const [movie, setMovie] = useState();

  return (
    &lt;&gt;
      &lt;GenericSelect&lt;Book&gt; onChange={(value) =&gt; setMovie(value)} values={booksValues} /&gt;
      &lt;GenericSelect&lt;Movie&gt; onChange={(value) =&gt; setBook(value)} values={moviesValues} /&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>This will prevent it, and any malicious attempt to use setBook on a value in the second select will be stopped by typescript:</p>
<pre><code>export const AmazonCloneWithState = () =&gt; {
  const [book, setBook] = useState&lt;Book | undefined&gt;(undefined);
  const [movie, setMovie] = useState&lt;Movie | undefined&gt;(undefined);

  return (
    &lt;&gt;
      &lt;GenericSelect&lt;Book&gt; onChange={(value) =&gt; setBook(value)} values={booksValues} /&gt;
      &lt;GenericSelect&lt;Movie&gt; onChange={(value) =&gt; setMovie(value)} values={moviesValues} /&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>That‚Äôs all for today, hope you enjoyed the reading and generics are not a mystery anymore! ‚úåüèº</p>]]></content:encoded>
      <enclosure
        url="https://www.developerway.com//assets/typescript-generics-for-react-developers/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title><![CDATA[ü¶ò Prison break, or solving life like a developerÔ∏è]]></title>
      <link>https://www.developerway.com/posts/prison-break-solving-life-as-a-developer</link>
      <guid>prison-break-solving-life-as-a-developer</guid>
      <pubDate>Mon, 15 Nov 2021 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[How would you deal with something like relocating to another country and becoming digital nomad? A story on how I took approach that I would use as a developer with large projects at work.]]></description>
      <content:encoded><![CDATA[<p>When is the best time to throw away all your possessions, move to the other side of the world, and begin a completely new life of a digital nomad? In the middle of the global pandemic, obviously üòÖ</p>
<h2>The origin story</h2>
<p>I had a vague dream of ‚Äúit would be cool to move to Europe for a year or two‚Äù for a while now. I lived in Australia for 4 years by then, and while it‚Äôs an incredible country to explore, my restless brain increasingly demanded some radical changes. Covid hit right when I started seriously planning prolonged 2-3 months trips there to fulfil the need the ‚Äúeasy‚Äù way and shattered any possible travel plans. After one and a half years of up and down restrictions, being more and more pissed with Australian politics and its response to the pandemic, and total inability to control my life anymore, the strictest months-long lockdown in Sydney hit us just when the rest of the world started opening up. That was the last straw. In order to capture the last evaporating bits of sanity, I needed to do something now.</p>
<p>Hence the idea: since I can not be here anymore, and I can not just travel as I usually would, can I just relocate and live in Europe for a year? On the surface, no üòï. I‚Äôm in a completely closed country where no one gets in and no one gets out for the foreseeable future; I don‚Äôt have any legal right to live or work in Europe; my job is in Sydney and I‚Äôm not ready to give it up. Bummer.</p>
<h2>The Relocation Project</h2>
<p>So I approached it the way I would deal with a massive terrifying project at work: keep the big picture at the back of your mind, but stop thinking about it. Instead, start slicing it into smaller pieces until every one of them is independent and doable with minimal effort and time.</p>
<p><img src="https://www.developerway.com/assets/prison-break-solving-life-as-a-developer/diagram.png" alt=""/></p>
<p><strong>The project</strong>: relocate Nadia to Europe for a year.</p>
<p><strong>MVP</strong> (minimal viable product):</p>
<ul>
<li>legal right to live and work in Europe for a year</li>
<li>a reliable source of income for a year</li>
<li>a way to leave Australia</li>
</ul>
<p>The complete project would also include things like: what to do with the apartment, with the car and all the things that I own; how to escape lockdown and visit friends before I leave; how to get vaccinated, and so on. But before tackling those, MVP needs to be 100% solved. So let‚Äôs do it step by step.</p>
<h3>üí∏ A reliable source of income for a year</h3>
<p>This step was the easiest for me: I am super lucky to work at a <a href="https://pynhq.com/">startup</a> where the founders build it with the idea of a ‚Äúcompany to serve us‚Äù, not the other way around. So when I had ‚Äúthe talk‚Äù with my boss it was something like this:</p>
<ul>
<li>hey Jon, I‚Äôm going crazy in this corona madness. What do you think if I move to Europe and will work fully remote for a year from the opposite timezone?</li>
<li>of course, no problem, what do you need?</li>
</ul>
<p>‚ù§Ô∏è The first problem solved.</p>
<h3>üá™üá∫ Legal right to live and work in Europe for a year</h3>
<p>After some random mindless googling I discovered the game-changer. Did you know that there is a number of countries, including some European countries in the Schengen zone, that offer <strong><em>digital nomad visas</em></strong>? For real! They specifically target people that have a job already and can perform it remotely from another location. Mind-blowing sign from the universe. After some research, the choice was obvious: Malta and its <a href="https://residencymalta.gov.mt/overview/">Nomad Residence Permit</a> program.</p>
<ul>
<li>they give residency permit that allows staying in Malta for at least one year, with the opportunity to extend</li>
<li>English is widely spoken, so no communication difficulties</li>
<li>it‚Äôs in the Schengen zone, which means unrestricted travel to 25 countries for a year</li>
<li>no double income taxes</li>
<li>looks to be a nice country with rich history, access to the Mediterranean sea and beautiful coastline</li>
</ul>
<p>So without too much thinking, I applied üôÇ. The process was super easy: just collect a bunch of documents from their list, send them to their email, pay the fee, and wait for the decision. And after ~3 weeks I was approved.</p>
<p>üéâ The second problem was solved.</p>
<h3>üê® A way to leave Australia</h3>
<p>Amazingly, this was the hardest part of the project. For context: in March 2020, when Covid hit, Australia closed its borders for everyone, in and out, including its own citizens. Initially for 3 months, to ‚Äúflatten the curve‚Äù and prepare for Covid, but those 3 months turned into almost 2 years, and they still, in November 2021 are partially closed. At the time of The Project (around August 2021), I could only leave Australia if:</p>
<ul>
<li>I had a <em><strong>very valid</strong></em> reason</li>
<li>I am able to prove with documents why my reason is so valid</li>
<li>I apply for an exemption to the Department of Immigration and get it approved</li>
</ul>
<p>Things that are <strong>NOT</strong> valid enough from the government perspective, or at least exemption applications that were denied multiple times that I know of: visiting dying parents, a job offer in another country, reuniting with a partner, going for study for a year, relocating permanently to another country. Around 50% of applications are usually denied. The ‚ÄúTravel Exemption Australia‚Äù group, where people share their stories and help tweak the applications, was one of the most depressing groups ever.</p>
<p>In order to deal with it, I had to turn this into a mini-project within the big Relocation Project.</p>
<p><strong>Step 1</strong>. Research and collect examples of successful applications, extract common patterns and useful phrases from them<br/>
<strong>Step 2</strong>. Collect all the necessary document<br/>
<strong>Step 3</strong>. Write and submit Statutory Declaration: a legal document, in which I had to:<br/></p>
<ul>
<li>declare that I intend to leave Australia for at least a year</li>
<li>describe things that I do to prove the seriousness of my intent (like selling my car, giving up my apartment, the fact that I got the visa for a year)</li>
<li>prove that I can financially support myself during that time (bank statement, employment letter with the salary, letter that I can work remotely)</li>
<li>declare that I understand the risks of travel and under no circumstances going to ask the government for help</li>
</ul>
<p>The consequence of this document is that if I leave Australia, and then return earlier than 3 months (the exemption category), I will be committing a criminal offence. Which, if caught, is punishable by huge fines, or even in theory a prison. So there will be no turning back after I leave üôÇ</p>
<p>ü•≥ Luckily, the hard work and extensive preparation paid out, and the application was approved.</p>
<h2>The new beginning</h2>
<p>After the MVP (minimal viable product) of the Relocation Project was done and successfully released, the rest was just a smooth sail of implementing new easy features üòÖ</p>
<p>I shocked everyone that I‚Äôm leaving Australia soon, got vaccinated (the process of which deserves another article), sold my car, gave up my apartment, got rid of all my stuff, bent lockdown rules a few times to catch up with people, booked the flight, and took off to the new life üõ´</p>
<p>Right now hanging out in Malta, playing with cats that are everywhere here and planning my next adventure.</p>
<p>May the cats be with you ‚úåüèº</p>
<p><img src="https://www.developerway.com/assets/prison-break-solving-life-as-a-developer/cats.jpg" alt=""/></p>]]></content:encoded>
      <enclosure
        url="https://www.developerway.com//assets/prison-break-solving-life-as-a-developer/cats.jpg"
        length="0" type="image/jpg"/>
    </item>
    <item>
      <title><![CDATA[Custom eslint rules + typescript monorepo = ‚ù§Ô∏è]]></title>
      <link>https://www.developerway.com/posts/custom-eslint-rules-typescript-monorepo</link>
      <guid>custom-eslint-rules-typescript-monorepo</guid>
      <pubDate>Sun, 18 Apr 2021 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[A simple trick that allows you to write in typescript and consume right away custom eslint rules. No compilation, build or publish/link step, just write code and use it!]]></description>
      <content:encoded><![CDATA[<p><img src="https://www.developerway.com/assets/custom-eslint-rules-typescript-monorepo/welcome.png" alt=""/></p>
<p>Do you love writing eslint rules as I do? There is something magical and powerful in writing a tiny piece of software that enforces a vision on how the code should look like and even fixes this vision by itself.</p>
<p>Do you love writing strongly typed code as I do? Code autocompletion, bugs are caught before you even save the file, input and output of functions are obvious from their types‚Ä¶ Perrrfect! After a while, writing pure javascript feels like descending into the dark ages.</p>
<p>And here is a bummer: it‚Äôs actually quite hard to make those two get along! Eslint doesn‚Äôt know about typescript existence and doesn‚Äôt support rules written in any other language other than javascript. To solve this, people usually resort to one of those solutions:</p>
<ul>
<li>they either write eslint rules with just javascript and don‚Äôt get the benefits of types at all (<a href="https://github.com/vercel/next.js/tree/canary/packages/eslint-plugin-next/lib/rules">like for example next.js repo does</a>)</li>
<li>or they compile eslint rules to javascript before using them (<a href="https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin-internal/package.json#L5">like for example typescript-eslint repo does</a>)</li>
<li>or even extract eslint rule into their own repository, package it via npm and then consume in the main repo as an external eslint plugin (any other repo that consumes any external eslint plugins)</li>
</ul>
<p>All of the solutions will work, but my little inner perfectionist gets an eye twitch when it sees raw javascript code in the otherwise perfectly typed repository, or cries ‚Äúdev experience üò≠‚Äù when it sees other steps between the writing of the code and its consumption.</p>
<p>Hence this little magic trick that solves this problem and allows you to get the benefits of both worlds and make the dev experience shine. It assumes monorepo setup (yarn workspaces, lerna, pnpm, etc), but the general approach can be used outside of monorepos as well.</p>
<p>Jump straight to the example implementation if you‚Äôd rather read code than words: <a href="https://github.com/adevnadia/custom-eslint-in-typescript">https://github.com/adevnadia/custom-eslint-in-typescript</a></p>
<h2>Step 1: eslint plugin package</h2>
<p>Create a new package <code>esint-plugin-example</code> for the future eslint plugin, with the following structure (or any structure that you prefer to use for your packages and rules of course):</p>
<p><img src="https://www.developerway.com/assets/custom-eslint-rules-typescript-monorepo/image1.png" alt=""/></p>
<p><code>package.json</code> should have the following fields:</p>
<p><img src="https://www.developerway.com/assets/custom-eslint-rules-typescript-monorepo/image2.png" alt=""/></p>
<p>where <code>name</code> should follow <a href="https://eslint.org/docs/2.0.0/developer-guide/working-with-plugins">eslint naming conventions</a> and <code>main</code> should point to <code>index.js</code> file (the only <code>js</code> file we‚Äôd ever need in this setup).</p>
<p><code>index.ts</code>  ‚Äî typescript entry point to the plugin, <a href="https://eslint.org/docs/developer-guide/working-with-plugins">exports the rules</a></p>
<pre><code>import myFirstRule  from &#x27;./rules/my-first-rule&#x27;;

const rules = {
  &#x27;my-first-rule&#x27;: myFirstRule
};

export default rules;
</code></pre>
<p><code>rules/my-first-rule.ts</code> ‚Äî the actual rule implemented for the plugin. In typescript üòç! Make sure to install <code>@types/eslint</code>.</p>
<pre><code>import { Rule } from &#x27;eslint&#x27;;

const rule: Rule.RuleModule = {
    create: (context: Rule.RuleContext) =&gt; {
        return {
            // rule code
        }
    },
};

export default rule;
</code></pre>
<ul>
<li><code>index.js</code> ‚Äî the ‚Äúbridge‚Äù file that makes the whole setup work (see step 3)</li>
</ul>
<h2>Step two: eslint config</h2>
<p>Run <code>yarn install</code> if you‚Äôre on workspaces (or any other linking step that your repo uses), now the package is linked and ready to be consumed.</p>
<p>Add it to the list of <code>eslint</code> plugins and to the list of enabled rules in <code>eslint</code> config file</p>
<pre><code>module.exports = {
  parser: &#x27;@typescript-eslint/parser&#x27;,
  plugins: [&#x27;example&#x27;],
  rules: {
    &#x27;example/my-first-rule&#x27;: &#x27;error&#x27;,
  }
};
</code></pre>
<h2>Step three: the bridge between javascript and typescript</h2>
<p>Final, and most important step ‚Äî teach <code>Node.js</code>to use typescript when running eslint. To do that, add this to our <code>index.js</code> file in the eslint-plugin-example package:</p>
<pre><code>// This registers Typescript compiler instance onto node.js.
// Now it is possible to just require typescript files without any compilation steps in the environment run by node
require(&#x27;ts-node&#x27;).register();
// import our rules from the typescript file
const rules = require(&#x27;./index.ts&#x27;).default;
// re-export our rules so that eslint run by node can understand them
module.exports = {
    rules: rules
};
</code></pre>
<p>That‚Äôs it! Now when you do <code>yarn run eslint</code> in your repo, the beautiful strongly typed rule will be run directly, using the typescript compiler.</p>
<p>Try it out: <a href="https://github.com/adevnadia/custom-eslint-in-typescript">https://github.com/adevnadia/custom-eslint-in-typescript</a></p>
<h3>Little caveat</h3>
<p>Of course, all the good things have their cost. In this case, the cost is ‚Äúpublishing‚Äù ‚Äî if you‚Äôre publishing packages from the repo, you probably raised an eyebrow on the solution above. Unfortunately, since <code>main</code> field in <code>package.json</code> now points to the bridge <code>index.js</code> file, not the compiled code in <code>dist</code> folder, the published package will point to this code as well. There are ways to deal with it: replace <code>main</code> field in the CI before publishing, make use of environment variables in the <code>index.js</code>file or just exclude eslint plugin from publishing at all. The solution depends entirely on what is acceptable in your repo and how much you want to modify the publishing process.</p>
<p>That‚Äôs it, hope this little trick saved you some time and made your inner perfectionist as happy as mine üòä</p>]]></content:encoded>
      <enclosure
        url="https://www.developerway.com//assets/custom-eslint-rules-typescript-monorepo/welcome.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title><![CDATA[Three simple tricks to speed up yarn install]]></title>
      <link>https://www.developerway.com/posts/three-simple-tricks-to-speed-up-yarn-install</link>
      <guid>three-simple-tricks-to-speed-up-yarn-install</guid>
      <pubDate>Mon, 05 Apr 2021 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Those tricks can speed up your yarn install by up to 50%]]></description>
      <content:encoded><![CDATA[<p>Dev productivity and quality of life improvements are a passion of mine. And speeding up working with code is not only fun, but also essential for building products fast. Happier and faster developers equal happier customers, who get their features and bug fixes sooner!</p>
<p>When dealing with npm-based ecosystem and its myriads of packages, dependencies install time, especially in large projects, can be unreasonably long. Below are three simple tricks that can help you shave off a minute or two, or sometimes even reduce your <code>yarn install</code> time by half üòã</p>
<p><img src="https://www.developerway.com/assets/speed-up-yarn-install/compiling.png" alt=""/></p>
<p>Not anymore!</p>
<h2>Bloated yarn.lock problem</h2>
<p>If your project runs on yarn, then more likely than not some of your dependencies will be duplicated, even if they satisfy semver conditions. Although <a href="https://classic.yarnpkg.com/en/docs/cli/dedupe/">yarn promises</a> that deduplication isn‚Äôt necessary, this is not exactly the truth.</p>
<p>Imagine the situation: you‚Äôre adding <code>@awesome/tools</code> library to your dependencies, which also depends on <code>utils@^1.0.0</code>library, which is its latest version. After installing <code>@awesome/tools</code> you‚Äôll see in your <code>yarn.lock</code> file:</p>
<p><img src="https://www.developerway.com/assets/speed-up-yarn-install/image1.png" alt=""/></p>
<p>After a few months you want to add another library that depends on those utils, let‚Äôs say <code>@simple/button</code>. Utils library released a few bug fixes and features in the meantime, and its latest version is now <code>1.5.1</code>, and <code>@simple/button</code>depends on it. If you just run <code>yarn add @simple/button</code>, then in the <code>yarn.lock</code> you will see this picture:</p>
<p><img src="https://www.developerway.com/assets/speed-up-yarn-install/image2.png" alt=""/></p>
<p>Even though <code>1.5.1</code> and <code>1.0.0</code> versions are semver-compatible, yarn will not merge them into one as you‚Äôd expect, and you‚Äôll end up with 2 versions of the same <code>utils</code> in the repo.</p>
<p>It gets worse than that. If you have a few different libraries that depend on version <code>1.0.0</code> and a few that depend on <code>1.5.1</code>, yarn will hoist one of those versions to the root of <code>node_modules</code> folder, but another one would have no place to go (only one version can sit at the root), and they will be installed as <strong><em>copies</em></strong> in <code>node_modules</code> folders of the libraries that use them. You‚Äôll end up with this folder structure:</p>
<p><img src="https://www.developerway.com/assets/speed-up-yarn-install/image3.png" alt=""/></p>
<p>And although it <em>seems</em> like you only have 2 versions of <code>utils</code> library, in reality, it can be 5‚Äì6-infinite-number of its copies living in your project, all of which need to be copied into their place, and all of which will steal your <code>yarn install</code> time.</p>
<h3>Solution</h3>
<p>Deduplicate! Either manually ensure that all semver-compatible libraries resolve to just one version, or use tools like <a href="https://github.com/atlassian/yarn-deduplicate">yarn-deduplicate</a> to automate it for you. This is what you want in your <code>yarn.lock</code>:</p>
<p><img src="https://www.developerway.com/assets/speed-up-yarn-install/image4.png" alt=""/></p>
<p>Just to give you a taste of what‚Äôs possible: in one of the projects I was working on the radical deduplication of all dependencies dropped <code>yarn install</code> time from 3 min to ~1.5min. <strong>50%!</strong></p>
<h2>The dark side of monorepo and workspaces</h2>
<p>If you subscribe to the monorepo school of thoughts and use <a href="https://classic.yarnpkg.com/en/docs/workspaces/">yarn workspaces</a> (or <a href="https://github.com/lerna/lerna">Lerna</a>, which uses workspaces underneath) to manage your packages, you can easily find yourself in a situation where dependencies in your local packages are out of sync with each other. Similar to the situation above, if one of your packages depends on <code>utils@^1.0.0</code> and others on <code>utils@^1.5.1</code>, and those are not deduplicated in the root <code>yarn.lock</code>, yarn will create multiple copies of the version that is not hoisted to the root, and install them in your workspaces‚Äô <code>node_modules</code> folders. In this case you have the potential to end up not only with multiple copies of the same dependency in the root <code>node_modules</code>, but also with the same copies of the dependency scattered all over the repo:</p>
<p><img src="https://www.developerway.com/assets/speed-up-yarn-install/image5.png" alt=""/></p>
<p>In a really big project that I was working on, that had more than 600 workspaces, if we would have allowed as little as 10% of the dependencies to go out of sync, <code>yarn install</code> instead of 5 min would take <strong>an hour</strong>. For 50% it would just throw with ‚Äúout of memory‚Äù error halfway through :)</p>
<h3>Solution</h3>
<p>If migrating to yarn2 or anything pnpm based is not an option (they solve this particular problem), then the only other choice is to keep dependencies in your workspaces strictly in sync with each other and the root <code>package.json</code>. Up to the patch version number, no reliance on semver!</p>
<h2>Nuke node_modules situation</h2>
<p>For some reason, when something weird is happening after updating dependencies in yarn, the very first solution that everyone recommends is to nuke <code>node_modules</code> folder and do a fresh <code>yarn install</code>. It‚Äôs usually the last suggestion as well since it magically fixes 90% of the weirdness cases. After a while, doing <code>rm -rf node_modules &amp;&amp; yarn install</code> develops into a habit that you do every time you check out the main branch and start working on a new feature. All those boring, boring, booooring minutes watching yarn re-installing everything‚Ä¶</p>
<p>If only it could be speeded up a little bit, at least by 50%‚Ä¶</p>
<h3>Solution</h3>
<p>Inside your root <code>node_modules</code> folder there is a secret file <code>.yarn-integrity</code>, where yarn writes down everything that it needs to know about your repository and its installed dependencies. If the content of this file doesn‚Äôt match the situation in the repo, yarn will update it and refresh the installed packages. And if the file is missing, it will generate it based on the <code>yarn.lock</code> and update the content in <code>node_modules</code> with whatever is supposed to be there according to <code>yarn.lock</code>. <strong>Without removing it first</strong>, so if most of the content there is already correct, then it just replaces the incorrect one.</p>
<p>See where this is going? üòâ Instead of <code>rm -rf node_modules &amp;&amp; yarn install</code> habit do</p>
<pre><code>rm -rf node_modules/.yarn-integrity &amp;&amp; yarn install
</code></pre>
<p>üôÉ. It usually <strong><em>halves</em></strong> the time it takes to run <code>yarn install</code> (tested on at least 3 projects of various sizes).</p>
<p>Hope you enjoyed those three little secrets, applied them to your repo and your <code>yarn install</code> is now faster than ever! ü•≥</p>]]></content:encoded>
      <enclosure url="https://www.developerway.com//assets/speed-up-yarn-install/compiling.png"
        length="0" type="image/png"/>
    </item>
    <item>
      <title><![CDATA[Learning by fixing: Node.js, modules and packages]]></title>
      <link>https://www.developerway.com/posts/learning-by-fixing-node-js-modules-and-packages
      </link>
      <guid>learning-by-fixing-node-js-modules-and-packages</guid>
      <pubDate>Mon, 08 Feb 2021 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Learn how Node resolves modules and deals with packages by pretending to be a detective and debugging a mysterious build failure]]></description>
      <content:encoded><![CDATA[<p>Everything is a skill and everything can be learned. Even learning itself is something that can be trained and improved. And in software development, constant learning is at the core of a successful career as a developer. I believe that one of the most efficient ways to gain really deep knowledge fast is not to go through online courses, or not even build something yourself, but to fix a problem.</p>
<p>In this article, I want to share one of the problems that I encountered recently, which turned out a perfect use case to practice deep learning of how and why Node resolves modules and how it deals with packages. I will walk you through the process of finding a solution step by step and explain relevant knowledge and discoveries along the way.</p>
<p>To get the most of the article some experience with modern frontend ecosystem and basic knowledge of tools like npm and webpack would be helpful.</p>
<h2>The mystery</h2>
<p>The project I was working on has a pretty standard frontend setup: React, Next.js, css-in-js, UI components from an external library to build the interface. One day I added a new component, and although everything worked locally, my CI, while attempting to build the website, greeted me with this:</p>
<p><img src="https://www.developerway.com/assets/learning-by-fixing/image1.png" alt=""/></p>
<p>After a bit of ‚Äúerrr, wat?‚Äù, scratching my head furiously, meddling with CI config and doing the usual clean-the-cache, nuke-node-modules cargo-culting activities I managed to reproduce the problem locally. Turned out that:</p>
<ul>
<li>it only happens with the Lozenge component, which uses Compiled - a new css-in-js library</li>
<li>it was working locally because the version of Node in the CI was newer than on my local machine.</li>
</ul>
<p>So clearly the problem was either with Lozenge, or with the Compiled library itself, and clearly, there was something in their code that prevented it from working with the latest Node. So the solution to the problem seemed simple: downgrade version of Node in the CI to unblock my builds and raise an issue with the <a href="https://github.com/atlassian-labs/compiled/issues/501">library</a> in the hope that maintainers, who know their source code, can figure it out.</p>
<p>Only‚Ä¶</p>
<p>What can <em>possibly</em> a Lozenge component, that just renders a few divs, or a css-in-js library, that converts js-written styles into <code>style</code> tags can have, that depends on a version of Node? Especially on an <em>old</em> version of Node? It‚Äôs usually the other way around‚Ä¶</p>
<p>It‚Äôs a proper mystery! Time to put my Sherlock hat on and solve it.</p>
<h2>ESM or CJS</h2>
<p>The very first step of playing a detective would be to take a closer look at the crime scene and extract all available clues from there.</p>
<p><img src="https://www.developerway.com/assets/learning-by-fixing/image2.png" alt=""/></p>
<p>In this case, we can see that a file from the path <code>/dist/cjs/Lozenge/Container.js</code> is trying to require a file with the path <code>/dist/esm/runtime.js</code>. This is the very first case of digging deep in this investigation: what is <code>CJS</code>, <code>ESM</code>, and why the error is there?</p>
<p>First of all, due to various historic reasons, javascript at the beginning didn‚Äôt have any concept of a module, you could not from one file import content of another file. Various attempts to introduce modularity in javascript resulted in a bunch of different formats, with <code>CJS</code> and <code>ESM</code> being the most commonly used ones.</p>
<p>Multiple <a href="https://dev.to/iggredible/what-the-heck-are-cjs-amd-umd-and-esm-ikm">articles</a> and <a href="https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1">deep dives</a> are dedicated to the topic. The key differences that are relevant here:</p>
<p><b>ESM</b> ‚Äî ‚Äúmodern‚Äù format, uses <strong>‚Äúimport‚Äù</strong> syntax, familiar to anyone who ever wrote anything with Typescript or React.</p>
<pre><code>import React from &#x27;react&#x27;;
</code></pre>
<p><b>cjs</b> ‚Äî ‚Äúold‚Äù format, uses ‚Äú<strong>require</strong>‚Äù syntax, mostly could be found in Node apps and in the results of bundlers/compilers since it‚Äôs the only format that Node can understand (until very recently).</p>
<pre><code>const React = require(&#x27;react&#x27;).default;
</code></pre>
<p><code>CJS</code>, since it‚Äôs older, can‚Äôt deal with <code>ESM</code>, any attempts to use ‚Äú<strong>import‚Äù</strong>, or require a file in <code>ESM</code> format, will fail. And this is exactly what is happening: for some reason, Lozenge in <code>CJS</code> format attempts to require <code>runtime.js</code> file in <code>ESM</code> format.</p>
<p>It is not unusual to see both of those formats to be distributed in modern frontend libraries. One of the reasons for this is that <code>ESM</code> code makes it easier for tools like Webpack to do ‚Äútree-shaking‚Äù (elimination of unused code), which positively affects the final javascript size.</p>
<p>In our case, if we look inside project‚Äôs <code>node_modules</code> at what is installed in Lozenge and Compiled, we will see that this is exactly the case for both of them: their respective <code>dist</code> folders contain folders with both <code>CJS</code> and <code>ESM</code> code.</p>
<p><img src="https://www.developerway.com/assets/learning-by-fixing/image3.png" alt=""/></p>
<p>If you‚Äôre not familiar with how <code>node_modules</code> work, this article might be an interesting read: <a href="https://medium.com/@adevnadia/webpack-and-yarn-magic-against-duplicates-in-bundles-52b5e1a5e2e2">https://medium.com/@adevnadia/webpack-and-yarn-magic-against-duplicates-in-bundles-52b5e1a5e2e2</a></p>
<h2>Modules resolution and packages</h2>
<p>Now, that we have an idea of where the problem occurs (<code>CJS</code> module in Lozenge tries to require <code>ESM</code> module from Compiled), it‚Äôs time to dig deeper and understand why exactly this happens. First of all, let‚Äôs check out what is happening in the problematic file <code>/dist/cjs/Lozenge/Container.js</code>:</p>
<pre><code>...
var \_react = \_interopRequireDefault(require(&quot;react&quot;));
var \_runtime = require(&quot;@compiled/react/runtime&quot;);
var \_constants = require(&quot;@atlaskit/theme/constants&quot;);
...
</code></pre>
<p>This looks like would you would typically expect to see in <code>CJS</code> code that was transpiled from something like Typescript, and it gives us a few clues for the further investigation:</p>
<ul>
<li>Compiled‚Äôs runtime is indeed required by the Lozenge, as expected</li>
<li>It is required as a deep import from <code>@compiled/react</code> package</li>
</ul>
<p>If Lozenge for some reason required <code>ESM</code> module directly as a file path, then the problem would have been a bug somewhere in Lozenge‚Äôs compilation process. In this case, however, everything looks fine from the Lozenge perspective, which allows us to eliminate it from the investigation and focus on Compiled only.</p>
<p>Another interesting thing in this code is the deep import from Compiled. Normal packages can only have names composed from 2 parts ‚Äî scope and package name itself, i.e. <code>@compiled/react</code> is the name <a href="https://www.npmjs.com/package/@compiled/react">you‚Äôd see on npm</a>. Additional <code>/runtime</code> suggests that some sort of custom multi-entry strategy is implemented here, likely for the purpose of reducing bundle sizes.</p>
<p>Let&#x27;s take a closer look at Compiled itself now. If we open <code>/node_modules/@compiled/react/</code> folder we‚Äôll see:</p>
<p><img src="https://www.developerway.com/assets/learning-by-fixing/image4.png" alt=""/></p>
<ul>
<li><code>package.json</code> file at the root, with all the usual fields that you‚Äôd expect from an npm package, like <code>name</code>, <code>version</code> or <code>dependencies</code>;</li>
<li><code>dist</code> folder, with <code>CJS</code> and <code>ESM</code> code for the entire package</li>
<li><code>runtime</code> folder, also with <code>package.json</code> file. This one looks weird, it only has a few fields, and all of them are relative links to files inside <code>dist</code> folder. No <code>name</code>, <code>version</code>, etc</li>
</ul>
<p><img src="https://www.developerway.com/assets/learning-by-fixing/image5.png" alt=""/></p>
<p>And good news! We see a direct link to the file that Lozenge somehow was trying to require during the build process ‚Äî <code>‚Äú../dist/esm/runtime.js‚Äù</code> ü•≥. Can it be that something in the build process got confused and mixed up links in <code>main</code> and <code>module</code>? What is the purpose of those by the way, how it works <em>exactly</em>? <a href="https://nodejs.org/api/modules.html">Time to read the docs again</a>, this time digging deep into how Node resolves modules and deals with <code>package.json</code>.</p>
<p>First of all, Node looks for required paths in <code>node_modules</code> folders, starting from the file where <code>require</code> was called, and going up the ancestor tree until it finds something useful (or throws). In our case, it will start from <code>/node_modules/@atlaskit/lozenge/dist/cjs/Lozenge/Container.js</code>, and will attempt to find <code>node_modules</code> in:</p>
<pre><code>- /node_modules/@atlaskit/lozenge/dist/cjs/Lozenge
- /node_modules/@atlaskit/lozenge/dist/cjs
- /node_modules/@atlaskit/lozenge/dist
- /node_modules/@atlaskit/lozenge
- ‚Ä¶
</code></pre>
<p>until it finally reaches the root <code>node_modules</code> where it finds <code>/node_modules/@compiled/react/runtime</code> folder with the weird <code>package.json</code> inside. If I had a version of Compiled in my root <code>package.json</code> different from the one used in Lozenge, then npm would install an additional copy of it in <code>/node_modules/@atlaskit/lozenge/node_modules/@compiled/react</code>, and the search above would have stopped on the fourth step instead of going up to the very root. This is how and why we can use different versions of one package in the same application.</p>
<p><img src="https://www.developerway.com/assets/learning-by-fixing/image5_1.png" alt=""/></p>
<p>On every iteration node will try to find <code>package.json</code> file, and when it does, it will grab <code>main</code> field from it and try to resolve it as a file. Node itself doesn‚Äôt know or care about anything else other than <code>main</code> field, which explains why in our case <code>package.json</code> in <code>@compiled/react/runtime</code> folder looks so weird ‚Äî it‚Äôs not an actual ‚Äúpackage‚Äù, but just a way to trick Node into resolving that file via the simplified path. If we wanted to, we could‚Äôve reached this exact file via <code>require(‚Äò@compiled/react/dist/cjs/runtime/index.js‚Äô)</code>.</p>
<p>In theory, if in <code>main</code> field of that <code>package.json</code> was a link to a <code>ESM</code> file, that would explain our mystery. Unfortunately, the field is absolutely correct and points to <code>CJS</code> file as expected. There is, however, ‚Äúmodule‚Äù field there, which points to what we need! And there is nothing about it in node‚Äôs docs, so it‚Äôs not something that is native to node.</p>
<p><img src="https://www.developerway.com/assets/learning-by-fixing/image6.png" alt=""/></p>
<p>After <a href="https://stackoverflow.com/questions/42708484/what-is-the-module-package-json-field-for">some googling</a>, the investigation revealed the answer: this field is used by bundling tools (Webpack, Rollup, etc) to bypass node‚Äôs standard resolution algorithm, avoid <code>CJS</code> and bundle <code>ESM</code> code directly. This field is de-facto standard, although not supported by node, and widely used by libraries that distribute both <code>CJS</code> and <code>ESM</code> code.</p>
<p>Great, looks like we‚Äôre really close and the answer is right there! Can it be just some really weird edge-casy bug in webpack itself, that somehow confused Lozenge <code>CJS</code> code into using file from <code>module</code> field instead of <code>main</code>? ü•Å Really easy to verify: just replace <code>ESM</code> link in <code>module</code> with <code>CJS</code>, so that it points to the code Lozenge can deal with, run the build, and ü§ûüèΩ‚Ä¶</p>
<p>and‚Ä¶</p>
<p>And it didn‚Äôt work: the build still fails in the exact same place ü§¶üèΩ‚Äç‚ôÄÔ∏è. Looks like this field was not used at all and we‚Äôre clearly missing something. Time to step back a bit, re-group and think some more. What do we know?</p>
<ul>
<li>all the fields are correct and on their places</li>
<li>both <code>CJS</code> and <code>ESM</code> code is there</li>
<li>all the packages are on their right places and according to node resolution algorithm correct code should be used</li>
<li>the build fails on the new version of Node but works on the older one</li>
</ul>
<p>What we don‚Äôt know yet, is what changed? Something was introduced to Node that somehow ruins this perfectly designed investigation. A bit of triaging narrowed down the version where everything starts to fail to <strong>12.17.x</strong>., and its <a href="https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V12.md#12.17.0">changelog</a> gives another clue: this is the version where <code>ESM</code> support was enabled by default, without an additional flag.</p>
<h2>Package exports</h2>
<p>Although ‚ÄúESM support by default‚Äù sounds like good news, it‚Äôs not that helpful in reality: that means that the change that breaks the build could be introduced in any previous version and was just hidden until now. On the other hand, it proves that:</p>
<ul>
<li>whatever happens is related to <code>ESM</code> specifically</li>
<li>and since we verified that all the fields and code are correct, then there <em>has</em> to be something explicit in Compiled, related to <code>ESM</code>, that overrides the default node behaviour</li>
</ul>
<p>At this point I did something that, arguably, I should‚Äôve done at the very beginning of the investigation (but then there wouldn‚Äôt be a good mystery and that article): I searched through any mention of <code>/esm/runtime.js</code> in its source code. And finally, some luck! In the <code>package.json</code> at the root of <code>@compiled/react</code> package, hidden among other fields, there was this:</p>
<p><img src="https://www.developerway.com/assets/learning-by-fixing/image7.png" alt=""/></p>
<p><a href="https://nodejs.org/api/packages.html#packages_package_entry_points">‚ÄúExports‚Äù</a> is a relatively new addition to Node that allows developers to specify multiple entries to the package instead of a single ‚Äúmain‚Äù entry like it was in the past. And if we look at the <a href="https://nodejs.org/api/modules.html#modules_all_together">node modules resolution algorithm</a> again, we will see that introduction of ‚Äúexports‚Äù turns what we discovered earlier in a bit more complicated process: now on every iteration of looking for the right folder Node will try to:</p>
<ul>
<li>parse the required path (<code>@compiled/react/runtime</code>), extract from it package <strong>scope</strong> (<code>@compiled</code>), package <strong>name</strong> (<code>react</code>) and <strong>subpath</strong> (everything else from the path, i.e. <code>/runtime</code>)</li>
<li>If there is a <code>package.json</code> available in the path that is a combination of <strong>scope</strong> + <strong>name</strong> (<code>@compiled/react</code>), then it extracts <code>exports</code> from it and tries to match it with the required <code>path</code></li>
</ul>
<p>And this is finally the end of the mystery! Since Compiled at the root had <code>package.json</code> with exports, node never even reached the weird <code>package.json</code> with the reference to the correct <code>CJS</code> <code>runtime.js</code>, and that‚Äôs why meddling with it didn‚Äôt have any effect on the build. And in the older version of Node <code>exports</code> is not supported, that field was ignored, and the build would use the weird <code>package.json</code> with the correct link and therefore would work. And <code>./runtime</code> entry of <code>exports</code> references <code>ESM</code> module, which is picked up by the Lozenge‚Äôs <code>CJS</code> file and causes the build to fail. Replacing this link with <code>CJS</code> one finally fixes the build locally ü•≥.</p>
<p>Only one thing left to do ‚Äî fix it for real. Just replacing <code>ESM</code> with <code>CJS</code> in the actual library doesn‚Äôt seem like a good idea, that would prevent consumers of the library from using <code>ESM</code> modules completely. Luckily, <a href="https://nodejs.org/api/packages.html#packages_conditional_exports">there is an answer to this</a>: conditional exports. This is a way to map different paths and subpaths depending on certain conditions, for example, <strong>require</strong> or <strong>import</strong> type of modules. And the actual solution, that works both for consumers that want to use <code>CJS</code> or <code>ESM</code> version of Compiled, would look like this:</p>
<p><img src="https://www.developerway.com/assets/learning-by-fixing/image8.png" alt=""/></p>
<p>Now, when <code>CJS</code> Lozenge requires <code>@compiled/react/runtime</code> with Node version more than 12.17.x it will:</p>
<ul>
<li>find <code>@compiled/react</code> folder in project‚Äôs <code>node_modules</code></li>
<li>parse <code>node_modules/@compiled/react/package.json</code> file</li>
<li>extract <code>exports</code> field from it</li>
<li>match <code>./runtime</code> entry with our requested path</li>
<li>detect that the request comes from <code>CJS</code> file and resolve the correct <code>./dist/cjs/runtime.js</code> file</li>
</ul>
<p>And older Node will:</p>
<ul>
<li>find <code>@compiled/react/runtime</code> folder in project‚Äôs <code>node_modules</code></li>
<li>parse <code>node_modules/@compiled/react/runtime/package.json</code> file</li>
<li>extract <code>main</code> field from it</li>
<li>resolve the correct <code>../dist/cjs/runtime.js</code> file</li>
</ul>
<p>And everything now Just Works‚Ñ¢!</p>]]></content:encoded>
      <enclosure url="https://www.developerway.com//assets/learning-by-fixing/image2.png" length="0"
        type="image/png"/>
    </item>
    <item>
      <title><![CDATA[webpack and yarn magic against duplicates in bundles]]></title>
      <link>
        https://www.developerway.com/posts/webpack-and-yarn-magic-against-duplicates-in-bundles
      </link>
      <guid>webpack-and-yarn-magic-against-duplicates-in-bundles</guid>
      <pubDate>Thu, 11 Jun 2020 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[This page describes the theory and some technical details behind the webpack-deduplication-plugin plugin, which helped us reduce javascript size in Jira by ~10%.]]></description>
      <content:encoded><![CDATA[<h2>Setting up the scene</h2>
<p>In order to not to turn this article into a book on modern dependencies and bundling tools, it is assumed that the reader has some understanding of what tools like <b>npm</b>, <b>yarn</b> and <b>webpack</b> are used for in modern frontend projects and want to dig a bit deeper in the magic behind the scenes.</p>
<p>Some terminology used in the article:</p>
<p><p><b>Direct dependencies</b>: packages on which your project relies explicitly. Typically installed via <b>yarn</b> add package-name. The
full list of those can be found in the dependencies field in package.json at the root of the project.</p></p>
<p><p><b>Transitive dependencies</b>: packages on which your project relies implicitly. Those are the dependencies on which your direct
dependencies rely on. Typically you won‚Äôt see them in package.json, but they can be seen, for example, in <b>yarn.lock</b> file.</p></p>
<p><p><b>Duplicated dependencies</b>: transitive dependencies with mismatched versions. If one of the project dependencies has a button package
version 4.0.0 as a transitive dependency and another has the same button version 3.0.0, both of those versions will be installed and the
button dependency will be duplicated.</p></p>
<p><p><b>De-duplication</b>: the process of elimination of duplicated dependencies according to their
<a href="https://semver.org">semver</a>
versions (x.x.x ‚Äî major.minor.patch). Typically, a range of versions within the same major version will contain no breaking changes and
only the latest version within this range can be installed. For example, a button version 4.0.0 and 4.5.6 can be ‚Äúde-duplicated‚Äù and only
4.5.6 version will be installed.</p></p>
<p><p><b>yarn</b>.lock file: an auto-generated file that contains the exact and full list of all direct and transitive dependencies and their
exact versions in <b>yarn</b>-based projects.</p></p>
<h3>The problem of duplicated dependencies</h3>
<p><p>‚ÄúDuplicated‚Äù dependencies in any of the middle- to large scale projects that rely on npm packages are inevitable. When a project has
dozens ‚Äúdirect‚Äù dependencies, and every one of those has their own dependencies, the final number of all packages (direct and transitive)
installed in a project can be close to hundreds. In this situation, it is more likely than not that some of the dependencies will be
duplicated.</p></p>
<p><p>Considering that those are bundled together and served to the customers, in order to reduce the final javascript size it is important to
reduce the number of duplicates to a minimum. This is where the deduplication process comes into play.</p></p>
<h2>Deduplication in yarn</h2>
<p><p>Consider, for example, a project, that among its direct dependencies has <i>modal-dialog@3.0.0</i> and <i>button@2.5.0</i>, and
modal-dialog brings <i>button@2.4.1</i> as a transitive dependency. If left unduplicated, both buttons will exist in the project</p></p>
<p><img src="https://www.developerway.com/assets/webpack-and-yarn/image1.png" alt=""/>
<p>and in yarn.lock we will see something like this:</p></p>
<pre><code>modal-dialog@^3.0.0:
  version &quot;3.0.0&quot;
  resolved &quot;exact-link-to-where-download-modal-dialog-3.0.0-from&quot;
  dependencies:
    button@^2.4.1

button@^2.5.0:
  version &quot;2.5.0&quot;
  resolved &quot;exact-link-to-where-download-2.5.0-version-from&quot;

button@^2.4.1:
  version &quot;2.4.1&quot;
  resolved &quot;exact-link-to-where-download-2.4.1-version-from&quot;
</code></pre>
<p>Now, we know that according to semver button@2.4.1 and button@2.5.0 are compatible, and therefore we can tell yarn to grab the same
button@2.5.0 version for both of them ‚Äî ‚Äúdeduplicate‚Äù them. From the project perspective it will look like this:
<img src="https://www.developerway.com/assets/webpack-and-yarn/image3.png" alt=""/>
and in yarn.lock file we‚Äôll see this:</p>
<pre><code>modal-dialog@^3.0.0:
  version &quot;3.0.0&quot;
  resolved &quot;exact-link-to-where-download-modal-dialog-3.0.0-from&quot;
  dependencies:
    button@^2.4.1

button@^2.4.1, button@^2.5.0:
  version &quot;2.5.0&quot;
  resolved &quot;exact-link-to-where-download-2.5.0-version-from&quot;
</code></pre>
<h3>Deduplication in yarn ‚Äî not compatible version</h3>
<p><p>The above deduplication technic is the only thing that we usually have in the fight against duplicates, and usually, it works quite well.
But what will happen if a project has not-semver-dedupable transitive dependencies? If, for example, our project has modal-dialog@3.0.0,
button@2.5.0 and editor@5000.0.0 as direct dependencies, and those bring button@1.3.0 and button@1.0.0 as transitive dependencies?</p></p>
<p><p>Using the same technique, we can de-duplicate buttons from 1.x.x version, and from the project perspective it will look like this:</p>
<img src="https://www.developerway.com/assets/webpack-and-yarn/image5.png" alt=""/> And in yarn.lock file we will see this:</p>
<pre><code>modal-dialog@^3.0.0:
  version &quot;3.0.0&quot;
  resolved &quot;exact-link-to-where-download-modal-dialog-3.0.0-from&quot;
  dependencies:
    button@^1.0.0

editor@^5000.0.0:
  version &quot;5000.0.0&quot;
  resolved &quot;exact-link-to-where-download-editor-5000.0.0-from&quot;
  dependencies:
    button@^1.3.0

button@^2.5.0:
  version &quot;2.5.0&quot;
  resolved &quot;exact-link-to-where-download-2.5.0-version-from&quot;

button@^1.0.0, button@^1.3.0:
  version &quot;1.3.0&quot;
  resolved &quot;exact-link-to-where-download-1.3.0-version-from&quot;
</code></pre>
<p><p>Two versions of buttons are unavoidable, and in this case, usually, there is nothing we can do other than upgrading the versions of
modal-dialog and editor to the versions when they both have button from 2.x.x range and it can be de-duplicated properly. Typically, in
this case, we stop, say that our project has ‚Äú2 versions of buttons‚Äù and move on with our lives.</p></p>
<p>But what if we dig a little bit further and check out how exactly those 2 buttons are installed on disk and bundled together?</p>
<h3>Duplicated dependencies install</h3>
<p><p>When we install our dependencies via classic yarn or npm (pnpm or yarn 2.0 change the situation and are not considered here), npm hoists
everything that is possible up to the root node_modules. If, for example, in our project above both editor and modal-dialog have a
dependency on the same ‚Äúdeduped‚Äù version of tooltip, but our project does not, npm will install it at the root of the project.</p></p>
<p><img src="https://www.developerway.com/assets/webpack-and-yarn/image7.png" alt=""/> and inside node_modules folder we‚Äôll see this structure:</p>
<pre><code>/node_modules
  /editor
  /modal-dialog
  /tooltip
</code></pre>
<p><p>And because of that, we can be sure that we only have one version of tooltip in the project, even if two completely different dependencies
depend on slightly different versions of it.</p></p>
<p>Unless‚Ä¶</p>
<p><p>Unless those versions are not semver compatible and can not be deduped that easily üò¨ Basically, the situation in the project with buttons
from the above will look like this:</p></p>
<p><img src="https://www.developerway.com/assets/webpack-and-yarn/image9.png" alt=""/></p>
<p><p>Even if dependencies are ‚Äúdeduped‚Äù on yarn.lock level and we ‚Äúofficially‚Äù have only 2 versions of buttons in yarn.lock, every single
package with button@1.3.0 as a dependency will install its own copy of it.</p></p>
<h2>Duplicated dependencies and webpack</h2>
<p><p>So, if a project is bundled with webpack, how exactly it handles the situation from above? It doesn‚Äôt actually (there was webpack dedup
plugin in the long past, but it was removed after webpack 2.0).</p></p>
<p><p>Webpack behind the scenes just builds a graph of all your files and their dependencies based on what‚Äôs installed and required in your
node_modules via
<a href="https://nodejs.org/api/modules.html">normal node resolution algorithm</a>
. TL;DR: every time a file in editor does ‚Äúimport Button from ‚Äòbutton‚Äô;‚Äù, node will try to find this button in the closest node_modules starting
from the parent folder of the file the request appeared. The same story with the modal-dialog. And then, from webpack perspective, the very
final ask for the button will be:</p></p>
<ul><li><p><i>project/node_modules/editor/node_modules/button/index.js</i> ‚Äî when it‚Äôs requested from within editor</p></li><li><p><i>project/node_modules/modal-dialog/node_modules/button/index.js</i> ‚Äî when it‚Äôs requested from within modal-dialog</p></li></ul>
<p>Webpack is not going to check whether they are exactly the same, will treat them as unique files and bundle both of then in the same bundle.
Our ‚Äúduplicated‚Äù button just got double duplicated.</p>
<h3>Deduplication in webpack ‚Äî first attempt</h3>
<p><p>Since those buttons are exactly the same, the very first question that comes into mind: is it possible to take advantage of that and
‚Äútrick‚Äù webpack into recognising it? And indeed, it is possible and it is ridiculously simple.</p></p>
<p><p>Webpack is incredibly flexible, it provides rich plugin interface with access to almost everything you can imagine (and to some things
that you can not), at its core, most of its features are built with plugins as well, and it
<a href="https://webpack.js.org/plugins/">exports a lot of them</a> for others to use.</p></p>
<p><p>One of those plugins is <a href="https://webpack.js.org/plugins/normal-module-replacement-plugin/">NormalModuleReplacementPlugin</a> ‚Äî it
gives the ability to replace one file with another file during build time based on a regular expression. Which is exactly what we need!
The rest is just a matter of coding.</p></p>
<p><p>First, detect all ‚Äúduplicated‚Äù dependencies by grabbing a list of all packages within node_modules and filtering those that have
node_modules in their install path more than once (basically all the ‚Äúnested‚Äù packages from the yarn install chapter above), and group
them by their version from package.json.</p></p>
<p><img src="https://www.developerway.com/assets/webpack-and-yarn/image10.png" alt=""/> Second, replace all encounters of the ‚Äúsame‚Äù package with the very
first one from the list <img src="https://www.developerway.com/assets/webpack-and-yarn/image11.png" alt=""/> And üí•, there is no ‚Äúthird‚Äù, the solution
works, it‚Äôs safe, and reduces bundle sizes in Jira by ~10%. <img src="https://www.developerway.com/assets/webpack-and-yarn/image12.png" alt=""/> The full
implementation was literally just 100 lines. Be mindful with celebrating and copying the approach though, this is not the end of the article
üòâ</p>
<h3>Deduplication in webpack ‚Äî actual solution</h3>
<p><p>While the solution above worked good and safe (we did vigorous testing of it before releasing it to production), it had an unfortunate
side-effect: webpack started to generate assets in non-deterministic way ü§¶‚Äç‚ôÄ On every single re-build it was either moving some pieces of
those ‚Äúduplicated‚Äù modules around or was just generating new internal ids. Any possible reason within the code from our side was
eliminated quite fast. Something weird was happening within webpack internals themselves.</p></p>
<p><p>Debugging what the hell is going on, understanding why and releasing a solution that fixes it for good took a week, deep dive into the
internals of NormalModuleReplacementPlugin and webpack itself and would take another huge article to describe properly. I will try to list
here the most interesting things about yarn and webpack (in no particular order) that were discovered along the way and could be useful
for others to know.</p></p>
<h2>Findings and other curiosities</h2>
<h3>The non-deterministic behaviour is reproducible non-deterministically</h3>
<p><p>If you try to reproduce the non-deterministic part on a small synthetic example, most likely you won‚Äôt be able to. I was only able to do
so it in my toy repo when I imported the entire @atlaskit/editor to it, just a combination of a few Atlaskit components didn‚Äôt do it.
Reducing the chunk size to a minimum to make webpack split code, manual async imports also didn‚Äôt help.</p></p>
<p><p>Interestingly, the order in which the hook that you need to listen to in order to override requests for files is always different, but the
final assets on small examples (and without deduping for that matter) are deterministic.</p></p>
<h3>NormalModuleReplacementPlugin was not built for the purpose.</h3>
<p><p>First of all, it executes the RegExp only on request property of the result and replaces only request as well
<a href="https://github.com/webpack/webpack/blob/master/lib/NormalModuleReplacementPlugin.js">(check out the source)</a>
. However, there are many more properties in the result object that contain information about the origin of the module (and in theory need
to be replaced as well), one of which is context ‚Äî where the request actually originated from. And if a file is requested relatively, it will
have a relative path in the request property as well.</p></p>
<pre><code>{
  request: &quot;./styled&quot;,
  context: &quot;/project/node_modules/editor/node_modules/button&quot;
}
</code></pre>
<p><p>The final ‚Äúpath‚Äù to the file is a resolution of both, and in order to properly detect ‚Äúduplicates‚Äù, we need to watch them both and replace
<b>all</b> the fields that have the ‚Äúduplicated‚Äù information (including context), which NormalModuleReplacementPlugin does not do.</p></p>
<h3>Nevertheless, NormalModuleReplacementPlugin can actually be used if there is a need</h3>
<p><p>Because everything that is said in the ‚Äúfinding‚Äù above is not entirely correct, and what turned out to be enough in the end is to replace
just request with the resolved absolute path from both of those.</p></p>
<p>From this:</p>
<pre><code>{
  request: &quot;./styled&quot;,
  context: &quot;/project/node_modules/editor/node_modules/button&quot;
}
</code></pre>
<p>it transforms into this</p>
<pre><code>{
  request: &quot;/project/node_modules/modal-dialog/node_modules/button/styled&quot;,
  context: &quot;/project/node_modules/editor/node_modules/button&quot;
}
</code></pre>
<p>and webpack is okay with it and able to correctly bundle it üò≤</p>
<h3>‚Äúnaive‚Äù replace (string.startsWith) is not going to work</h3>
<p>Even if in theory if packages are ‚Äúthe same‚Äù, in reality, they are not, and the difference is called ‚Äútransitive dependencies of transitive dependencies‚Äù. The ‚Äúsimplest‚Äù example of the use case would be:</p>
<ul><li>button@2.x and icon@3.x at the root</li>
<li>editor has button@1.x as a transitive dependency, which has icon@1.x as a transitive dependency</li><li><p>modal-dialog has button@1.x as a transitive dependency, which has icon@1.x as a transitive dependency PLUS it has icon@2.x as its own
transitive dependency (those who survived and read til this moment ‚Äî kudos to you, you‚Äôre heroes)</p></li></ul>
<p><img src="https://www.developerway.com/assets/webpack-and-yarn/image16.png" alt=""/></p>
<p>this will be represented as the following folder structure:</p>
<pre><code>/node_modules
  /editor
    /node_modules
      /button-1.3.0
      /icon-1.0.0 // on the same level as button above
  /modal-dialog
    /node_modules
      /button-1.3.0
        /node_modules
          /icons-1.0.0 // nested within button since on the lvl above there is another icon
      /icon-2.0.0
  /button-2.5.0
</code></pre>
<p>and final requests to icon@1.x will be:</p>
<pre><code>/project/node_modules/editor/node_modules/icon-1.0.0
/project/node_modules/modal_dialog/node_modules/button-1.3.0/node_modules/icon-1.0.0
</code></pre>
<p>considering that button@1.x is a duplicate, we need to replace button in modal_dialog with the button from editor. And just ‚Äúnaive‚Äù startsWith will replace</p>
<pre><code>/project/node_modules/modal_dialog/node_modules/button-1.3.0
</code></pre>
<p>with</p>
<pre><code>/project/node_modules/editor/node_modules/button-1.3.0
</code></pre>
<p>and the path to the last icon will be transformed into</p>
<pre><code>/project/node_modules/editor/node_modules/button-1.3.0/node_modules/icon-1.0.0
</code></pre>
<h2>The end</h2>
<p>So, what was the final reason for non-deterministic behaviour? It is actually a combination of the:</p>
<ul><li>non-deterministic order of hooks on the webpack side</li>
<li>‚Äúnaive‚Äù initial strings replacement</li>
<li>listening and replacing only ‚Äúrequest‚Äù in the initial implementation</li>
<li>a few other edge cases that are not mentioned here and that caused not all modules to be resolved</li></ul>
<p>Now, that it‚Äôs solved, and the plugin was battle-tested in Jira, everyone else can use it too and shrink their bundles a bit. In Jira it
gave us ~10% overall of the bundle size reduction and ~300ms TTI improvement in the Issue View page. The plugin is available here:</p>
<p><a href="https://github.com/atlassian-labs/webpack-deduplication-plugin">https://github.com/atlassian-labs/webpack-deduplication-plugin</a></p>]]></content:encoded>
      <enclosure url="https://www.developerway.com//assets/webpack-and-yarn/image-preview.png"
        length="0" type="image/png"/>
    </item>
  </channel>
</rss>
